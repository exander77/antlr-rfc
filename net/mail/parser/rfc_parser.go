// Code generated from RFC.g4 by ANTLR 4.8. DO NOT EDIT.

package parser // RFC

import (
	"fmt"
	"reflect"
	"strconv"

	"github.com/antlr/antlr4/runtime/Go/antlr"
)

// Suppress unused import errors
var _ = fmt.Printf
var _ = reflect.Copy
var _ = strconv.Itoa

var parserATN = []uint16{
	3, 24715, 42794, 33075, 47597, 16764, 15335, 30598, 22884, 3, 131, 967,
	4, 2, 9, 2, 4, 3, 9, 3, 4, 4, 9, 4, 4, 5, 9, 5, 4, 6, 9, 6, 4, 7, 9, 7,
	4, 8, 9, 8, 4, 9, 9, 9, 4, 10, 9, 10, 4, 11, 9, 11, 4, 12, 9, 12, 4, 13,
	9, 13, 4, 14, 9, 14, 4, 15, 9, 15, 4, 16, 9, 16, 4, 17, 9, 17, 4, 18, 9,
	18, 4, 19, 9, 19, 4, 20, 9, 20, 4, 21, 9, 21, 4, 22, 9, 22, 4, 23, 9, 23,
	4, 24, 9, 24, 4, 25, 9, 25, 4, 26, 9, 26, 4, 27, 9, 27, 4, 28, 9, 28, 4,
	29, 9, 29, 4, 30, 9, 30, 4, 31, 9, 31, 4, 32, 9, 32, 4, 33, 9, 33, 4, 34,
	9, 34, 4, 35, 9, 35, 4, 36, 9, 36, 4, 37, 9, 37, 4, 38, 9, 38, 4, 39, 9,
	39, 4, 40, 9, 40, 4, 41, 9, 41, 4, 42, 9, 42, 4, 43, 9, 43, 4, 44, 9, 44,
	4, 45, 9, 45, 4, 46, 9, 46, 4, 47, 9, 47, 4, 48, 9, 48, 4, 49, 9, 49, 4,
	50, 9, 50, 4, 51, 9, 51, 4, 52, 9, 52, 4, 53, 9, 53, 4, 54, 9, 54, 4, 55,
	9, 55, 4, 56, 9, 56, 4, 57, 9, 57, 4, 58, 9, 58, 4, 59, 9, 59, 4, 60, 9,
	60, 4, 61, 9, 61, 4, 62, 9, 62, 4, 63, 9, 63, 4, 64, 9, 64, 4, 65, 9, 65,
	4, 66, 9, 66, 4, 67, 9, 67, 4, 68, 9, 68, 4, 69, 9, 69, 4, 70, 9, 70, 4,
	71, 9, 71, 4, 72, 9, 72, 4, 73, 9, 73, 4, 74, 9, 74, 4, 75, 9, 75, 4, 76,
	9, 76, 4, 77, 9, 77, 4, 78, 9, 78, 4, 79, 9, 79, 4, 80, 9, 80, 4, 81, 9,
	81, 4, 82, 9, 82, 4, 83, 9, 83, 4, 84, 9, 84, 4, 85, 9, 85, 4, 86, 9, 86,
	4, 87, 9, 87, 4, 88, 9, 88, 4, 89, 9, 89, 4, 90, 9, 90, 4, 91, 9, 91, 3,
	2, 3, 2, 3, 2, 5, 2, 186, 10, 2, 3, 2, 5, 2, 189, 10, 2, 3, 3, 7, 3, 192,
	10, 3, 12, 3, 14, 3, 195, 11, 3, 3, 3, 5, 3, 198, 10, 3, 3, 3, 6, 3, 201,
	10, 3, 13, 3, 14, 3, 202, 3, 3, 5, 3, 206, 10, 3, 3, 4, 3, 4, 3, 4, 3,
	4, 3, 4, 5, 4, 213, 10, 4, 3, 5, 3, 5, 3, 5, 3, 5, 5, 5, 219, 10, 5, 3,
	6, 3, 6, 5, 6, 223, 10, 6, 3, 6, 7, 6, 226, 10, 6, 12, 6, 14, 6, 229, 11,
	6, 3, 6, 5, 6, 232, 10, 6, 3, 6, 3, 6, 3, 7, 5, 7, 237, 10, 7, 3, 7, 6,
	7, 240, 10, 7, 13, 7, 14, 7, 241, 3, 7, 5, 7, 245, 10, 7, 3, 7, 5, 7, 248,
	10, 7, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8,
	3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 3, 8, 5, 8,
	272, 10, 8, 3, 9, 5, 9, 275, 10, 9, 3, 9, 6, 9, 278, 10, 9, 13, 9, 14,
	9, 279, 3, 9, 5, 9, 283, 10, 9, 3, 10, 6, 10, 286, 10, 10, 13, 10, 14,
	10, 287, 3, 10, 3, 10, 6, 10, 292, 10, 10, 13, 10, 14, 10, 293, 7, 10,
	296, 10, 10, 12, 10, 14, 10, 299, 11, 10, 3, 11, 5, 11, 302, 10, 11, 3,
	11, 3, 11, 5, 11, 306, 10, 11, 3, 11, 5, 11, 309, 10, 11, 3, 12, 3, 12,
	3, 12, 3, 12, 3, 12, 5, 12, 316, 10, 12, 3, 13, 3, 13, 5, 13, 320, 10,
	13, 3, 14, 5, 14, 323, 10, 14, 3, 14, 7, 14, 326, 10, 14, 12, 14, 14, 14,
	329, 11, 14, 3, 14, 5, 14, 332, 10, 14, 3, 15, 5, 15, 335, 10, 15, 3, 15,
	3, 15, 3, 15, 3, 15, 5, 15, 341, 10, 15, 3, 16, 3, 16, 3, 16, 3, 16, 5,
	16, 347, 10, 16, 3, 17, 6, 17, 350, 10, 17, 13, 17, 14, 17, 351, 3, 17,
	5, 17, 355, 10, 17, 3, 18, 3, 18, 3, 18, 5, 18, 360, 10, 18, 3, 18, 3,
	18, 3, 18, 5, 18, 365, 10, 18, 3, 19, 5, 19, 368, 10, 19, 3, 19, 3, 19,
	5, 19, 372, 10, 19, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3,
	20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20, 3, 20,
	3, 20, 3, 20, 3, 20, 5, 20, 395, 10, 20, 3, 21, 3, 21, 3, 21, 3, 21, 3,
	22, 5, 22, 402, 10, 22, 3, 22, 3, 22, 5, 22, 406, 10, 22, 3, 22, 3, 22,
	3, 22, 5, 22, 411, 10, 22, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23,
	3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3,
	23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 3, 23, 5, 23, 449,
	10, 23, 3, 24, 3, 24, 3, 24, 3, 24, 3, 24, 6, 24, 456, 10, 24, 13, 24,
	14, 24, 457, 3, 24, 3, 24, 3, 24, 5, 24, 463, 10, 24, 3, 25, 3, 25, 5,
	25, 467, 10, 25, 3, 26, 3, 26, 3, 26, 3, 26, 3, 26, 5, 26, 474, 10, 26,
	3, 27, 3, 27, 5, 27, 478, 10, 27, 3, 27, 5, 27, 481, 10, 27, 3, 28, 3,
	28, 5, 28, 485, 10, 28, 3, 28, 5, 28, 488, 10, 28, 3, 29, 3, 29, 5, 29,
	492, 10, 29, 3, 29, 5, 29, 495, 10, 29, 3, 30, 3, 30, 3, 30, 3, 31, 3,
	31, 3, 31, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 3, 32, 5, 32, 509, 10, 32,
	3, 33, 3, 33, 5, 33, 513, 10, 33, 3, 34, 3, 34, 5, 34, 517, 10, 34, 3,
	35, 5, 35, 520, 10, 35, 3, 35, 3, 35, 3, 35, 3, 35, 5, 35, 526, 10, 35,
	3, 36, 5, 36, 529, 10, 36, 3, 36, 3, 36, 5, 36, 533, 10, 36, 3, 36, 3,
	36, 5, 36, 537, 10, 36, 3, 36, 5, 36, 540, 10, 36, 3, 37, 3, 37, 3, 37,
	5, 37, 545, 10, 37, 3, 37, 5, 37, 548, 10, 37, 3, 37, 5, 37, 551, 10, 37,
	3, 38, 3, 38, 3, 39, 3, 39, 3, 39, 7, 39, 558, 10, 39, 12, 39, 14, 39,
	561, 11, 39, 3, 39, 5, 39, 564, 10, 39, 3, 40, 3, 40, 3, 40, 7, 40, 569,
	10, 40, 12, 40, 14, 40, 572, 11, 40, 3, 40, 5, 40, 575, 10, 40, 3, 41,
	3, 41, 3, 41, 5, 41, 580, 10, 41, 3, 42, 3, 42, 3, 42, 5, 42, 585, 10,
	42, 3, 42, 3, 42, 3, 42, 5, 42, 590, 10, 42, 5, 42, 592, 10, 42, 3, 43,
	6, 43, 595, 10, 43, 13, 43, 14, 43, 596, 3, 44, 3, 44, 3, 44, 5, 44, 602,
	10, 44, 3, 45, 3, 45, 3, 45, 5, 45, 607, 10, 45, 3, 46, 5, 46, 610, 10,
	46, 3, 46, 3, 46, 5, 46, 614, 10, 46, 3, 46, 7, 46, 617, 10, 46, 12, 46,
	14, 46, 620, 11, 46, 3, 46, 5, 46, 623, 10, 46, 3, 46, 3, 46, 5, 46, 627,
	10, 46, 3, 47, 3, 47, 3, 47, 3, 47, 5, 47, 633, 10, 47, 3, 48, 3, 48, 3,
	48, 3, 48, 3, 48, 5, 48, 640, 10, 48, 3, 49, 3, 49, 3, 50, 3, 50, 3, 51,
	3, 51, 3, 51, 3, 51, 3, 51, 5, 51, 651, 10, 51, 3, 52, 3, 52, 3, 52, 3,
	52, 7, 52, 657, 10, 52, 12, 52, 14, 52, 660, 11, 52, 3, 53, 5, 53, 663,
	10, 53, 3, 53, 6, 53, 666, 10, 53, 13, 53, 14, 53, 667, 3, 54, 5, 54, 671,
	10, 54, 3, 54, 3, 54, 5, 54, 675, 10, 54, 3, 55, 5, 55, 678, 10, 55, 3,
	55, 3, 55, 5, 55, 682, 10, 55, 3, 55, 5, 55, 685, 10, 55, 3, 56, 5, 56,
	688, 10, 56, 3, 56, 3, 56, 6, 56, 692, 10, 56, 13, 56, 14, 56, 693, 3,
	56, 5, 56, 697, 10, 56, 3, 57, 5, 57, 700, 10, 57, 3, 57, 3, 57, 5, 57,
	704, 10, 57, 3, 57, 5, 57, 707, 10, 57, 3, 58, 5, 58, 710, 10, 58, 3, 58,
	3, 58, 5, 58, 714, 10, 58, 3, 58, 5, 58, 717, 10, 58, 3, 59, 5, 59, 720,
	10, 59, 3, 59, 3, 59, 5, 59, 724, 10, 59, 3, 59, 5, 59, 727, 10, 59, 3,
	60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60,
	3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3,
	60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60, 3, 60,
	3, 60, 5, 60, 762, 10, 60, 3, 61, 5, 61, 765, 10, 61, 3, 61, 3, 61, 3,
	61, 3, 61, 3, 61, 5, 61, 772, 10, 61, 3, 62, 3, 62, 3, 62, 3, 63, 3, 63,
	7, 63, 779, 10, 63, 12, 63, 14, 63, 782, 11, 63, 3, 63, 3, 63, 3, 63, 3,
	63, 5, 63, 788, 10, 63, 3, 63, 3, 63, 5, 63, 792, 10, 63, 7, 63, 794, 10,
	63, 12, 63, 14, 63, 797, 11, 63, 3, 64, 5, 64, 800, 10, 64, 3, 64, 7, 64,
	803, 10, 64, 12, 64, 14, 64, 806, 11, 64, 3, 64, 3, 64, 3, 64, 3, 64, 5,
	64, 812, 10, 64, 7, 64, 814, 10, 64, 12, 64, 14, 64, 817, 11, 64, 3, 65,
	5, 65, 820, 10, 65, 3, 65, 7, 65, 823, 10, 65, 12, 65, 14, 65, 826, 11,
	65, 3, 65, 3, 65, 3, 65, 3, 65, 5, 65, 832, 10, 65, 7, 65, 834, 10, 65,
	12, 65, 14, 65, 837, 11, 65, 3, 66, 5, 66, 840, 10, 66, 3, 66, 6, 66, 843,
	10, 66, 13, 66, 14, 66, 844, 3, 66, 5, 66, 848, 10, 66, 3, 67, 3, 67, 3,
	67, 7, 67, 853, 10, 67, 12, 67, 14, 67, 856, 11, 67, 3, 68, 3, 68, 3, 68,
	7, 68, 861, 10, 68, 12, 68, 14, 68, 864, 11, 68, 3, 69, 3, 69, 5, 69, 868,
	10, 69, 3, 70, 3, 70, 5, 70, 872, 10, 70, 3, 71, 3, 71, 3, 72, 3, 72, 3,
	73, 3, 73, 3, 74, 3, 74, 3, 74, 3, 75, 3, 75, 5, 75, 885, 10, 75, 3, 76,
	3, 76, 3, 77, 3, 77, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 3, 78, 5,
	78, 898, 10, 78, 3, 79, 3, 79, 3, 80, 3, 80, 3, 81, 3, 81, 3, 81, 3, 81,
	7, 81, 908, 10, 81, 12, 81, 14, 81, 911, 11, 81, 3, 82, 3, 82, 3, 83, 3,
	83, 5, 83, 917, 10, 83, 3, 84, 3, 84, 5, 84, 921, 10, 84, 3, 85, 5, 85,
	924, 10, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3, 85, 3,
	85, 3, 85, 3, 85, 3, 85, 5, 85, 938, 10, 85, 3, 86, 3, 86, 3, 86, 3, 86,
	3, 86, 3, 86, 3, 86, 5, 86, 947, 10, 86, 3, 87, 3, 87, 5, 87, 951, 10,
	87, 3, 88, 3, 88, 3, 89, 3, 89, 3, 90, 6, 90, 958, 10, 90, 13, 90, 14,
	90, 959, 3, 91, 6, 91, 963, 10, 91, 13, 91, 14, 91, 964, 3, 91, 2, 2, 92,
	2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24, 26, 28, 30, 32, 34, 36, 38,
	40, 42, 44, 46, 48, 50, 52, 54, 56, 58, 60, 62, 64, 66, 68, 70, 72, 74,
	76, 78, 80, 82, 84, 86, 88, 90, 92, 94, 96, 98, 100, 102, 104, 106, 108,
	110, 112, 114, 116, 118, 120, 122, 124, 126, 128, 130, 132, 134, 136, 138,
	140, 142, 144, 146, 148, 150, 152, 154, 156, 158, 160, 162, 164, 166, 168,
	170, 172, 174, 176, 178, 180, 2, 47, 3, 2, 7, 13, 3, 2, 16, 65, 3, 2, 67,
	100, 3, 2, 9, 65, 4, 2, 51, 51, 83, 83, 4, 2, 53, 53, 85, 85, 4, 2, 52,
	52, 84, 84, 4, 2, 58, 58, 90, 90, 4, 2, 59, 59, 91, 91, 4, 2, 43, 43, 75,
	75, 4, 2, 61, 61, 93, 93, 4, 2, 42, 42, 74, 74, 4, 2, 46, 46, 78, 78, 4,
	2, 44, 44, 76, 76, 4, 2, 56, 56, 88, 88, 4, 2, 47, 47, 79, 79, 4, 2, 57,
	57, 89, 89, 4, 2, 39, 39, 71, 71, 4, 2, 48, 48, 80, 80, 4, 2, 40, 40, 72,
	72, 4, 2, 54, 54, 86, 86, 4, 2, 63, 63, 95, 95, 4, 2, 50, 50, 82, 82, 4,
	2, 45, 45, 77, 77, 4, 2, 41, 41, 73, 73, 4, 2, 60, 60, 92, 92, 4, 2, 17,
	17, 19, 19, 3, 2, 7, 64, 3, 2, 68, 100, 3, 2, 102, 109, 3, 2, 112, 129,
	3, 2, 39, 47, 3, 2, 49, 64, 3, 2, 71, 79, 3, 2, 81, 96, 3, 2, 39, 64, 3,
	2, 71, 96, 3, 2, 22, 23, 4, 2, 3, 100, 102, 130, 4, 2, 3, 5, 101, 129,
	3, 2, 22, 31, 3, 2, 7, 100, 3, 2, 16, 17, 3, 2, 7, 36, 3, 2, 38, 100, 2,
	1097, 2, 188, 3, 2, 2, 2, 4, 205, 3, 2, 2, 2, 6, 212, 3, 2, 2, 2, 8, 218,
	3, 2, 2, 2, 10, 220, 3, 2, 2, 2, 12, 247, 3, 2, 2, 2, 14, 271, 3, 2, 2,
	2, 16, 274, 3, 2, 2, 2, 18, 285, 3, 2, 2, 2, 20, 301, 3, 2, 2, 2, 22, 315,
	3, 2, 2, 2, 24, 319, 3, 2, 2, 2, 26, 327, 3, 2, 2, 2, 28, 334, 3, 2, 2,
	2, 30, 346, 3, 2, 2, 2, 32, 354, 3, 2, 2, 2, 34, 359, 3, 2, 2, 2, 36, 371,
	3, 2, 2, 2, 38, 394, 3, 2, 2, 2, 40, 396, 3, 2, 2, 2, 42, 410, 3, 2, 2,
	2, 44, 448, 3, 2, 2, 2, 46, 462, 3, 2, 2, 2, 48, 464, 3, 2, 2, 2, 50, 468,
	3, 2, 2, 2, 52, 480, 3, 2, 2, 2, 54, 487, 3, 2, 2, 2, 56, 494, 3, 2, 2,
	2, 58, 496, 3, 2, 2, 2, 60, 499, 3, 2, 2, 2, 62, 508, 3, 2, 2, 2, 64, 512,
	3, 2, 2, 2, 66, 516, 3, 2, 2, 2, 68, 519, 3, 2, 2, 2, 70, 539, 3, 2, 2,
	2, 72, 541, 3, 2, 2, 2, 74, 552, 3, 2, 2, 2, 76, 563, 3, 2, 2, 2, 78, 574,
	3, 2, 2, 2, 80, 579, 3, 2, 2, 2, 82, 581, 3, 2, 2, 2, 84, 594, 3, 2, 2,
	2, 86, 601, 3, 2, 2, 2, 88, 606, 3, 2, 2, 2, 90, 609, 3, 2, 2, 2, 92, 632,
	3, 2, 2, 2, 94, 639, 3, 2, 2, 2, 96, 641, 3, 2, 2, 2, 98, 643, 3, 2, 2,
	2, 100, 645, 3, 2, 2, 2, 102, 652, 3, 2, 2, 2, 104, 665, 3, 2, 2, 2, 106,
	670, 3, 2, 2, 2, 108, 677, 3, 2, 2, 2, 110, 687, 3, 2, 2, 2, 112, 699,
	3, 2, 2, 2, 114, 709, 3, 2, 2, 2, 116, 719, 3, 2, 2, 2, 118, 761, 3, 2,
	2, 2, 120, 764, 3, 2, 2, 2, 122, 773, 3, 2, 2, 2, 124, 780, 3, 2, 2, 2,
	126, 804, 3, 2, 2, 2, 128, 824, 3, 2, 2, 2, 130, 842, 3, 2, 2, 2, 132,
	849, 3, 2, 2, 2, 134, 857, 3, 2, 2, 2, 136, 867, 3, 2, 2, 2, 138, 871,
	3, 2, 2, 2, 140, 873, 3, 2, 2, 2, 142, 875, 3, 2, 2, 2, 144, 877, 3, 2,
	2, 2, 146, 879, 3, 2, 2, 2, 148, 884, 3, 2, 2, 2, 150, 886, 3, 2, 2, 2,
	152, 888, 3, 2, 2, 2, 154, 897, 3, 2, 2, 2, 156, 899, 3, 2, 2, 2, 158,
	901, 3, 2, 2, 2, 160, 909, 3, 2, 2, 2, 162, 912, 3, 2, 2, 2, 164, 916,
	3, 2, 2, 2, 166, 920, 3, 2, 2, 2, 168, 923, 3, 2, 2, 2, 170, 946, 3, 2,
	2, 2, 172, 950, 3, 2, 2, 2, 174, 952, 3, 2, 2, 2, 176, 954, 3, 2, 2, 2,
	178, 957, 3, 2, 2, 2, 180, 962, 3, 2, 2, 2, 182, 185, 7, 66, 2, 2, 183,
	186, 5, 164, 83, 2, 184, 186, 5, 166, 84, 2, 185, 183, 3, 2, 2, 2, 185,
	184, 3, 2, 2, 2, 186, 189, 3, 2, 2, 2, 187, 189, 5, 100, 51, 2, 188, 182,
	3, 2, 2, 2, 188, 187, 3, 2, 2, 2, 189, 3, 3, 2, 2, 2, 190, 192, 5, 166,
	84, 2, 191, 190, 3, 2, 2, 2, 192, 195, 3, 2, 2, 2, 193, 191, 3, 2, 2, 2,
	193, 194, 3, 2, 2, 2, 194, 196, 3, 2, 2, 2, 195, 193, 3, 2, 2, 2, 196,
	198, 5, 146, 74, 2, 197, 193, 3, 2, 2, 2, 197, 198, 3, 2, 2, 2, 198, 200,
	3, 2, 2, 2, 199, 201, 5, 166, 84, 2, 200, 199, 3, 2, 2, 2, 201, 202, 3,
	2, 2, 2, 202, 200, 3, 2, 2, 2, 202, 203, 3, 2, 2, 2, 203, 206, 3, 2, 2,
	2, 204, 206, 5, 104, 53, 2, 205, 197, 3, 2, 2, 2, 205, 204, 3, 2, 2, 2,
	206, 5, 3, 2, 2, 2, 207, 213, 9, 2, 2, 2, 208, 213, 9, 3, 2, 2, 209, 213,
	9, 4, 2, 2, 210, 213, 5, 96, 49, 2, 211, 213, 7, 131, 2, 2, 212, 207, 3,
	2, 2, 2, 212, 208, 3, 2, 2, 2, 212, 209, 3, 2, 2, 2, 212, 210, 3, 2, 2,
	2, 212, 211, 3, 2, 2, 2, 213, 7, 3, 2, 2, 2, 214, 219, 5, 168, 85, 2, 215,
	219, 5, 6, 4, 2, 216, 219, 5, 2, 2, 2, 217, 219, 5, 10, 6, 2, 218, 214,
	3, 2, 2, 2, 218, 215, 3, 2, 2, 2, 218, 216, 3, 2, 2, 2, 218, 217, 3, 2,
	2, 2, 219, 9, 3, 2, 2, 2, 220, 227, 7, 14, 2, 2, 221, 223, 5, 4, 3, 2,
	222, 221, 3, 2, 2, 2, 222, 223, 3, 2, 2, 2, 223, 224, 3, 2, 2, 2, 224,
	226, 5, 8, 5, 2, 225, 222, 3, 2, 2, 2, 226, 229, 3, 2, 2, 2, 227, 225,
	3, 2, 2, 2, 227, 228, 3, 2, 2, 2, 228, 231, 3, 2, 2, 2, 229, 227, 3, 2,
	2, 2, 230, 232, 5, 4, 3, 2, 231, 230, 3, 2, 2, 2, 231, 232, 3, 2, 2, 2,
	232, 233, 3, 2, 2, 2, 233, 234, 7, 15, 2, 2, 234, 11, 3, 2, 2, 2, 235,
	237, 5, 4, 3, 2, 236, 235, 3, 2, 2, 2, 236, 237, 3, 2, 2, 2, 237, 238,
	3, 2, 2, 2, 238, 240, 5, 10, 6, 2, 239, 236, 3, 2, 2, 2, 240, 241, 3, 2,
	2, 2, 241, 239, 3, 2, 2, 2, 241, 242, 3, 2, 2, 2, 242, 244, 3, 2, 2, 2,
	243, 245, 5, 4, 3, 2, 244, 243, 3, 2, 2, 2, 244, 245, 3, 2, 2, 2, 245,
	248, 3, 2, 2, 2, 246, 248, 5, 4, 3, 2, 247, 239, 3, 2, 2, 2, 247, 246,
	3, 2, 2, 2, 248, 13, 3, 2, 2, 2, 249, 272, 5, 138, 70, 2, 250, 272, 5,
	150, 76, 2, 251, 272, 7, 7, 2, 2, 252, 272, 7, 9, 2, 2, 253, 272, 7, 10,
	2, 2, 254, 272, 7, 11, 2, 2, 255, 272, 7, 12, 2, 2, 256, 272, 7, 13, 2,
	2, 257, 272, 7, 16, 2, 2, 258, 272, 7, 17, 2, 2, 259, 272, 7, 19, 2, 2,
	260, 272, 7, 21, 2, 2, 261, 272, 7, 35, 2, 2, 262, 272, 7, 37, 2, 2, 263,
	272, 7, 68, 2, 2, 264, 272, 7, 69, 2, 2, 265, 272, 7, 70, 2, 2, 266, 272,
	7, 97, 2, 2, 267, 272, 7, 98, 2, 2, 268, 272, 7, 99, 2, 2, 269, 272, 7,
	100, 2, 2, 270, 272, 7, 131, 2, 2, 271, 249, 3, 2, 2, 2, 271, 250, 3, 2,
	2, 2, 271, 251, 3, 2, 2, 2, 271, 252, 3, 2, 2, 2, 271, 253, 3, 2, 2, 2,
	271, 254, 3, 2, 2, 2, 271, 255, 3, 2, 2, 2, 271, 256, 3, 2, 2, 2, 271,
	257, 3, 2, 2, 2, 271, 258, 3, 2, 2, 2, 271, 259, 3, 2, 2, 2, 271, 260,
	3, 2, 2, 2, 271, 261, 3, 2, 2, 2, 271, 262, 3, 2, 2, 2, 271, 263, 3, 2,
	2, 2, 271, 264, 3, 2, 2, 2, 271, 265, 3, 2, 2, 2, 271, 266, 3, 2, 2, 2,
	271, 267, 3, 2, 2, 2, 271, 268, 3, 2, 2, 2, 271, 269, 3, 2, 2, 2, 271,
	270, 3, 2, 2, 2, 272, 15, 3, 2, 2, 2, 273, 275, 5, 12, 7, 2, 274, 273,
	3, 2, 2, 2, 274, 275, 3, 2, 2, 2, 275, 277, 3, 2, 2, 2, 276, 278, 5, 14,
	8, 2, 277, 276, 3, 2, 2, 2, 278, 279, 3, 2, 2, 2, 279, 277, 3, 2, 2, 2,
	279, 280, 3, 2, 2, 2, 280, 282, 3, 2, 2, 2, 281, 283, 5, 12, 7, 2, 282,
	281, 3, 2, 2, 2, 282, 283, 3, 2, 2, 2, 283, 17, 3, 2, 2, 2, 284, 286, 5,
	14, 8, 2, 285, 284, 3, 2, 2, 2, 286, 287, 3, 2, 2, 2, 287, 285, 3, 2, 2,
	2, 287, 288, 3, 2, 2, 2, 288, 297, 3, 2, 2, 2, 289, 291, 7, 20, 2, 2, 290,
	292, 5, 14, 8, 2, 291, 290, 3, 2, 2, 2, 292, 293, 3, 2, 2, 2, 293, 291,
	3, 2, 2, 2, 293, 294, 3, 2, 2, 2, 294, 296, 3, 2, 2, 2, 295, 289, 3, 2,
	2, 2, 296, 299, 3, 2, 2, 2, 297, 295, 3, 2, 2, 2, 297, 298, 3, 2, 2, 2,
	298, 19, 3, 2, 2, 2, 299, 297, 3, 2, 2, 2, 300, 302, 5, 12, 7, 2, 301,
	300, 3, 2, 2, 2, 301, 302, 3, 2, 2, 2, 302, 303, 3, 2, 2, 2, 303, 305,
	5, 18, 10, 2, 304, 306, 7, 20, 2, 2, 305, 304, 3, 2, 2, 2, 305, 306, 3,
	2, 2, 2, 306, 308, 3, 2, 2, 2, 307, 309, 5, 12, 7, 2, 308, 307, 3, 2, 2,
	2, 308, 309, 3, 2, 2, 2, 309, 21, 3, 2, 2, 2, 310, 316, 7, 7, 2, 2, 311,
	316, 9, 5, 2, 2, 312, 316, 9, 4, 2, 2, 313, 316, 5, 98, 50, 2, 314, 316,
	7, 131, 2, 2, 315, 310, 3, 2, 2, 2, 315, 311, 3, 2, 2, 2, 315, 312, 3,
	2, 2, 2, 315, 313, 3, 2, 2, 2, 315, 314, 3, 2, 2, 2, 316, 23, 3, 2, 2,
	2, 317, 320, 5, 22, 12, 2, 318, 320, 5, 2, 2, 2, 319, 317, 3, 2, 2, 2,
	319, 318, 3, 2, 2, 2, 320, 25, 3, 2, 2, 2, 321, 323, 5, 4, 3, 2, 322, 321,
	3, 2, 2, 2, 322, 323, 3, 2, 2, 2, 323, 324, 3, 2, 2, 2, 324, 326, 5, 24,
	13, 2, 325, 322, 3, 2, 2, 2, 326, 329, 3, 2, 2, 2, 327, 325, 3, 2, 2, 2,
	327, 328, 3, 2, 2, 2, 328, 331, 3, 2, 2, 2, 329, 327, 3, 2, 2, 2, 330,
	332, 5, 4, 3, 2, 331, 330, 3, 2, 2, 2, 331, 332, 3, 2, 2, 2, 332, 27, 3,
	2, 2, 2, 333, 335, 5, 12, 7, 2, 334, 333, 3, 2, 2, 2, 334, 335, 3, 2, 2,
	2, 335, 336, 3, 2, 2, 2, 336, 337, 5, 152, 77, 2, 337, 338, 5, 26, 14,
	2, 338, 340, 5, 152, 77, 2, 339, 341, 5, 12, 7, 2, 340, 339, 3, 2, 2, 2,
	340, 341, 3, 2, 2, 2, 341, 29, 3, 2, 2, 2, 342, 347, 5, 168, 85, 2, 343,
	347, 5, 16, 9, 2, 344, 347, 5, 28, 15, 2, 345, 347, 7, 38, 2, 2, 346, 342,
	3, 2, 2, 2, 346, 343, 3, 2, 2, 2, 346, 344, 3, 2, 2, 2, 346, 345, 3, 2,
	2, 2, 347, 31, 3, 2, 2, 2, 348, 350, 5, 30, 16, 2, 349, 348, 3, 2, 2, 2,
	350, 351, 3, 2, 2, 2, 351, 349, 3, 2, 2, 2, 351, 352, 3, 2, 2, 2, 352,
	355, 3, 2, 2, 2, 353, 355, 5, 102, 52, 2, 354, 349, 3, 2, 2, 2, 354, 353,
	3, 2, 2, 2, 355, 33, 3, 2, 2, 2, 356, 357, 5, 36, 19, 2, 357, 358, 7, 18,
	2, 2, 358, 360, 3, 2, 2, 2, 359, 356, 3, 2, 2, 2, 359, 360, 3, 2, 2, 2,
	360, 361, 3, 2, 2, 2, 361, 362, 5, 40, 21, 2, 362, 364, 5, 48, 25, 2, 363,
	365, 5, 12, 7, 2, 364, 363, 3, 2, 2, 2, 364, 365, 3, 2, 2, 2, 365, 35,
	3, 2, 2, 2, 366, 368, 5, 4, 3, 2, 367, 366, 3, 2, 2, 2, 367, 368, 3, 2,
	2, 2, 368, 369, 3, 2, 2, 2, 369, 372, 5, 38, 20, 2, 370, 372, 5, 106, 54,
	2, 371, 367, 3, 2, 2, 2, 371, 370, 3, 2, 2, 2, 372, 37, 3, 2, 2, 2, 373,
	374, 9, 6, 2, 2, 374, 375, 9, 7, 2, 2, 375, 395, 9, 8, 2, 2, 376, 377,
	9, 9, 2, 2, 377, 378, 9, 10, 2, 2, 378, 395, 9, 11, 2, 2, 379, 380, 9,
	12, 2, 2, 380, 381, 9, 11, 2, 2, 381, 395, 9, 13, 2, 2, 382, 383, 9, 9,
	2, 2, 383, 384, 9, 14, 2, 2, 384, 395, 9, 10, 2, 2, 385, 386, 9, 15, 2,
	2, 386, 387, 9, 16, 2, 2, 387, 395, 9, 17, 2, 2, 388, 389, 9, 18, 2, 2,
	389, 390, 9, 19, 2, 2, 390, 395, 9, 9, 2, 2, 391, 392, 9, 18, 2, 2, 392,
	393, 9, 10, 2, 2, 393, 395, 9, 8, 2, 2, 394, 373, 3, 2, 2, 2, 394, 376,
	3, 2, 2, 2, 394, 379, 3, 2, 2, 2, 394, 382, 3, 2, 2, 2, 394, 385, 3, 2,
	2, 2, 394, 388, 3, 2, 2, 2, 394, 391, 3, 2, 2, 2, 395, 39, 3, 2, 2, 2,
	396, 397, 5, 42, 22, 2, 397, 398, 5, 44, 23, 2, 398, 399, 5, 46, 24, 2,
	399, 41, 3, 2, 2, 2, 400, 402, 5, 4, 3, 2, 401, 400, 3, 2, 2, 2, 401, 402,
	3, 2, 2, 2, 402, 403, 3, 2, 2, 2, 403, 405, 5, 150, 76, 2, 404, 406, 5,
	150, 76, 2, 405, 404, 3, 2, 2, 2, 405, 406, 3, 2, 2, 2, 406, 407, 3, 2,
	2, 2, 407, 408, 5, 4, 3, 2, 408, 411, 3, 2, 2, 2, 409, 411, 5, 108, 55,
	2, 410, 401, 3, 2, 2, 2, 410, 409, 3, 2, 2, 2, 411, 43, 3, 2, 2, 2, 412,
	413, 9, 20, 2, 2, 413, 414, 9, 19, 2, 2, 414, 449, 9, 8, 2, 2, 415, 416,
	9, 15, 2, 2, 416, 417, 9, 11, 2, 2, 417, 449, 9, 21, 2, 2, 418, 419, 9,
	6, 2, 2, 419, 420, 9, 19, 2, 2, 420, 449, 9, 16, 2, 2, 421, 422, 9, 19,
	2, 2, 422, 423, 9, 22, 2, 2, 423, 449, 9, 16, 2, 2, 424, 425, 9, 6, 2,
	2, 425, 426, 9, 19, 2, 2, 426, 449, 9, 23, 2, 2, 427, 428, 9, 20, 2, 2,
	428, 429, 9, 10, 2, 2, 429, 449, 9, 8, 2, 2, 430, 431, 9, 20, 2, 2, 431,
	432, 9, 10, 2, 2, 432, 449, 9, 24, 2, 2, 433, 434, 9, 19, 2, 2, 434, 435,
	9, 10, 2, 2, 435, 449, 9, 25, 2, 2, 436, 437, 9, 18, 2, 2, 437, 438, 9,
	11, 2, 2, 438, 449, 9, 22, 2, 2, 439, 440, 9, 7, 2, 2, 440, 441, 9, 26,
	2, 2, 441, 449, 9, 9, 2, 2, 442, 443, 9, 8, 2, 2, 443, 444, 9, 7, 2, 2,
	444, 449, 9, 27, 2, 2, 445, 446, 9, 13, 2, 2, 446, 447, 9, 11, 2, 2, 447,
	449, 9, 26, 2, 2, 448, 412, 3, 2, 2, 2, 448, 415, 3, 2, 2, 2, 448, 418,
	3, 2, 2, 2, 448, 421, 3, 2, 2, 2, 448, 424, 3, 2, 2, 2, 448, 427, 3, 2,
	2, 2, 448, 430, 3, 2, 2, 2, 448, 433, 3, 2, 2, 2, 448, 436, 3, 2, 2, 2,
	448, 439, 3, 2, 2, 2, 448, 442, 3, 2, 2, 2, 448, 445, 3, 2, 2, 2, 449,
	45, 3, 2, 2, 2, 450, 451, 5, 4, 3, 2, 451, 452, 5, 150, 76, 2, 452, 453,
	5, 150, 76, 2, 453, 455, 5, 150, 76, 2, 454, 456, 5, 150, 76, 2, 455, 454,
	3, 2, 2, 2, 456, 457, 3, 2, 2, 2, 457, 455, 3, 2, 2, 2, 457, 458, 3, 2,
	2, 2, 458, 459, 3, 2, 2, 2, 459, 460, 5, 4, 3, 2, 460, 463, 3, 2, 2, 2,
	461, 463, 5, 110, 56, 2, 462, 450, 3, 2, 2, 2, 462, 461, 3, 2, 2, 2, 463,
	47, 3, 2, 2, 2, 464, 466, 5, 50, 26, 2, 465, 467, 5, 62, 32, 2, 466, 465,
	3, 2, 2, 2, 466, 467, 3, 2, 2, 2, 467, 49, 3, 2, 2, 2, 468, 469, 5, 52,
	27, 2, 469, 470, 7, 32, 2, 2, 470, 473, 5, 54, 28, 2, 471, 472, 7, 32,
	2, 2, 472, 474, 5, 56, 29, 2, 473, 471, 3, 2, 2, 2, 473, 474, 3, 2, 2,
	2, 474, 51, 3, 2, 2, 2, 475, 477, 5, 150, 76, 2, 476, 478, 5, 150, 76,
	2, 477, 476, 3, 2, 2, 2, 477, 478, 3, 2, 2, 2, 478, 481, 3, 2, 2, 2, 479,
	481, 5, 112, 57, 2, 480, 475, 3, 2, 2, 2, 480, 479, 3, 2, 2, 2, 481, 53,
	3, 2, 2, 2, 482, 484, 5, 150, 76, 2, 483, 485, 5, 150, 76, 2, 484, 483,
	3, 2, 2, 2, 484, 485, 3, 2, 2, 2, 485, 488, 3, 2, 2, 2, 486, 488, 5, 114,
	58, 2, 487, 482, 3, 2, 2, 2, 487, 486, 3, 2, 2, 2, 488, 55, 3, 2, 2, 2,
	489, 491, 5, 150, 76, 2, 490, 492, 5, 150, 76, 2, 491, 490, 3, 2, 2, 2,
	491, 492, 3, 2, 2, 2, 492, 495, 3, 2, 2, 2, 493, 495, 5, 116, 59, 2, 494,
	489, 3, 2, 2, 2, 494, 493, 3, 2, 2, 2, 495, 57, 3, 2, 2, 2, 496, 497, 5,
	150, 76, 2, 497, 498, 5, 150, 76, 2, 498, 59, 3, 2, 2, 2, 499, 500, 5,
	150, 76, 2, 500, 501, 5, 150, 76, 2, 501, 61, 3, 2, 2, 2, 502, 503, 5,
	4, 3, 2, 503, 504, 9, 28, 2, 2, 504, 505, 5, 58, 30, 2, 505, 506, 5, 60,
	31, 2, 506, 509, 3, 2, 2, 2, 507, 509, 5, 118, 60, 2, 508, 502, 3, 2, 2,
	2, 508, 507, 3, 2, 2, 2, 509, 63, 3, 2, 2, 2, 510, 513, 5, 66, 34, 2, 511,
	513, 5, 72, 37, 2, 512, 510, 3, 2, 2, 2, 512, 511, 3, 2, 2, 2, 513, 65,
	3, 2, 2, 2, 514, 517, 5, 82, 42, 2, 515, 517, 5, 68, 35, 2, 516, 514, 3,
	2, 2, 2, 516, 515, 3, 2, 2, 2, 517, 67, 3, 2, 2, 2, 518, 520, 5, 74, 38,
	2, 519, 518, 3, 2, 2, 2, 519, 520, 3, 2, 2, 2, 520, 525, 3, 2, 2, 2, 521,
	526, 5, 70, 36, 2, 522, 523, 5, 12, 7, 2, 523, 524, 5, 82, 42, 2, 524,
	526, 3, 2, 2, 2, 525, 521, 3, 2, 2, 2, 525, 522, 3, 2, 2, 2, 526, 69, 3,
	2, 2, 2, 527, 529, 5, 12, 7, 2, 528, 527, 3, 2, 2, 2, 528, 529, 3, 2, 2,
	2, 529, 530, 3, 2, 2, 2, 530, 532, 7, 34, 2, 2, 531, 533, 5, 82, 42, 2,
	532, 531, 3, 2, 2, 2, 532, 533, 3, 2, 2, 2, 533, 534, 3, 2, 2, 2, 534,
	536, 7, 36, 2, 2, 535, 537, 5, 12, 7, 2, 536, 535, 3, 2, 2, 2, 536, 537,
	3, 2, 2, 2, 537, 540, 3, 2, 2, 2, 538, 540, 5, 120, 61, 2, 539, 528, 3,
	2, 2, 2, 539, 538, 3, 2, 2, 2, 540, 71, 3, 2, 2, 2, 541, 542, 5, 74, 38,
	2, 542, 544, 7, 32, 2, 2, 543, 545, 5, 80, 41, 2, 544, 543, 3, 2, 2, 2,
	544, 545, 3, 2, 2, 2, 545, 547, 3, 2, 2, 2, 546, 548, 7, 33, 2, 2, 547,
	546, 3, 2, 2, 2, 547, 548, 3, 2, 2, 2, 548, 550, 3, 2, 2, 2, 549, 551,
	5, 12, 7, 2, 550, 549, 3, 2, 2, 2, 550, 551, 3, 2, 2, 2, 551, 73, 3, 2,
	2, 2, 552, 553, 5, 32, 17, 2, 553, 75, 3, 2, 2, 2, 554, 559, 5, 66, 34,
	2, 555, 556, 7, 18, 2, 2, 556, 558, 5, 66, 34, 2, 557, 555, 3, 2, 2, 2,
	558, 561, 3, 2, 2, 2, 559, 557, 3, 2, 2, 2, 559, 560, 3, 2, 2, 2, 560,
	564, 3, 2, 2, 2, 561, 559, 3, 2, 2, 2, 562, 564, 5, 126, 64, 2, 563, 554,
	3, 2, 2, 2, 563, 562, 3, 2, 2, 2, 564, 77, 3, 2, 2, 2, 565, 570, 5, 64,
	33, 2, 566, 567, 7, 18, 2, 2, 567, 569, 5, 64, 33, 2, 568, 566, 3, 2, 2,
	2, 569, 572, 3, 2, 2, 2, 570, 568, 3, 2, 2, 2, 570, 571, 3, 2, 2, 2, 571,
	575, 3, 2, 2, 2, 572, 570, 3, 2, 2, 2, 573, 575, 5, 128, 65, 2, 574, 565,
	3, 2, 2, 2, 574, 573, 3, 2, 2, 2, 575, 79, 3, 2, 2, 2, 576, 580, 5, 76,
	39, 2, 577, 580, 5, 12, 7, 2, 578, 580, 5, 130, 66, 2, 579, 576, 3, 2,
	2, 2, 579, 577, 3, 2, 2, 2, 579, 578, 3, 2, 2, 2, 580, 81, 3, 2, 2, 2,
	581, 584, 5, 86, 44, 2, 582, 583, 7, 38, 2, 2, 583, 585, 5, 88, 45, 2,
	584, 582, 3, 2, 2, 2, 584, 585, 3, 2, 2, 2, 585, 591, 3, 2, 2, 2, 586,
	587, 7, 32, 2, 2, 587, 589, 5, 84, 43, 2, 588, 590, 5, 12, 7, 2, 589, 588,
	3, 2, 2, 2, 589, 590, 3, 2, 2, 2, 590, 592, 3, 2, 2, 2, 591, 586, 3, 2,
	2, 2, 591, 592, 3, 2, 2, 2, 592, 83, 3, 2, 2, 2, 593, 595, 5, 150, 76,
	2, 594, 593, 3, 2, 2, 2, 595, 596, 3, 2, 2, 2, 596, 594, 3, 2, 2, 2, 596,
	597, 3, 2, 2, 2, 597, 85, 3, 2, 2, 2, 598, 602, 5, 20, 11, 2, 599, 602,
	5, 28, 15, 2, 600, 602, 5, 132, 67, 2, 601, 598, 3, 2, 2, 2, 601, 599,
	3, 2, 2, 2, 601, 600, 3, 2, 2, 2, 602, 87, 3, 2, 2, 2, 603, 607, 5, 20,
	11, 2, 604, 607, 5, 90, 46, 2, 605, 607, 5, 134, 68, 2, 606, 603, 3, 2,
	2, 2, 606, 604, 3, 2, 2, 2, 606, 605, 3, 2, 2, 2, 607, 89, 3, 2, 2, 2,
	608, 610, 5, 12, 7, 2, 609, 608, 3, 2, 2, 2, 609, 610, 3, 2, 2, 2, 610,
	611, 3, 2, 2, 2, 611, 618, 7, 65, 2, 2, 612, 614, 5, 4, 3, 2, 613, 612,
	3, 2, 2, 2, 613, 614, 3, 2, 2, 2, 614, 615, 3, 2, 2, 2, 615, 617, 5, 92,
	47, 2, 616, 613, 3, 2, 2, 2, 617, 620, 3, 2, 2, 2, 618, 616, 3, 2, 2, 2,
	618, 619, 3, 2, 2, 2, 619, 622, 3, 2, 2, 2, 620, 618, 3, 2, 2, 2, 621,
	623, 5, 4, 3, 2, 622, 621, 3, 2, 2, 2, 622, 623, 3, 2, 2, 2, 623, 624,
	3, 2, 2, 2, 624, 626, 7, 67, 2, 2, 625, 627, 5, 12, 7, 2, 626, 625, 3,
	2, 2, 2, 626, 627, 3, 2, 2, 2, 627, 91, 3, 2, 2, 2, 628, 633, 9, 29, 2,
	2, 629, 633, 9, 30, 2, 2, 630, 633, 5, 136, 69, 2, 631, 633, 7, 131, 2,
	2, 632, 628, 3, 2, 2, 2, 632, 629, 3, 2, 2, 2, 632, 630, 3, 2, 2, 2, 632,
	631, 3, 2, 2, 2, 633, 93, 3, 2, 2, 2, 634, 640, 9, 31, 2, 2, 635, 640,
	7, 110, 2, 2, 636, 640, 7, 111, 2, 2, 637, 640, 9, 32, 2, 2, 638, 640,
	7, 130, 2, 2, 639, 634, 3, 2, 2, 2, 639, 635, 3, 2, 2, 2, 639, 636, 3,
	2, 2, 2, 639, 637, 3, 2, 2, 2, 639, 638, 3, 2, 2, 2, 640, 95, 3, 2, 2,
	2, 641, 642, 5, 94, 48, 2, 642, 97, 3, 2, 2, 2, 643, 644, 5, 94, 48, 2,
	644, 99, 3, 2, 2, 2, 645, 650, 7, 66, 2, 2, 646, 651, 7, 101, 2, 2, 647,
	651, 5, 94, 48, 2, 648, 651, 5, 158, 80, 2, 649, 651, 5, 144, 73, 2, 650,
	646, 3, 2, 2, 2, 650, 647, 3, 2, 2, 2, 650, 648, 3, 2, 2, 2, 650, 649,
	3, 2, 2, 2, 651, 101, 3, 2, 2, 2, 652, 658, 5, 30, 16, 2, 653, 657, 5,
	30, 16, 2, 654, 657, 7, 20, 2, 2, 655, 657, 5, 12, 7, 2, 656, 653, 3, 2,
	2, 2, 656, 654, 3, 2, 2, 2, 656, 655, 3, 2, 2, 2, 657, 660, 3, 2, 2, 2,
	658, 656, 3, 2, 2, 2, 658, 659, 3, 2, 2, 2, 659, 103, 3, 2, 2, 2, 660,
	658, 3, 2, 2, 2, 661, 663, 5, 146, 74, 2, 662, 661, 3, 2, 2, 2, 662, 663,
	3, 2, 2, 2, 663, 664, 3, 2, 2, 2, 664, 666, 5, 166, 84, 2, 665, 662, 3,
	2, 2, 2, 666, 667, 3, 2, 2, 2, 667, 665, 3, 2, 2, 2, 667, 668, 3, 2, 2,
	2, 668, 105, 3, 2, 2, 2, 669, 671, 5, 12, 7, 2, 670, 669, 3, 2, 2, 2, 670,
	671, 3, 2, 2, 2, 671, 672, 3, 2, 2, 2, 672, 674, 5, 38, 20, 2, 673, 675,
	5, 12, 7, 2, 674, 673, 3, 2, 2, 2, 674, 675, 3, 2, 2, 2, 675, 107, 3, 2,
	2, 2, 676, 678, 5, 12, 7, 2, 677, 676, 3, 2, 2, 2, 677, 678, 3, 2, 2, 2,
	678, 679, 3, 2, 2, 2, 679, 681, 5, 150, 76, 2, 680, 682, 5, 150, 76, 2,
	681, 680, 3, 2, 2, 2, 681, 682, 3, 2, 2, 2, 682, 684, 3, 2, 2, 2, 683,
	685, 5, 12, 7, 2, 684, 683, 3, 2, 2, 2, 684, 685, 3, 2, 2, 2, 685, 109,
	3, 2, 2, 2, 686, 688, 5, 12, 7, 2, 687, 686, 3, 2, 2, 2, 687, 688, 3, 2,
	2, 2, 688, 689, 3, 2, 2, 2, 689, 691, 5, 150, 76, 2, 690, 692, 5, 150,
	76, 2, 691, 690, 3, 2, 2, 2, 692, 693, 3, 2, 2, 2, 693, 691, 3, 2, 2, 2,
	693, 694, 3, 2, 2, 2, 694, 696, 3, 2, 2, 2, 695, 697, 5, 12, 7, 2, 696,
	695, 3, 2, 2, 2, 696, 697, 3, 2, 2, 2, 697, 111, 3, 2, 2, 2, 698, 700,
	5, 12, 7, 2, 699, 698, 3, 2, 2, 2, 699, 700, 3, 2, 2, 2, 700, 701, 3, 2,
	2, 2, 701, 703, 5, 150, 76, 2, 702, 704, 5, 150, 76, 2, 703, 702, 3, 2,
	2, 2, 703, 704, 3, 2, 2, 2, 704, 706, 3, 2, 2, 2, 705, 707, 5, 12, 7, 2,
	706, 705, 3, 2, 2, 2, 706, 707, 3, 2, 2, 2, 707, 113, 3, 2, 2, 2, 708,
	710, 5, 12, 7, 2, 709, 708, 3, 2, 2, 2, 709, 710, 3, 2, 2, 2, 710, 711,
	3, 2, 2, 2, 711, 713, 5, 150, 76, 2, 712, 714, 5, 150, 76, 2, 713, 712,
	3, 2, 2, 2, 713, 714, 3, 2, 2, 2, 714, 716, 3, 2, 2, 2, 715, 717, 5, 12,
	7, 2, 716, 715, 3, 2, 2, 2, 716, 717, 3, 2, 2, 2, 717, 115, 3, 2, 2, 2,
	718, 720, 5, 12, 7, 2, 719, 718, 3, 2, 2, 2, 719, 720, 3, 2, 2, 2, 720,
	721, 3, 2, 2, 2, 721, 723, 5, 150, 76, 2, 722, 724, 5, 150, 76, 2, 723,
	722, 3, 2, 2, 2, 723, 724, 3, 2, 2, 2, 724, 726, 3, 2, 2, 2, 725, 727,
	5, 12, 7, 2, 726, 725, 3, 2, 2, 2, 726, 727, 3, 2, 2, 2, 727, 117, 3, 2,
	2, 2, 728, 729, 9, 10, 2, 2, 729, 762, 9, 9, 2, 2, 730, 731, 9, 25, 2,
	2, 731, 732, 9, 6, 2, 2, 732, 762, 9, 9, 2, 2, 733, 734, 9, 11, 2, 2, 734,
	735, 9, 18, 2, 2, 735, 762, 9, 9, 2, 2, 736, 737, 9, 11, 2, 2, 737, 738,
	9, 13, 2, 2, 738, 762, 9, 9, 2, 2, 739, 740, 9, 26, 2, 2, 740, 741, 9,
	18, 2, 2, 741, 762, 9, 9, 2, 2, 742, 743, 9, 26, 2, 2, 743, 744, 9, 13,
	2, 2, 744, 762, 9, 9, 2, 2, 745, 746, 9, 6, 2, 2, 746, 747, 9, 18, 2, 2,
	747, 762, 9, 9, 2, 2, 748, 749, 9, 6, 2, 2, 749, 750, 9, 13, 2, 2, 750,
	762, 9, 9, 2, 2, 751, 752, 9, 22, 2, 2, 752, 753, 9, 18, 2, 2, 753, 762,
	9, 9, 2, 2, 754, 755, 9, 22, 2, 2, 755, 756, 9, 13, 2, 2, 756, 762, 9,
	9, 2, 2, 757, 762, 9, 33, 2, 2, 758, 762, 9, 34, 2, 2, 759, 762, 9, 35,
	2, 2, 760, 762, 9, 36, 2, 2, 761, 728, 3, 2, 2, 2, 761, 730, 3, 2, 2, 2,
	761, 733, 3, 2, 2, 2, 761, 736, 3, 2, 2, 2, 761, 739, 3, 2, 2, 2, 761,
	742, 3, 2, 2, 2, 761, 745, 3, 2, 2, 2, 761, 748, 3, 2, 2, 2, 761, 751,
	3, 2, 2, 2, 761, 754, 3, 2, 2, 2, 761, 757, 3, 2, 2, 2, 761, 758, 3, 2,
	2, 2, 761, 759, 3, 2, 2, 2, 761, 760, 3, 2, 2, 2, 762, 119, 3, 2, 2, 2,
	763, 765, 5, 12, 7, 2, 764, 763, 3, 2, 2, 2, 764, 765, 3, 2, 2, 2, 765,
	766, 3, 2, 2, 2, 766, 767, 7, 34, 2, 2, 767, 768, 5, 122, 62, 2, 768, 769,
	5, 82, 42, 2, 769, 771, 7, 36, 2, 2, 770, 772, 5, 12, 7, 2, 771, 770, 3,
	2, 2, 2, 771, 772, 3, 2, 2, 2, 772, 121, 3, 2, 2, 2, 773, 774, 5, 124,
	63, 2, 774, 775, 7, 32, 2, 2, 775, 123, 3, 2, 2, 2, 776, 779, 5, 12, 7,
	2, 777, 779, 7, 18, 2, 2, 778, 776, 3, 2, 2, 2, 778, 777, 3, 2, 2, 2, 779,
	782, 3, 2, 2, 2, 780, 778, 3, 2, 2, 2, 780, 781, 3, 2, 2, 2, 781, 783,
	3, 2, 2, 2, 782, 780, 3, 2, 2, 2, 783, 784, 7, 38, 2, 2, 784, 795, 5, 88,
	45, 2, 785, 787, 7, 18, 2, 2, 786, 788, 5, 12, 7, 2, 787, 786, 3, 2, 2,
	2, 787, 788, 3, 2, 2, 2, 788, 791, 3, 2, 2, 2, 789, 790, 7, 38, 2, 2, 790,
	792, 5, 88, 45, 2, 791, 789, 3, 2, 2, 2, 791, 792, 3, 2, 2, 2, 792, 794,
	3, 2, 2, 2, 793, 785, 3, 2, 2, 2, 794, 797, 3, 2, 2, 2, 795, 793, 3, 2,
	2, 2, 795, 796, 3, 2, 2, 2, 796, 125, 3, 2, 2, 2, 797, 795, 3, 2, 2, 2,
	798, 800, 5, 12, 7, 2, 799, 798, 3, 2, 2, 2, 799, 800, 3, 2, 2, 2, 800,
	801, 3, 2, 2, 2, 801, 803, 7, 18, 2, 2, 802, 799, 3, 2, 2, 2, 803, 806,
	3, 2, 2, 2, 804, 802, 3, 2, 2, 2, 804, 805, 3, 2, 2, 2, 805, 807, 3, 2,
	2, 2, 806, 804, 3, 2, 2, 2, 807, 815, 5, 66, 34, 2, 808, 811, 7, 18, 2,
	2, 809, 812, 5, 66, 34, 2, 810, 812, 5, 12, 7, 2, 811, 809, 3, 2, 2, 2,
	811, 810, 3, 2, 2, 2, 811, 812, 3, 2, 2, 2, 812, 814, 3, 2, 2, 2, 813,
	808, 3, 2, 2, 2, 814, 817, 3, 2, 2, 2, 815, 813, 3, 2, 2, 2, 815, 816,
	3, 2, 2, 2, 816, 127, 3, 2, 2, 2, 817, 815, 3, 2, 2, 2, 818, 820, 5, 12,
	7, 2, 819, 818, 3, 2, 2, 2, 819, 820, 3, 2, 2, 2, 820, 821, 3, 2, 2, 2,
	821, 823, 7, 18, 2, 2, 822, 819, 3, 2, 2, 2, 823, 826, 3, 2, 2, 2, 824,
	822, 3, 2, 2, 2, 824, 825, 3, 2, 2, 2, 825, 827, 3, 2, 2, 2, 826, 824,
	3, 2, 2, 2, 827, 835, 5, 64, 33, 2, 828, 831, 7, 18, 2, 2, 829, 832, 5,
	64, 33, 2, 830, 832, 5, 12, 7, 2, 831, 829, 3, 2, 2, 2, 831, 830, 3, 2,
	2, 2, 831, 832, 3, 2, 2, 2, 832, 834, 3, 2, 2, 2, 833, 828, 3, 2, 2, 2,
	834, 837, 3, 2, 2, 2, 835, 833, 3, 2, 2, 2, 835, 836, 3, 2, 2, 2, 836,
	129, 3, 2, 2, 2, 837, 835, 3, 2, 2, 2, 838, 840, 5, 12, 7, 2, 839, 838,
	3, 2, 2, 2, 839, 840, 3, 2, 2, 2, 840, 841, 3, 2, 2, 2, 841, 843, 7, 18,
	2, 2, 842, 839, 3, 2, 2, 2, 843, 844, 3, 2, 2, 2, 844, 842, 3, 2, 2, 2,
	844, 845, 3, 2, 2, 2, 845, 847, 3, 2, 2, 2, 846, 848, 5, 12, 7, 2, 847,
	846, 3, 2, 2, 2, 847, 848, 3, 2, 2, 2, 848, 131, 3, 2, 2, 2, 849, 854,
	5, 30, 16, 2, 850, 851, 7, 20, 2, 2, 851, 853, 5, 30, 16, 2, 852, 850,
	3, 2, 2, 2, 853, 856, 3, 2, 2, 2, 854, 852, 3, 2, 2, 2, 854, 855, 3, 2,
	2, 2, 855, 133, 3, 2, 2, 2, 856, 854, 3, 2, 2, 2, 857, 862, 5, 16, 9, 2,
	858, 859, 7, 20, 2, 2, 859, 861, 5, 16, 9, 2, 860, 858, 3, 2, 2, 2, 861,
	864, 3, 2, 2, 2, 862, 860, 3, 2, 2, 2, 862, 863, 3, 2, 2, 2, 863, 135,
	3, 2, 2, 2, 864, 862, 3, 2, 2, 2, 865, 868, 5, 94, 48, 2, 866, 868, 5,
	2, 2, 2, 867, 865, 3, 2, 2, 2, 867, 866, 3, 2, 2, 2, 868, 137, 3, 2, 2,
	2, 869, 872, 9, 37, 2, 2, 870, 872, 9, 38, 2, 2, 871, 869, 3, 2, 2, 2,
	871, 870, 3, 2, 2, 2, 872, 139, 3, 2, 2, 2, 873, 874, 9, 39, 2, 2, 874,
	141, 3, 2, 2, 2, 875, 876, 9, 40, 2, 2, 876, 143, 3, 2, 2, 2, 877, 878,
	7, 5, 2, 2, 878, 145, 3, 2, 2, 2, 879, 880, 5, 144, 73, 2, 880, 881, 5,
	158, 80, 2, 881, 147, 3, 2, 2, 2, 882, 885, 9, 41, 2, 2, 883, 885, 7, 130,
	2, 2, 884, 882, 3, 2, 2, 2, 884, 883, 3, 2, 2, 2, 885, 149, 3, 2, 2, 2,
	886, 887, 9, 42, 2, 2, 887, 151, 3, 2, 2, 2, 888, 889, 7, 8, 2, 2, 889,
	153, 3, 2, 2, 2, 890, 898, 5, 150, 76, 2, 891, 898, 9, 19, 2, 2, 892, 898,
	9, 21, 2, 2, 893, 898, 9, 26, 2, 2, 894, 898, 9, 13, 2, 2, 895, 898, 9,
	11, 2, 2, 896, 898, 9, 15, 2, 2, 897, 890, 3, 2, 2, 2, 897, 891, 3, 2,
	2, 2, 897, 892, 3, 2, 2, 2, 897, 893, 3, 2, 2, 2, 897, 894, 3, 2, 2, 2,
	897, 895, 3, 2, 2, 2, 897, 896, 3, 2, 2, 2, 898, 155, 3, 2, 2, 2, 899,
	900, 7, 3, 2, 2, 900, 157, 3, 2, 2, 2, 901, 902, 7, 4, 2, 2, 902, 159,
	3, 2, 2, 2, 903, 908, 5, 166, 84, 2, 904, 905, 5, 146, 74, 2, 905, 906,
	5, 166, 84, 2, 906, 908, 3, 2, 2, 2, 907, 903, 3, 2, 2, 2, 907, 904, 3,
	2, 2, 2, 908, 911, 3, 2, 2, 2, 909, 907, 3, 2, 2, 2, 909, 910, 3, 2, 2,
	2, 910, 161, 3, 2, 2, 2, 911, 909, 3, 2, 2, 2, 912, 913, 7, 6, 2, 2, 913,
	163, 3, 2, 2, 2, 914, 917, 9, 43, 2, 2, 915, 917, 7, 131, 2, 2, 916, 914,
	3, 2, 2, 2, 916, 915, 3, 2, 2, 2, 917, 165, 3, 2, 2, 2, 918, 921, 5, 162,
	82, 2, 919, 921, 5, 156, 79, 2, 920, 918, 3, 2, 2, 2, 920, 919, 3, 2, 2,
	2, 921, 167, 3, 2, 2, 2, 922, 924, 5, 12, 7, 2, 923, 922, 3, 2, 2, 2, 923,
	924, 3, 2, 2, 2, 924, 925, 3, 2, 2, 2, 925, 926, 7, 35, 2, 2, 926, 927,
	7, 37, 2, 2, 927, 928, 3, 2, 2, 2, 928, 929, 5, 174, 88, 2, 929, 930, 7,
	37, 2, 2, 930, 931, 5, 176, 89, 2, 931, 932, 7, 37, 2, 2, 932, 933, 5,
	180, 91, 2, 933, 934, 7, 37, 2, 2, 934, 935, 7, 35, 2, 2, 935, 937, 3,
	2, 2, 2, 936, 938, 5, 12, 7, 2, 937, 936, 3, 2, 2, 2, 937, 938, 3, 2, 2,
	2, 938, 169, 3, 2, 2, 2, 939, 947, 9, 2, 2, 2, 940, 947, 9, 44, 2, 2, 941,
	947, 7, 19, 2, 2, 942, 947, 9, 42, 2, 2, 943, 947, 9, 37, 2, 2, 944, 947,
	7, 66, 2, 2, 945, 947, 9, 30, 2, 2, 946, 939, 3, 2, 2, 2, 946, 940, 3,
	2, 2, 2, 946, 941, 3, 2, 2, 2, 946, 942, 3, 2, 2, 2, 946, 943, 3, 2, 2,
	2, 946, 944, 3, 2, 2, 2, 946, 945, 3, 2, 2, 2, 947, 171, 3, 2, 2, 2, 948,
	951, 9, 45, 2, 2, 949, 951, 9, 46, 2, 2, 950, 948, 3, 2, 2, 2, 950, 949,
	3, 2, 2, 2, 951, 173, 3, 2, 2, 2, 952, 953, 5, 178, 90, 2, 953, 175, 3,
	2, 2, 2, 954, 955, 5, 178, 90, 2, 955, 177, 3, 2, 2, 2, 956, 958, 5, 170,
	86, 2, 957, 956, 3, 2, 2, 2, 958, 959, 3, 2, 2, 2, 959, 957, 3, 2, 2, 2,
	959, 960, 3, 2, 2, 2, 960, 179, 3, 2, 2, 2, 961, 963, 5, 172, 87, 2, 962,
	961, 3, 2, 2, 2, 963, 964, 3, 2, 2, 2, 964, 962, 3, 2, 2, 2, 964, 965,
	3, 2, 2, 2, 965, 181, 3, 2, 2, 2, 143, 185, 188, 193, 197, 202, 205, 212,
	218, 222, 227, 231, 236, 241, 244, 247, 271, 274, 279, 282, 287, 293, 297,
	301, 305, 308, 315, 319, 322, 327, 331, 334, 340, 346, 351, 354, 359, 364,
	367, 371, 394, 401, 405, 410, 448, 457, 462, 466, 473, 477, 480, 484, 487,
	491, 494, 508, 512, 516, 519, 525, 528, 532, 536, 539, 544, 547, 550, 559,
	563, 570, 574, 579, 584, 589, 591, 596, 601, 606, 609, 613, 618, 622, 626,
	632, 639, 650, 656, 658, 662, 667, 670, 674, 677, 681, 684, 687, 693, 696,
	699, 703, 706, 709, 713, 716, 719, 723, 726, 761, 764, 771, 778, 780, 787,
	791, 795, 799, 804, 811, 815, 819, 824, 831, 835, 839, 844, 847, 854, 862,
	867, 871, 884, 897, 907, 909, 916, 920, 923, 937, 946, 950, 959, 964,
}
var deserializer = antlr.NewATNDeserializer(nil)
var deserializedATN = deserializer.DeserializeFromUInt16(parserATN)

var literalNames = []string{
	"", "'\u0009'", "'\u000A'", "'\u000D'", "' '", "'!'", "'\"'", "'#'", "'$'",
	"'%'", "'&'", "'''", "'('", "')'", "'*'", "'+'", "','", "'-'", "'.'", "'/'",
	"'0'", "'1'", "'2'", "'3'", "'4'", "'5'", "'6'", "'7'", "'8'", "'9'", "':'",
	"';'", "'<'", "'='", "'>'", "'?'", "'@'", "'A'", "'B'", "'C'", "'D'", "'E'",
	"'F'", "'G'", "'H'", "'I'", "'J'", "'K'", "'L'", "'M'", "'N'", "'O'", "'P'",
	"'Q'", "'R'", "'S'", "'T'", "'U'", "'V'", "'W'", "'X'", "'Y'", "'Z'", "'['",
	"'\\'", "']'", "'^'", "'_'", "'`'", "'a'", "'b'", "'c'", "'d'", "'e'",
	"'f'", "'g'", "'h'", "'i'", "'j'", "'k'", "'l'", "'m'", "'n'", "'o'", "'p'",
	"'q'", "'r'", "'s'", "'t'", "'u'", "'v'", "'w'", "'x'", "'y'", "'z'", "'{'",
	"'|'", "'}'", "'~'", "'\u0000'", "'\u0001'", "'\u0002'", "'\u0003'", "'\u0004'",
	"'\u0005'", "'\u0006'", "'\u0007'", "'\u0008'", "'\u000B'", "'\u000C'",
	"'\u000E'", "'\u000F'", "'\u0010'", "'\u0011'", "'\u0012'", "'\u0013'",
	"'\u0014'", "'\u0015'", "'\u0016'", "'\u0017'", "'\u0018'", "'\u0019'",
	"'\u001A'", "'\u001B'", "'\u001C'", "'\u001D'", "'\u001E'", "'\u001F'",
	"'\u007F'",
}
var symbolicNames = []string{
	"", "TAB", "LF", "CR", "SPACE", "EXCLAMATION", "QUOTE", "HASH", "DOLLAR",
	"PERCENT", "AMPERSAND", "APOSTROPHE", "LEFT_PAREN", "RIGHT_PAREN", "ASTERISK",
	"PLUS", "COMMA", "DASH", "PERIOD", "SLASH", "ZERO", "ONE", "TWO", "THREE",
	"FOUR", "FIVE", "SIX", "SEVEN", "EIGHT", "NINE", "COLON", "SEMICOLON",
	"LESS_THAN", "EQUALS", "GREATER_THAN", "QUESTION", "AT", "CAP_A", "CAP_B",
	"CAP_C", "CAP_D", "CAP_E", "CAP_F", "CAP_G", "CAP_H", "CAP_I", "CAP_J",
	"CAP_K", "CAP_L", "CAP_M", "CAP_N", "CAP_O", "CAP_P", "CAP_Q", "CAP_R",
	"CAP_S", "CAP_T", "CAP_U", "CAP_V", "CAP_W", "CAP_X", "CAP_Y", "CAP_Z",
	"LEFT_BRACE", "BACKSLASH", "RIGHT_BRACE", "CARAT", "UNDERSCORE", "ACCENT",
	"A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O",
	"P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "LEFT_CURLY_BRACE",
	"PIPE", "RIGHT_CURLY_BRACE", "TILDE", "U_0000", "U_0001", "U_0002", "U_0003",
	"U_0004", "U_0005", "U_0006", "U_0007", "U_0008", "U_000B", "U_000C", "U_000E",
	"U_000F", "U_0010", "U_0011", "U_0012", "U_0013", "U_0014", "U_0015", "U_0016",
	"U_0017", "U_0018", "U_0019", "U_001A", "U_001B", "U_001C", "U_001D", "U_001E",
	"U_001F", "U_007F", "U_REST",
}

var ruleNames = []string{
	"quoted_pair", "fws", "ctext", "ccontent", "comment", "cfws", "atext",
	"atom", "dot_atom_text", "dot_atom", "qtext", "qcontent", "quoted_content",
	"quoted_string", "word", "phrase", "date_time", "day_of_week", "day_name",
	"date", "day", "month", "year", "time", "time_of_day", "hour", "minute",
	"second", "zone_hour", "zone_minute", "zone", "address", "mailbox", "name_addr",
	"angle_addr", "group", "display_name", "mailbox_list", "address_list",
	"group_list", "addr_spec", "port", "local_part", "domain", "domain_literal",
	"dtext", "obs_no_ws_ctl", "obs_ctext", "obs_qtext", "obs_qp", "obs_phrase",
	"obs_fws", "obs_day_of_week", "obs_day", "obs_year", "obs_hour", "obs_minute",
	"obs_second", "obs_zone", "obs_angle_addr", "obs_route", "obs_domain_list",
	"obs_mbox_list", "obs_addr_list", "obs_group_list", "obs_local_part", "obs_domain",
	"obs_dtext", "alpha", "bit", "char_1", "cr", "crlf", "ctl", "digit", "dquote",
	"hexdig", "htab", "lf", "lwsp", "sp", "vchar", "wsp", "encoded_word", "anytext_token",
	"anytext_et", "charset", "encoding", "token", "encoded_text",
}
var decisionToDFA = make([]*antlr.DFA, len(deserializedATN.DecisionToState))

func init() {
	for index, ds := range deserializedATN.DecisionToState {
		decisionToDFA[index] = antlr.NewDFA(ds, index)
	}
}

type RFCParser struct {
	*antlr.BaseParser
}

func NewRFCParser(input antlr.TokenStream) *RFCParser {
	this := new(RFCParser)

	this.BaseParser = antlr.NewBaseParser(input)

	this.Interpreter = antlr.NewParserATNSimulator(this, deserializedATN, decisionToDFA, antlr.NewPredictionContextCache())
	this.RuleNames = ruleNames
	this.LiteralNames = literalNames
	this.SymbolicNames = symbolicNames
	this.GrammarFileName = "RFC.g4"

	return this
}

// RFCParser tokens.
const (
	RFCParserEOF               = antlr.TokenEOF
	RFCParserTAB               = 1
	RFCParserLF                = 2
	RFCParserCR                = 3
	RFCParserSPACE             = 4
	RFCParserEXCLAMATION       = 5
	RFCParserQUOTE             = 6
	RFCParserHASH              = 7
	RFCParserDOLLAR            = 8
	RFCParserPERCENT           = 9
	RFCParserAMPERSAND         = 10
	RFCParserAPOSTROPHE        = 11
	RFCParserLEFT_PAREN        = 12
	RFCParserRIGHT_PAREN       = 13
	RFCParserASTERISK          = 14
	RFCParserPLUS              = 15
	RFCParserCOMMA             = 16
	RFCParserDASH              = 17
	RFCParserPERIOD            = 18
	RFCParserSLASH             = 19
	RFCParserZERO              = 20
	RFCParserONE               = 21
	RFCParserTWO               = 22
	RFCParserTHREE             = 23
	RFCParserFOUR              = 24
	RFCParserFIVE              = 25
	RFCParserSIX               = 26
	RFCParserSEVEN             = 27
	RFCParserEIGHT             = 28
	RFCParserNINE              = 29
	RFCParserCOLON             = 30
	RFCParserSEMICOLON         = 31
	RFCParserLESS_THAN         = 32
	RFCParserEQUALS            = 33
	RFCParserGREATER_THAN      = 34
	RFCParserQUESTION          = 35
	RFCParserAT                = 36
	RFCParserCAP_A             = 37
	RFCParserCAP_B             = 38
	RFCParserCAP_C             = 39
	RFCParserCAP_D             = 40
	RFCParserCAP_E             = 41
	RFCParserCAP_F             = 42
	RFCParserCAP_G             = 43
	RFCParserCAP_H             = 44
	RFCParserCAP_I             = 45
	RFCParserCAP_J             = 46
	RFCParserCAP_K             = 47
	RFCParserCAP_L             = 48
	RFCParserCAP_M             = 49
	RFCParserCAP_N             = 50
	RFCParserCAP_O             = 51
	RFCParserCAP_P             = 52
	RFCParserCAP_Q             = 53
	RFCParserCAP_R             = 54
	RFCParserCAP_S             = 55
	RFCParserCAP_T             = 56
	RFCParserCAP_U             = 57
	RFCParserCAP_V             = 58
	RFCParserCAP_W             = 59
	RFCParserCAP_X             = 60
	RFCParserCAP_Y             = 61
	RFCParserCAP_Z             = 62
	RFCParserLEFT_BRACE        = 63
	RFCParserBACKSLASH         = 64
	RFCParserRIGHT_BRACE       = 65
	RFCParserCARAT             = 66
	RFCParserUNDERSCORE        = 67
	RFCParserACCENT            = 68
	RFCParserA                 = 69
	RFCParserB                 = 70
	RFCParserC                 = 71
	RFCParserD                 = 72
	RFCParserE                 = 73
	RFCParserF                 = 74
	RFCParserG                 = 75
	RFCParserH                 = 76
	RFCParserI                 = 77
	RFCParserJ                 = 78
	RFCParserK                 = 79
	RFCParserL                 = 80
	RFCParserM                 = 81
	RFCParserN                 = 82
	RFCParserO                 = 83
	RFCParserP                 = 84
	RFCParserQ                 = 85
	RFCParserR                 = 86
	RFCParserS                 = 87
	RFCParserT                 = 88
	RFCParserU                 = 89
	RFCParserV                 = 90
	RFCParserW                 = 91
	RFCParserX                 = 92
	RFCParserY                 = 93
	RFCParserZ                 = 94
	RFCParserLEFT_CURLY_BRACE  = 95
	RFCParserPIPE              = 96
	RFCParserRIGHT_CURLY_BRACE = 97
	RFCParserTILDE             = 98
	RFCParserU_0000            = 99
	RFCParserU_0001            = 100
	RFCParserU_0002            = 101
	RFCParserU_0003            = 102
	RFCParserU_0004            = 103
	RFCParserU_0005            = 104
	RFCParserU_0006            = 105
	RFCParserU_0007            = 106
	RFCParserU_0008            = 107
	RFCParserU_000B            = 108
	RFCParserU_000C            = 109
	RFCParserU_000E            = 110
	RFCParserU_000F            = 111
	RFCParserU_0010            = 112
	RFCParserU_0011            = 113
	RFCParserU_0012            = 114
	RFCParserU_0013            = 115
	RFCParserU_0014            = 116
	RFCParserU_0015            = 117
	RFCParserU_0016            = 118
	RFCParserU_0017            = 119
	RFCParserU_0018            = 120
	RFCParserU_0019            = 121
	RFCParserU_001A            = 122
	RFCParserU_001B            = 123
	RFCParserU_001C            = 124
	RFCParserU_001D            = 125
	RFCParserU_001E            = 126
	RFCParserU_001F            = 127
	RFCParserU_007F            = 128
	RFCParserU_REST            = 129
)

// RFCParser rules.
const (
	RFCParserRULE_quoted_pair     = 0
	RFCParserRULE_fws             = 1
	RFCParserRULE_ctext           = 2
	RFCParserRULE_ccontent        = 3
	RFCParserRULE_comment         = 4
	RFCParserRULE_cfws            = 5
	RFCParserRULE_atext           = 6
	RFCParserRULE_atom            = 7
	RFCParserRULE_dot_atom_text   = 8
	RFCParserRULE_dot_atom        = 9
	RFCParserRULE_qtext           = 10
	RFCParserRULE_qcontent        = 11
	RFCParserRULE_quoted_content  = 12
	RFCParserRULE_quoted_string   = 13
	RFCParserRULE_word            = 14
	RFCParserRULE_phrase          = 15
	RFCParserRULE_date_time       = 16
	RFCParserRULE_day_of_week     = 17
	RFCParserRULE_day_name        = 18
	RFCParserRULE_date            = 19
	RFCParserRULE_day             = 20
	RFCParserRULE_month           = 21
	RFCParserRULE_year            = 22
	RFCParserRULE_time            = 23
	RFCParserRULE_time_of_day     = 24
	RFCParserRULE_hour            = 25
	RFCParserRULE_minute          = 26
	RFCParserRULE_second          = 27
	RFCParserRULE_zone_hour       = 28
	RFCParserRULE_zone_minute     = 29
	RFCParserRULE_zone            = 30
	RFCParserRULE_address         = 31
	RFCParserRULE_mailbox         = 32
	RFCParserRULE_name_addr       = 33
	RFCParserRULE_angle_addr      = 34
	RFCParserRULE_group           = 35
	RFCParserRULE_display_name    = 36
	RFCParserRULE_mailbox_list    = 37
	RFCParserRULE_address_list    = 38
	RFCParserRULE_group_list      = 39
	RFCParserRULE_addr_spec       = 40
	RFCParserRULE_port            = 41
	RFCParserRULE_local_part      = 42
	RFCParserRULE_domain          = 43
	RFCParserRULE_domain_literal  = 44
	RFCParserRULE_dtext           = 45
	RFCParserRULE_obs_no_ws_ctl   = 46
	RFCParserRULE_obs_ctext       = 47
	RFCParserRULE_obs_qtext       = 48
	RFCParserRULE_obs_qp          = 49
	RFCParserRULE_obs_phrase      = 50
	RFCParserRULE_obs_fws         = 51
	RFCParserRULE_obs_day_of_week = 52
	RFCParserRULE_obs_day         = 53
	RFCParserRULE_obs_year        = 54
	RFCParserRULE_obs_hour        = 55
	RFCParserRULE_obs_minute      = 56
	RFCParserRULE_obs_second      = 57
	RFCParserRULE_obs_zone        = 58
	RFCParserRULE_obs_angle_addr  = 59
	RFCParserRULE_obs_route       = 60
	RFCParserRULE_obs_domain_list = 61
	RFCParserRULE_obs_mbox_list   = 62
	RFCParserRULE_obs_addr_list   = 63
	RFCParserRULE_obs_group_list  = 64
	RFCParserRULE_obs_local_part  = 65
	RFCParserRULE_obs_domain      = 66
	RFCParserRULE_obs_dtext       = 67
	RFCParserRULE_alpha           = 68
	RFCParserRULE_bit             = 69
	RFCParserRULE_char_1          = 70
	RFCParserRULE_cr              = 71
	RFCParserRULE_crlf            = 72
	RFCParserRULE_ctl             = 73
	RFCParserRULE_digit           = 74
	RFCParserRULE_dquote          = 75
	RFCParserRULE_hexdig          = 76
	RFCParserRULE_htab            = 77
	RFCParserRULE_lf              = 78
	RFCParserRULE_lwsp            = 79
	RFCParserRULE_sp              = 80
	RFCParserRULE_vchar           = 81
	RFCParserRULE_wsp             = 82
	RFCParserRULE_encoded_word    = 83
	RFCParserRULE_anytext_token   = 84
	RFCParserRULE_anytext_et      = 85
	RFCParserRULE_charset         = 86
	RFCParserRULE_encoding        = 87
	RFCParserRULE_token           = 88
	RFCParserRULE_encoded_text    = 89
)

// IQuoted_pairContext is an interface to support dynamic dispatch.
type IQuoted_pairContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuoted_pairContext differentiates from other interfaces.
	IsQuoted_pairContext()
}

type Quoted_pairContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_pairContext() *Quoted_pairContext {
	var p = new(Quoted_pairContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_quoted_pair
	return p
}

func (*Quoted_pairContext) IsQuoted_pairContext() {}

func NewQuoted_pairContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_pairContext {
	var p = new(Quoted_pairContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_quoted_pair

	return p
}

func (s *Quoted_pairContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_pairContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserBACKSLASH, 0)
}

func (s *Quoted_pairContext) Vchar() IVcharContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IVcharContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IVcharContext)
}

func (s *Quoted_pairContext) Wsp() IWspContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWspContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *Quoted_pairContext) Obs_qp() IObs_qpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_qpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_qpContext)
}

func (s *Quoted_pairContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_pairContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_pairContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterQuoted_pair(s)
	}
}

func (s *Quoted_pairContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitQuoted_pair(s)
	}
}

func (p *RFCParser) Quoted_pair() (localctx IQuoted_pairContext) {
	localctx = NewQuoted_pairContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 0, RFCParserRULE_quoted_pair)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(186)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 1, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(180)
			p.Match(RFCParserBACKSLASH)
		}
		p.SetState(183)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case RFCParserEXCLAMATION, RFCParserQUOTE, RFCParserHASH, RFCParserDOLLAR, RFCParserPERCENT, RFCParserAMPERSAND, RFCParserAPOSTROPHE, RFCParserLEFT_PAREN, RFCParserRIGHT_PAREN, RFCParserASTERISK, RFCParserPLUS, RFCParserCOMMA, RFCParserDASH, RFCParserPERIOD, RFCParserSLASH, RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE, RFCParserCOLON, RFCParserSEMICOLON, RFCParserLESS_THAN, RFCParserEQUALS, RFCParserGREATER_THAN, RFCParserQUESTION, RFCParserAT, RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z, RFCParserLEFT_BRACE, RFCParserBACKSLASH, RFCParserRIGHT_BRACE, RFCParserCARAT, RFCParserUNDERSCORE, RFCParserACCENT, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ, RFCParserLEFT_CURLY_BRACE, RFCParserPIPE, RFCParserRIGHT_CURLY_BRACE, RFCParserTILDE, RFCParserU_REST:
			{
				p.SetState(181)
				p.Vchar()
			}

		case RFCParserTAB, RFCParserSPACE:
			{
				p.SetState(182)
				p.Wsp()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(185)
			p.Obs_qp()
		}

	}

	return localctx
}

// IFwsContext is an interface to support dynamic dispatch.
type IFwsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsFwsContext differentiates from other interfaces.
	IsFwsContext()
}

type FwsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyFwsContext() *FwsContext {
	var p = new(FwsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_fws
	return p
}

func (*FwsContext) IsFwsContext() {}

func NewFwsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *FwsContext {
	var p = new(FwsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_fws

	return p
}

func (s *FwsContext) GetParser() antlr.Parser { return s.parser }

func (s *FwsContext) Crlf() ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *FwsContext) AllWsp() []IWspContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWspContext)(nil)).Elem())
	var tst = make([]IWspContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWspContext)
		}
	}

	return tst
}

func (s *FwsContext) Wsp(i int) IWspContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWspContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *FwsContext) Obs_fws() IObs_fwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_fwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_fwsContext)
}

func (s *FwsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *FwsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *FwsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterFws(s)
	}
}

func (s *FwsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitFws(s)
	}
}

func (p *RFCParser) Fws() (localctx IFwsContext) {
	localctx = NewFwsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 2, RFCParserRULE_fws)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(203)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 5, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(195)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 3, p.GetParserRuleContext()) == 1 {
			p.SetState(191)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for _la == RFCParserTAB || _la == RFCParserSPACE {
				{
					p.SetState(188)
					p.Wsp()
				}

				p.SetState(193)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}
			{
				p.SetState(194)
				p.Crlf()
			}

		}
		p.SetState(198)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(197)
					p.Wsp()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(200)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 4, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(202)
			p.Obs_fws()
		}

	}

	return localctx
}

// ICtextContext is an interface to support dynamic dispatch.
type ICtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCtextContext differentiates from other interfaces.
	IsCtextContext()
}

type CtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCtextContext() *CtextContext {
	var p = new(CtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_ctext
	return p
}

func (*CtextContext) IsCtextContext() {}

func NewCtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CtextContext {
	var p = new(CtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_ctext

	return p
}

func (s *CtextContext) GetParser() antlr.Parser { return s.parser }

func (s *CtextContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(RFCParserEXCLAMATION, 0)
}

func (s *CtextContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(RFCParserQUOTE, 0)
}

func (s *CtextContext) HASH() antlr.TerminalNode {
	return s.GetToken(RFCParserHASH, 0)
}

func (s *CtextContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(RFCParserDOLLAR, 0)
}

func (s *CtextContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserPERCENT, 0)
}

func (s *CtextContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(RFCParserAMPERSAND, 0)
}

func (s *CtextContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(RFCParserAPOSTROPHE, 0)
}

func (s *CtextContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(RFCParserASTERISK, 0)
}

func (s *CtextContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RFCParserPLUS, 0)
}

func (s *CtextContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, 0)
}

func (s *CtextContext) DASH() antlr.TerminalNode {
	return s.GetToken(RFCParserDASH, 0)
}

func (s *CtextContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, 0)
}

func (s *CtextContext) SLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserSLASH, 0)
}

func (s *CtextContext) ZERO() antlr.TerminalNode {
	return s.GetToken(RFCParserZERO, 0)
}

func (s *CtextContext) ONE() antlr.TerminalNode {
	return s.GetToken(RFCParserONE, 0)
}

func (s *CtextContext) TWO() antlr.TerminalNode {
	return s.GetToken(RFCParserTWO, 0)
}

func (s *CtextContext) THREE() antlr.TerminalNode {
	return s.GetToken(RFCParserTHREE, 0)
}

func (s *CtextContext) FOUR() antlr.TerminalNode {
	return s.GetToken(RFCParserFOUR, 0)
}

func (s *CtextContext) FIVE() antlr.TerminalNode {
	return s.GetToken(RFCParserFIVE, 0)
}

func (s *CtextContext) SIX() antlr.TerminalNode {
	return s.GetToken(RFCParserSIX, 0)
}

func (s *CtextContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(RFCParserSEVEN, 0)
}

func (s *CtextContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(RFCParserEIGHT, 0)
}

func (s *CtextContext) NINE() antlr.TerminalNode {
	return s.GetToken(RFCParserNINE, 0)
}

func (s *CtextContext) COLON() antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, 0)
}

func (s *CtextContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(RFCParserSEMICOLON, 0)
}

func (s *CtextContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserLESS_THAN, 0)
}

func (s *CtextContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(RFCParserEQUALS, 0)
}

func (s *CtextContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserGREATER_THAN, 0)
}

func (s *CtextContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(RFCParserQUESTION, 0)
}

func (s *CtextContext) AT() antlr.TerminalNode {
	return s.GetToken(RFCParserAT, 0)
}

func (s *CtextContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *CtextContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *CtextContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *CtextContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *CtextContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *CtextContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *CtextContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *CtextContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *CtextContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *CtextContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_J, 0)
}

func (s *CtextContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_K, 0)
}

func (s *CtextContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *CtextContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *CtextContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *CtextContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *CtextContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *CtextContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Q, 0)
}

func (s *CtextContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *CtextContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *CtextContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *CtextContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *CtextContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *CtextContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *CtextContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_X, 0)
}

func (s *CtextContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *CtextContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Z, 0)
}

func (s *CtextContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_BRACE, 0)
}

func (s *CtextContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_BRACE, 0)
}

func (s *CtextContext) CARAT() antlr.TerminalNode {
	return s.GetToken(RFCParserCARAT, 0)
}

func (s *CtextContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(RFCParserUNDERSCORE, 0)
}

func (s *CtextContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserACCENT, 0)
}

func (s *CtextContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *CtextContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *CtextContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *CtextContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *CtextContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *CtextContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *CtextContext) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *CtextContext) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *CtextContext) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *CtextContext) J() antlr.TerminalNode {
	return s.GetToken(RFCParserJ, 0)
}

func (s *CtextContext) K() antlr.TerminalNode {
	return s.GetToken(RFCParserK, 0)
}

func (s *CtextContext) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *CtextContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *CtextContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *CtextContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *CtextContext) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *CtextContext) Q() antlr.TerminalNode {
	return s.GetToken(RFCParserQ, 0)
}

func (s *CtextContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *CtextContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *CtextContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *CtextContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *CtextContext) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *CtextContext) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *CtextContext) X() antlr.TerminalNode {
	return s.GetToken(RFCParserX, 0)
}

func (s *CtextContext) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *CtextContext) Z() antlr.TerminalNode {
	return s.GetToken(RFCParserZ, 0)
}

func (s *CtextContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_CURLY_BRACE, 0)
}

func (s *CtextContext) PIPE() antlr.TerminalNode {
	return s.GetToken(RFCParserPIPE, 0)
}

func (s *CtextContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_CURLY_BRACE, 0)
}

func (s *CtextContext) TILDE() antlr.TerminalNode {
	return s.GetToken(RFCParserTILDE, 0)
}

func (s *CtextContext) Obs_ctext() IObs_ctextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_ctextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_ctextContext)
}

func (s *CtextContext) U_REST() antlr.TerminalNode {
	return s.GetToken(RFCParserU_REST, 0)
}

func (s *CtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterCtext(s)
	}
}

func (s *CtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitCtext(s)
	}
}

func (p *RFCParser) Ctext() (localctx ICtextContext) {
	localctx = NewCtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 4, RFCParserRULE_ctext)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(210)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserEXCLAMATION, RFCParserQUOTE, RFCParserHASH, RFCParserDOLLAR, RFCParserPERCENT, RFCParserAMPERSAND, RFCParserAPOSTROPHE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(205)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserEXCLAMATION)|(1<<RFCParserQUOTE)|(1<<RFCParserHASH)|(1<<RFCParserDOLLAR)|(1<<RFCParserPERCENT)|(1<<RFCParserAMPERSAND)|(1<<RFCParserAPOSTROPHE))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserASTERISK, RFCParserPLUS, RFCParserCOMMA, RFCParserDASH, RFCParserPERIOD, RFCParserSLASH, RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE, RFCParserCOLON, RFCParserSEMICOLON, RFCParserLESS_THAN, RFCParserEQUALS, RFCParserGREATER_THAN, RFCParserQUESTION, RFCParserAT, RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z, RFCParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(206)
			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserASTERISK)|(1<<RFCParserPLUS)|(1<<RFCParserCOMMA)|(1<<RFCParserDASH)|(1<<RFCParserPERIOD)|(1<<RFCParserSLASH)|(1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE)|(1<<RFCParserCOLON)|(1<<RFCParserSEMICOLON))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(RFCParserLESS_THAN-32))|(1<<(RFCParserEQUALS-32))|(1<<(RFCParserGREATER_THAN-32))|(1<<(RFCParserQUESTION-32))|(1<<(RFCParserAT-32))|(1<<(RFCParserCAP_A-32))|(1<<(RFCParserCAP_B-32))|(1<<(RFCParserCAP_C-32))|(1<<(RFCParserCAP_D-32))|(1<<(RFCParserCAP_E-32))|(1<<(RFCParserCAP_F-32))|(1<<(RFCParserCAP_G-32))|(1<<(RFCParserCAP_H-32))|(1<<(RFCParserCAP_I-32))|(1<<(RFCParserCAP_J-32))|(1<<(RFCParserCAP_K-32))|(1<<(RFCParserCAP_L-32))|(1<<(RFCParserCAP_M-32))|(1<<(RFCParserCAP_N-32))|(1<<(RFCParserCAP_O-32))|(1<<(RFCParserCAP_P-32))|(1<<(RFCParserCAP_Q-32))|(1<<(RFCParserCAP_R-32))|(1<<(RFCParserCAP_S-32))|(1<<(RFCParserCAP_T-32))|(1<<(RFCParserCAP_U-32))|(1<<(RFCParserCAP_V-32))|(1<<(RFCParserCAP_W-32))|(1<<(RFCParserCAP_X-32))|(1<<(RFCParserCAP_Y-32))|(1<<(RFCParserCAP_Z-32))|(1<<(RFCParserLEFT_BRACE-32)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserRIGHT_BRACE, RFCParserCARAT, RFCParserUNDERSCORE, RFCParserACCENT, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ, RFCParserLEFT_CURLY_BRACE, RFCParserPIPE, RFCParserRIGHT_CURLY_BRACE, RFCParserTILDE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(207)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(RFCParserRIGHT_BRACE-65))|(1<<(RFCParserCARAT-65))|(1<<(RFCParserUNDERSCORE-65))|(1<<(RFCParserACCENT-65))|(1<<(RFCParserA-65))|(1<<(RFCParserB-65))|(1<<(RFCParserC-65))|(1<<(RFCParserD-65))|(1<<(RFCParserE-65))|(1<<(RFCParserF-65))|(1<<(RFCParserG-65))|(1<<(RFCParserH-65))|(1<<(RFCParserI-65))|(1<<(RFCParserJ-65))|(1<<(RFCParserK-65))|(1<<(RFCParserL-65))|(1<<(RFCParserM-65))|(1<<(RFCParserN-65))|(1<<(RFCParserO-65))|(1<<(RFCParserP-65))|(1<<(RFCParserQ-65))|(1<<(RFCParserR-65))|(1<<(RFCParserS-65))|(1<<(RFCParserT-65))|(1<<(RFCParserU-65))|(1<<(RFCParserV-65))|(1<<(RFCParserW-65))|(1<<(RFCParserX-65))|(1<<(RFCParserY-65))|(1<<(RFCParserZ-65))|(1<<(RFCParserLEFT_CURLY_BRACE-65))|(1<<(RFCParserPIPE-65)))) != 0) || _la == RFCParserRIGHT_CURLY_BRACE || _la == RFCParserTILDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserU_0001, RFCParserU_0002, RFCParserU_0003, RFCParserU_0004, RFCParserU_0005, RFCParserU_0006, RFCParserU_0007, RFCParserU_0008, RFCParserU_000B, RFCParserU_000C, RFCParserU_000E, RFCParserU_000F, RFCParserU_0010, RFCParserU_0011, RFCParserU_0012, RFCParserU_0013, RFCParserU_0014, RFCParserU_0015, RFCParserU_0016, RFCParserU_0017, RFCParserU_0018, RFCParserU_0019, RFCParserU_001A, RFCParserU_001B, RFCParserU_001C, RFCParserU_001D, RFCParserU_001E, RFCParserU_001F, RFCParserU_007F:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(208)
			p.Obs_ctext()
		}

	case RFCParserU_REST:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(209)
			p.Match(RFCParserU_REST)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICcontentContext is an interface to support dynamic dispatch.
type ICcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCcontentContext differentiates from other interfaces.
	IsCcontentContext()
}

type CcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCcontentContext() *CcontentContext {
	var p = new(CcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_ccontent
	return p
}

func (*CcontentContext) IsCcontentContext() {}

func NewCcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CcontentContext {
	var p = new(CcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_ccontent

	return p
}

func (s *CcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *CcontentContext) Encoded_word() IEncoded_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncoded_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncoded_wordContext)
}

func (s *CcontentContext) Ctext() ICtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICtextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICtextContext)
}

func (s *CcontentContext) Quoted_pair() IQuoted_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_pairContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_pairContext)
}

func (s *CcontentContext) Comment() ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterCcontent(s)
	}
}

func (s *CcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitCcontent(s)
	}
}

func (p *RFCParser) Ccontent() (localctx ICcontentContext) {
	localctx = NewCcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 6, RFCParserRULE_ccontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(216)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 7, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(212)
			p.Encoded_word()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(213)
			p.Ctext()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(214)
			p.Quoted_pair()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(215)
			p.Comment()
		}

	}

	return localctx
}

// ICommentContext is an interface to support dynamic dispatch.
type ICommentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCommentContext differentiates from other interfaces.
	IsCommentContext()
}

type CommentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCommentContext() *CommentContext {
	var p = new(CommentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_comment
	return p
}

func (*CommentContext) IsCommentContext() {}

func NewCommentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CommentContext {
	var p = new(CommentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_comment

	return p
}

func (s *CommentContext) GetParser() antlr.Parser { return s.parser }

func (s *CommentContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_PAREN, 0)
}

func (s *CommentContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_PAREN, 0)
}

func (s *CommentContext) AllCcontent() []ICcontentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICcontentContext)(nil)).Elem())
	var tst = make([]ICcontentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICcontentContext)
		}
	}

	return tst
}

func (s *CommentContext) Ccontent(i int) ICcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICcontentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICcontentContext)
}

func (s *CommentContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *CommentContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *CommentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CommentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CommentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterComment(s)
	}
}

func (s *CommentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitComment(s)
	}
}

func (p *RFCParser) Comment() (localctx ICommentContext) {
	localctx = NewCommentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 8, RFCParserRULE_comment)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(218)
		p.Match(RFCParserLEFT_PAREN)
	}
	p.SetState(225)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(220)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 8, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(219)
					p.Fws()
				}

			}
			{
				p.SetState(222)
				p.Ccontent()
			}

		}
		p.SetState(227)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 9, p.GetParserRuleContext())
	}
	p.SetState(229)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE))) != 0 {
		{
			p.SetState(228)
			p.Fws()
		}

	}
	{
		p.SetState(231)
		p.Match(RFCParserRIGHT_PAREN)
	}

	return localctx
}

// ICfwsContext is an interface to support dynamic dispatch.
type ICfwsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCfwsContext differentiates from other interfaces.
	IsCfwsContext()
}

type CfwsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCfwsContext() *CfwsContext {
	var p = new(CfwsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_cfws
	return p
}

func (*CfwsContext) IsCfwsContext() {}

func NewCfwsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CfwsContext {
	var p = new(CfwsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_cfws

	return p
}

func (s *CfwsContext) GetParser() antlr.Parser { return s.parser }

func (s *CfwsContext) AllComment() []ICommentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICommentContext)(nil)).Elem())
	var tst = make([]ICommentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICommentContext)
		}
	}

	return tst
}

func (s *CfwsContext) Comment(i int) ICommentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICommentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICommentContext)
}

func (s *CfwsContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *CfwsContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *CfwsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CfwsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CfwsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterCfws(s)
	}
}

func (s *CfwsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitCfws(s)
	}
}

func (p *RFCParser) Cfws() (localctx ICfwsContext) {
	localctx = NewCfwsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 10, RFCParserRULE_cfws)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(245)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 14, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(237)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				p.SetState(234)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)

				if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE))) != 0 {
					{
						p.SetState(233)
						p.Fws()
					}

				}
				{
					p.SetState(236)
					p.Comment()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(239)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 12, p.GetParserRuleContext())
		}
		p.SetState(242)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 13, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(241)
				p.Fws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(244)
			p.Fws()
		}

	}

	return localctx
}

// IAtextContext is an interface to support dynamic dispatch.
type IAtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtextContext differentiates from other interfaces.
	IsAtextContext()
}

type AtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtextContext() *AtextContext {
	var p = new(AtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_atext
	return p
}

func (*AtextContext) IsAtextContext() {}

func NewAtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtextContext {
	var p = new(AtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_atext

	return p
}

func (s *AtextContext) GetParser() antlr.Parser { return s.parser }

func (s *AtextContext) Alpha() IAlphaContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAlphaContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAlphaContext)
}

func (s *AtextContext) Digit() IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *AtextContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(RFCParserEXCLAMATION, 0)
}

func (s *AtextContext) HASH() antlr.TerminalNode {
	return s.GetToken(RFCParserHASH, 0)
}

func (s *AtextContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(RFCParserDOLLAR, 0)
}

func (s *AtextContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserPERCENT, 0)
}

func (s *AtextContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(RFCParserAMPERSAND, 0)
}

func (s *AtextContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(RFCParserAPOSTROPHE, 0)
}

func (s *AtextContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(RFCParserASTERISK, 0)
}

func (s *AtextContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RFCParserPLUS, 0)
}

func (s *AtextContext) DASH() antlr.TerminalNode {
	return s.GetToken(RFCParserDASH, 0)
}

func (s *AtextContext) SLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserSLASH, 0)
}

func (s *AtextContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(RFCParserEQUALS, 0)
}

func (s *AtextContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(RFCParserQUESTION, 0)
}

func (s *AtextContext) CARAT() antlr.TerminalNode {
	return s.GetToken(RFCParserCARAT, 0)
}

func (s *AtextContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(RFCParserUNDERSCORE, 0)
}

func (s *AtextContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserACCENT, 0)
}

func (s *AtextContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_CURLY_BRACE, 0)
}

func (s *AtextContext) PIPE() antlr.TerminalNode {
	return s.GetToken(RFCParserPIPE, 0)
}

func (s *AtextContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_CURLY_BRACE, 0)
}

func (s *AtextContext) TILDE() antlr.TerminalNode {
	return s.GetToken(RFCParserTILDE, 0)
}

func (s *AtextContext) U_REST() antlr.TerminalNode {
	return s.GetToken(RFCParserU_REST, 0)
}

func (s *AtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterAtext(s)
	}
}

func (s *AtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitAtext(s)
	}
}

func (p *RFCParser) Atext() (localctx IAtextContext) {
	localctx = NewAtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 12, RFCParserRULE_atext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(269)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(247)
			p.Alpha()
		}

	case RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(248)
			p.Digit()
		}

	case RFCParserEXCLAMATION:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(249)
			p.Match(RFCParserEXCLAMATION)
		}

	case RFCParserHASH:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(250)
			p.Match(RFCParserHASH)
		}

	case RFCParserDOLLAR:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(251)
			p.Match(RFCParserDOLLAR)
		}

	case RFCParserPERCENT:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(252)
			p.Match(RFCParserPERCENT)
		}

	case RFCParserAMPERSAND:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(253)
			p.Match(RFCParserAMPERSAND)
		}

	case RFCParserAPOSTROPHE:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(254)
			p.Match(RFCParserAPOSTROPHE)
		}

	case RFCParserASTERISK:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(255)
			p.Match(RFCParserASTERISK)
		}

	case RFCParserPLUS:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(256)
			p.Match(RFCParserPLUS)
		}

	case RFCParserDASH:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(257)
			p.Match(RFCParserDASH)
		}

	case RFCParserSLASH:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(258)
			p.Match(RFCParserSLASH)
		}

	case RFCParserEQUALS:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(259)
			p.Match(RFCParserEQUALS)
		}

	case RFCParserQUESTION:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(260)
			p.Match(RFCParserQUESTION)
		}

	case RFCParserCARAT:
		p.EnterOuterAlt(localctx, 15)
		{
			p.SetState(261)
			p.Match(RFCParserCARAT)
		}

	case RFCParserUNDERSCORE:
		p.EnterOuterAlt(localctx, 16)
		{
			p.SetState(262)
			p.Match(RFCParserUNDERSCORE)
		}

	case RFCParserACCENT:
		p.EnterOuterAlt(localctx, 17)
		{
			p.SetState(263)
			p.Match(RFCParserACCENT)
		}

	case RFCParserLEFT_CURLY_BRACE:
		p.EnterOuterAlt(localctx, 18)
		{
			p.SetState(264)
			p.Match(RFCParserLEFT_CURLY_BRACE)
		}

	case RFCParserPIPE:
		p.EnterOuterAlt(localctx, 19)
		{
			p.SetState(265)
			p.Match(RFCParserPIPE)
		}

	case RFCParserRIGHT_CURLY_BRACE:
		p.EnterOuterAlt(localctx, 20)
		{
			p.SetState(266)
			p.Match(RFCParserRIGHT_CURLY_BRACE)
		}

	case RFCParserTILDE:
		p.EnterOuterAlt(localctx, 21)
		{
			p.SetState(267)
			p.Match(RFCParserTILDE)
		}

	case RFCParserU_REST:
		p.EnterOuterAlt(localctx, 22)
		{
			p.SetState(268)
			p.Match(RFCParserU_REST)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAtomContext is an interface to support dynamic dispatch.
type IAtomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAtomContext differentiates from other interfaces.
	IsAtomContext()
}

type AtomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAtomContext() *AtomContext {
	var p = new(AtomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_atom
	return p
}

func (*AtomContext) IsAtomContext() {}

func NewAtomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AtomContext {
	var p = new(AtomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_atom

	return p
}

func (s *AtomContext) GetParser() antlr.Parser { return s.parser }

func (s *AtomContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *AtomContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *AtomContext) AllAtext() []IAtextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtextContext)(nil)).Elem())
	var tst = make([]IAtextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtextContext)
		}
	}

	return tst
}

func (s *AtomContext) Atext(i int) IAtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtextContext)
}

func (s *AtomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AtomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AtomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterAtom(s)
	}
}

func (s *AtomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitAtom(s)
	}
}

func (p *RFCParser) Atom() (localctx IAtomContext) {
	localctx = NewAtomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 14, RFCParserRULE_atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(272)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(271)
			p.Cfws()
		}

	}
	p.SetState(275)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(274)
				p.Atext()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(277)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 17, p.GetParserRuleContext())
	}
	p.SetState(280)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 18, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(279)
			p.Cfws()
		}

	}

	return localctx
}

// IDot_atom_textContext is an interface to support dynamic dispatch.
type IDot_atom_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDot_atom_textContext differentiates from other interfaces.
	IsDot_atom_textContext()
}

type Dot_atom_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDot_atom_textContext() *Dot_atom_textContext {
	var p = new(Dot_atom_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_dot_atom_text
	return p
}

func (*Dot_atom_textContext) IsDot_atom_textContext() {}

func NewDot_atom_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dot_atom_textContext {
	var p = new(Dot_atom_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_dot_atom_text

	return p
}

func (s *Dot_atom_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Dot_atom_textContext) AllAtext() []IAtextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtextContext)(nil)).Elem())
	var tst = make([]IAtextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtextContext)
		}
	}

	return tst
}

func (s *Dot_atom_textContext) Atext(i int) IAtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtextContext)
}

func (s *Dot_atom_textContext) AllPERIOD() []antlr.TerminalNode {
	return s.GetTokens(RFCParserPERIOD)
}

func (s *Dot_atom_textContext) PERIOD(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, i)
}

func (s *Dot_atom_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dot_atom_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dot_atom_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDot_atom_text(s)
	}
}

func (s *Dot_atom_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDot_atom_text(s)
	}
}

func (p *RFCParser) Dot_atom_text() (localctx IDot_atom_textContext) {
	localctx = NewDot_atom_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 16, RFCParserRULE_dot_atom_text)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(283)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserEXCLAMATION)|(1<<RFCParserHASH)|(1<<RFCParserDOLLAR)|(1<<RFCParserPERCENT)|(1<<RFCParserAMPERSAND)|(1<<RFCParserAPOSTROPHE)|(1<<RFCParserASTERISK)|(1<<RFCParserPLUS)|(1<<RFCParserDASH)|(1<<RFCParserSLASH)|(1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(RFCParserEQUALS-33))|(1<<(RFCParserQUESTION-33))|(1<<(RFCParserCAP_A-33))|(1<<(RFCParserCAP_B-33))|(1<<(RFCParserCAP_C-33))|(1<<(RFCParserCAP_D-33))|(1<<(RFCParserCAP_E-33))|(1<<(RFCParserCAP_F-33))|(1<<(RFCParserCAP_G-33))|(1<<(RFCParserCAP_H-33))|(1<<(RFCParserCAP_I-33))|(1<<(RFCParserCAP_J-33))|(1<<(RFCParserCAP_K-33))|(1<<(RFCParserCAP_L-33))|(1<<(RFCParserCAP_M-33))|(1<<(RFCParserCAP_N-33))|(1<<(RFCParserCAP_O-33))|(1<<(RFCParserCAP_P-33))|(1<<(RFCParserCAP_Q-33))|(1<<(RFCParserCAP_R-33))|(1<<(RFCParserCAP_S-33))|(1<<(RFCParserCAP_T-33))|(1<<(RFCParserCAP_U-33))|(1<<(RFCParserCAP_V-33))|(1<<(RFCParserCAP_W-33))|(1<<(RFCParserCAP_X-33))|(1<<(RFCParserCAP_Y-33))|(1<<(RFCParserCAP_Z-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(RFCParserCARAT-66))|(1<<(RFCParserUNDERSCORE-66))|(1<<(RFCParserACCENT-66))|(1<<(RFCParserA-66))|(1<<(RFCParserB-66))|(1<<(RFCParserC-66))|(1<<(RFCParserD-66))|(1<<(RFCParserE-66))|(1<<(RFCParserF-66))|(1<<(RFCParserG-66))|(1<<(RFCParserH-66))|(1<<(RFCParserI-66))|(1<<(RFCParserJ-66))|(1<<(RFCParserK-66))|(1<<(RFCParserL-66))|(1<<(RFCParserM-66))|(1<<(RFCParserN-66))|(1<<(RFCParserO-66))|(1<<(RFCParserP-66))|(1<<(RFCParserQ-66))|(1<<(RFCParserR-66))|(1<<(RFCParserS-66))|(1<<(RFCParserT-66))|(1<<(RFCParserU-66))|(1<<(RFCParserV-66))|(1<<(RFCParserW-66))|(1<<(RFCParserX-66))|(1<<(RFCParserY-66))|(1<<(RFCParserZ-66))|(1<<(RFCParserLEFT_CURLY_BRACE-66))|(1<<(RFCParserPIPE-66))|(1<<(RFCParserRIGHT_CURLY_BRACE-66)))) != 0) || _la == RFCParserTILDE || _la == RFCParserU_REST {
		{
			p.SetState(282)
			p.Atext()
		}

		p.SetState(285)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	p.SetState(295)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(287)
				p.Match(RFCParserPERIOD)
			}
			p.SetState(289)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserEXCLAMATION)|(1<<RFCParserHASH)|(1<<RFCParserDOLLAR)|(1<<RFCParserPERCENT)|(1<<RFCParserAMPERSAND)|(1<<RFCParserAPOSTROPHE)|(1<<RFCParserASTERISK)|(1<<RFCParserPLUS)|(1<<RFCParserDASH)|(1<<RFCParserSLASH)|(1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(RFCParserEQUALS-33))|(1<<(RFCParserQUESTION-33))|(1<<(RFCParserCAP_A-33))|(1<<(RFCParserCAP_B-33))|(1<<(RFCParserCAP_C-33))|(1<<(RFCParserCAP_D-33))|(1<<(RFCParserCAP_E-33))|(1<<(RFCParserCAP_F-33))|(1<<(RFCParserCAP_G-33))|(1<<(RFCParserCAP_H-33))|(1<<(RFCParserCAP_I-33))|(1<<(RFCParserCAP_J-33))|(1<<(RFCParserCAP_K-33))|(1<<(RFCParserCAP_L-33))|(1<<(RFCParserCAP_M-33))|(1<<(RFCParserCAP_N-33))|(1<<(RFCParserCAP_O-33))|(1<<(RFCParserCAP_P-33))|(1<<(RFCParserCAP_Q-33))|(1<<(RFCParserCAP_R-33))|(1<<(RFCParserCAP_S-33))|(1<<(RFCParserCAP_T-33))|(1<<(RFCParserCAP_U-33))|(1<<(RFCParserCAP_V-33))|(1<<(RFCParserCAP_W-33))|(1<<(RFCParserCAP_X-33))|(1<<(RFCParserCAP_Y-33))|(1<<(RFCParserCAP_Z-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(RFCParserCARAT-66))|(1<<(RFCParserUNDERSCORE-66))|(1<<(RFCParserACCENT-66))|(1<<(RFCParserA-66))|(1<<(RFCParserB-66))|(1<<(RFCParserC-66))|(1<<(RFCParserD-66))|(1<<(RFCParserE-66))|(1<<(RFCParserF-66))|(1<<(RFCParserG-66))|(1<<(RFCParserH-66))|(1<<(RFCParserI-66))|(1<<(RFCParserJ-66))|(1<<(RFCParserK-66))|(1<<(RFCParserL-66))|(1<<(RFCParserM-66))|(1<<(RFCParserN-66))|(1<<(RFCParserO-66))|(1<<(RFCParserP-66))|(1<<(RFCParserQ-66))|(1<<(RFCParserR-66))|(1<<(RFCParserS-66))|(1<<(RFCParserT-66))|(1<<(RFCParserU-66))|(1<<(RFCParserV-66))|(1<<(RFCParserW-66))|(1<<(RFCParserX-66))|(1<<(RFCParserY-66))|(1<<(RFCParserZ-66))|(1<<(RFCParserLEFT_CURLY_BRACE-66))|(1<<(RFCParserPIPE-66))|(1<<(RFCParserRIGHT_CURLY_BRACE-66)))) != 0) || _la == RFCParserTILDE || _la == RFCParserU_REST {
				{
					p.SetState(288)
					p.Atext()
				}

				p.SetState(291)
				p.GetErrorHandler().Sync(p)
				_la = p.GetTokenStream().LA(1)
			}

		}
		p.SetState(297)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 21, p.GetParserRuleContext())
	}

	return localctx
}

// IDot_atomContext is an interface to support dynamic dispatch.
type IDot_atomContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDot_atomContext differentiates from other interfaces.
	IsDot_atomContext()
}

type Dot_atomContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDot_atomContext() *Dot_atomContext {
	var p = new(Dot_atomContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_dot_atom
	return p
}

func (*Dot_atomContext) IsDot_atomContext() {}

func NewDot_atomContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Dot_atomContext {
	var p = new(Dot_atomContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_dot_atom

	return p
}

func (s *Dot_atomContext) GetParser() antlr.Parser { return s.parser }

func (s *Dot_atomContext) Dot_atom_text() IDot_atom_textContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDot_atom_textContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDot_atom_textContext)
}

func (s *Dot_atomContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Dot_atomContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Dot_atomContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, 0)
}

func (s *Dot_atomContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Dot_atomContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Dot_atomContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDot_atom(s)
	}
}

func (s *Dot_atomContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDot_atom(s)
	}
}

func (p *RFCParser) Dot_atom() (localctx IDot_atomContext) {
	localctx = NewDot_atomContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 18, RFCParserRULE_dot_atom)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(299)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(298)
			p.Cfws()
		}

	}
	{
		p.SetState(301)
		p.Dot_atom_text()
	}
	p.SetState(303)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFCParserPERIOD {
		{
			p.SetState(302)
			p.Match(RFCParserPERIOD)
		}

	}
	p.SetState(306)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 24, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(305)
			p.Cfws()
		}

	}

	return localctx
}

// IQtextContext is an interface to support dynamic dispatch.
type IQtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQtextContext differentiates from other interfaces.
	IsQtextContext()
}

type QtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQtextContext() *QtextContext {
	var p = new(QtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_qtext
	return p
}

func (*QtextContext) IsQtextContext() {}

func NewQtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QtextContext {
	var p = new(QtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_qtext

	return p
}

func (s *QtextContext) GetParser() antlr.Parser { return s.parser }

func (s *QtextContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(RFCParserEXCLAMATION, 0)
}

func (s *QtextContext) HASH() antlr.TerminalNode {
	return s.GetToken(RFCParserHASH, 0)
}

func (s *QtextContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(RFCParserDOLLAR, 0)
}

func (s *QtextContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserPERCENT, 0)
}

func (s *QtextContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(RFCParserAMPERSAND, 0)
}

func (s *QtextContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(RFCParserAPOSTROPHE, 0)
}

func (s *QtextContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_PAREN, 0)
}

func (s *QtextContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_PAREN, 0)
}

func (s *QtextContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(RFCParserASTERISK, 0)
}

func (s *QtextContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RFCParserPLUS, 0)
}

func (s *QtextContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, 0)
}

func (s *QtextContext) DASH() antlr.TerminalNode {
	return s.GetToken(RFCParserDASH, 0)
}

func (s *QtextContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, 0)
}

func (s *QtextContext) SLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserSLASH, 0)
}

func (s *QtextContext) ZERO() antlr.TerminalNode {
	return s.GetToken(RFCParserZERO, 0)
}

func (s *QtextContext) ONE() antlr.TerminalNode {
	return s.GetToken(RFCParserONE, 0)
}

func (s *QtextContext) TWO() antlr.TerminalNode {
	return s.GetToken(RFCParserTWO, 0)
}

func (s *QtextContext) THREE() antlr.TerminalNode {
	return s.GetToken(RFCParserTHREE, 0)
}

func (s *QtextContext) FOUR() antlr.TerminalNode {
	return s.GetToken(RFCParserFOUR, 0)
}

func (s *QtextContext) FIVE() antlr.TerminalNode {
	return s.GetToken(RFCParserFIVE, 0)
}

func (s *QtextContext) SIX() antlr.TerminalNode {
	return s.GetToken(RFCParserSIX, 0)
}

func (s *QtextContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(RFCParserSEVEN, 0)
}

func (s *QtextContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(RFCParserEIGHT, 0)
}

func (s *QtextContext) NINE() antlr.TerminalNode {
	return s.GetToken(RFCParserNINE, 0)
}

func (s *QtextContext) COLON() antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, 0)
}

func (s *QtextContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(RFCParserSEMICOLON, 0)
}

func (s *QtextContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserLESS_THAN, 0)
}

func (s *QtextContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(RFCParserEQUALS, 0)
}

func (s *QtextContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserGREATER_THAN, 0)
}

func (s *QtextContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(RFCParserQUESTION, 0)
}

func (s *QtextContext) AT() antlr.TerminalNode {
	return s.GetToken(RFCParserAT, 0)
}

func (s *QtextContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *QtextContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *QtextContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *QtextContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *QtextContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *QtextContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *QtextContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *QtextContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *QtextContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *QtextContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_J, 0)
}

func (s *QtextContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_K, 0)
}

func (s *QtextContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *QtextContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *QtextContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *QtextContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *QtextContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *QtextContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Q, 0)
}

func (s *QtextContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *QtextContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *QtextContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *QtextContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *QtextContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *QtextContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *QtextContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_X, 0)
}

func (s *QtextContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *QtextContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Z, 0)
}

func (s *QtextContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_BRACE, 0)
}

func (s *QtextContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_BRACE, 0)
}

func (s *QtextContext) CARAT() antlr.TerminalNode {
	return s.GetToken(RFCParserCARAT, 0)
}

func (s *QtextContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(RFCParserUNDERSCORE, 0)
}

func (s *QtextContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserACCENT, 0)
}

func (s *QtextContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *QtextContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *QtextContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *QtextContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *QtextContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *QtextContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *QtextContext) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *QtextContext) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *QtextContext) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *QtextContext) J() antlr.TerminalNode {
	return s.GetToken(RFCParserJ, 0)
}

func (s *QtextContext) K() antlr.TerminalNode {
	return s.GetToken(RFCParserK, 0)
}

func (s *QtextContext) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *QtextContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *QtextContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *QtextContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *QtextContext) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *QtextContext) Q() antlr.TerminalNode {
	return s.GetToken(RFCParserQ, 0)
}

func (s *QtextContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *QtextContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *QtextContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *QtextContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *QtextContext) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *QtextContext) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *QtextContext) X() antlr.TerminalNode {
	return s.GetToken(RFCParserX, 0)
}

func (s *QtextContext) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *QtextContext) Z() antlr.TerminalNode {
	return s.GetToken(RFCParserZ, 0)
}

func (s *QtextContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_CURLY_BRACE, 0)
}

func (s *QtextContext) PIPE() antlr.TerminalNode {
	return s.GetToken(RFCParserPIPE, 0)
}

func (s *QtextContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_CURLY_BRACE, 0)
}

func (s *QtextContext) TILDE() antlr.TerminalNode {
	return s.GetToken(RFCParserTILDE, 0)
}

func (s *QtextContext) Obs_qtext() IObs_qtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_qtextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_qtextContext)
}

func (s *QtextContext) U_REST() antlr.TerminalNode {
	return s.GetToken(RFCParserU_REST, 0)
}

func (s *QtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterQtext(s)
	}
}

func (s *QtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitQtext(s)
	}
}

func (p *RFCParser) Qtext() (localctx IQtextContext) {
	localctx = NewQtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 20, RFCParserRULE_qtext)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(313)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserEXCLAMATION:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(308)
			p.Match(RFCParserEXCLAMATION)
		}

	case RFCParserHASH, RFCParserDOLLAR, RFCParserPERCENT, RFCParserAMPERSAND, RFCParserAPOSTROPHE, RFCParserLEFT_PAREN, RFCParserRIGHT_PAREN, RFCParserASTERISK, RFCParserPLUS, RFCParserCOMMA, RFCParserDASH, RFCParserPERIOD, RFCParserSLASH, RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE, RFCParserCOLON, RFCParserSEMICOLON, RFCParserLESS_THAN, RFCParserEQUALS, RFCParserGREATER_THAN, RFCParserQUESTION, RFCParserAT, RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z, RFCParserLEFT_BRACE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(309)
			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserHASH)|(1<<RFCParserDOLLAR)|(1<<RFCParserPERCENT)|(1<<RFCParserAMPERSAND)|(1<<RFCParserAPOSTROPHE)|(1<<RFCParserLEFT_PAREN)|(1<<RFCParserRIGHT_PAREN)|(1<<RFCParserASTERISK)|(1<<RFCParserPLUS)|(1<<RFCParserCOMMA)|(1<<RFCParserDASH)|(1<<RFCParserPERIOD)|(1<<RFCParserSLASH)|(1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE)|(1<<RFCParserCOLON)|(1<<RFCParserSEMICOLON))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(RFCParserLESS_THAN-32))|(1<<(RFCParserEQUALS-32))|(1<<(RFCParserGREATER_THAN-32))|(1<<(RFCParserQUESTION-32))|(1<<(RFCParserAT-32))|(1<<(RFCParserCAP_A-32))|(1<<(RFCParserCAP_B-32))|(1<<(RFCParserCAP_C-32))|(1<<(RFCParserCAP_D-32))|(1<<(RFCParserCAP_E-32))|(1<<(RFCParserCAP_F-32))|(1<<(RFCParserCAP_G-32))|(1<<(RFCParserCAP_H-32))|(1<<(RFCParserCAP_I-32))|(1<<(RFCParserCAP_J-32))|(1<<(RFCParserCAP_K-32))|(1<<(RFCParserCAP_L-32))|(1<<(RFCParserCAP_M-32))|(1<<(RFCParserCAP_N-32))|(1<<(RFCParserCAP_O-32))|(1<<(RFCParserCAP_P-32))|(1<<(RFCParserCAP_Q-32))|(1<<(RFCParserCAP_R-32))|(1<<(RFCParserCAP_S-32))|(1<<(RFCParserCAP_T-32))|(1<<(RFCParserCAP_U-32))|(1<<(RFCParserCAP_V-32))|(1<<(RFCParserCAP_W-32))|(1<<(RFCParserCAP_X-32))|(1<<(RFCParserCAP_Y-32))|(1<<(RFCParserCAP_Z-32))|(1<<(RFCParserLEFT_BRACE-32)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserRIGHT_BRACE, RFCParserCARAT, RFCParserUNDERSCORE, RFCParserACCENT, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ, RFCParserLEFT_CURLY_BRACE, RFCParserPIPE, RFCParserRIGHT_CURLY_BRACE, RFCParserTILDE:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(310)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(RFCParserRIGHT_BRACE-65))|(1<<(RFCParserCARAT-65))|(1<<(RFCParserUNDERSCORE-65))|(1<<(RFCParserACCENT-65))|(1<<(RFCParserA-65))|(1<<(RFCParserB-65))|(1<<(RFCParserC-65))|(1<<(RFCParserD-65))|(1<<(RFCParserE-65))|(1<<(RFCParserF-65))|(1<<(RFCParserG-65))|(1<<(RFCParserH-65))|(1<<(RFCParserI-65))|(1<<(RFCParserJ-65))|(1<<(RFCParserK-65))|(1<<(RFCParserL-65))|(1<<(RFCParserM-65))|(1<<(RFCParserN-65))|(1<<(RFCParserO-65))|(1<<(RFCParserP-65))|(1<<(RFCParserQ-65))|(1<<(RFCParserR-65))|(1<<(RFCParserS-65))|(1<<(RFCParserT-65))|(1<<(RFCParserU-65))|(1<<(RFCParserV-65))|(1<<(RFCParserW-65))|(1<<(RFCParserX-65))|(1<<(RFCParserY-65))|(1<<(RFCParserZ-65))|(1<<(RFCParserLEFT_CURLY_BRACE-65))|(1<<(RFCParserPIPE-65)))) != 0) || _la == RFCParserRIGHT_CURLY_BRACE || _la == RFCParserTILDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserU_0001, RFCParserU_0002, RFCParserU_0003, RFCParserU_0004, RFCParserU_0005, RFCParserU_0006, RFCParserU_0007, RFCParserU_0008, RFCParserU_000B, RFCParserU_000C, RFCParserU_000E, RFCParserU_000F, RFCParserU_0010, RFCParserU_0011, RFCParserU_0012, RFCParserU_0013, RFCParserU_0014, RFCParserU_0015, RFCParserU_0016, RFCParserU_0017, RFCParserU_0018, RFCParserU_0019, RFCParserU_001A, RFCParserU_001B, RFCParserU_001C, RFCParserU_001D, RFCParserU_001E, RFCParserU_001F, RFCParserU_007F:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(311)
			p.Obs_qtext()
		}

	case RFCParserU_REST:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(312)
			p.Match(RFCParserU_REST)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQcontentContext is an interface to support dynamic dispatch.
type IQcontentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQcontentContext differentiates from other interfaces.
	IsQcontentContext()
}

type QcontentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQcontentContext() *QcontentContext {
	var p = new(QcontentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_qcontent
	return p
}

func (*QcontentContext) IsQcontentContext() {}

func NewQcontentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *QcontentContext {
	var p = new(QcontentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_qcontent

	return p
}

func (s *QcontentContext) GetParser() antlr.Parser { return s.parser }

func (s *QcontentContext) Qtext() IQtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQtextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQtextContext)
}

func (s *QcontentContext) Quoted_pair() IQuoted_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_pairContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_pairContext)
}

func (s *QcontentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *QcontentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *QcontentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterQcontent(s)
	}
}

func (s *QcontentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitQcontent(s)
	}
}

func (p *RFCParser) Qcontent() (localctx IQcontentContext) {
	localctx = NewQcontentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 22, RFCParserRULE_qcontent)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(317)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserEXCLAMATION, RFCParserHASH, RFCParserDOLLAR, RFCParserPERCENT, RFCParserAMPERSAND, RFCParserAPOSTROPHE, RFCParserLEFT_PAREN, RFCParserRIGHT_PAREN, RFCParserASTERISK, RFCParserPLUS, RFCParserCOMMA, RFCParserDASH, RFCParserPERIOD, RFCParserSLASH, RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE, RFCParserCOLON, RFCParserSEMICOLON, RFCParserLESS_THAN, RFCParserEQUALS, RFCParserGREATER_THAN, RFCParserQUESTION, RFCParserAT, RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z, RFCParserLEFT_BRACE, RFCParserRIGHT_BRACE, RFCParserCARAT, RFCParserUNDERSCORE, RFCParserACCENT, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ, RFCParserLEFT_CURLY_BRACE, RFCParserPIPE, RFCParserRIGHT_CURLY_BRACE, RFCParserTILDE, RFCParserU_0001, RFCParserU_0002, RFCParserU_0003, RFCParserU_0004, RFCParserU_0005, RFCParserU_0006, RFCParserU_0007, RFCParserU_0008, RFCParserU_000B, RFCParserU_000C, RFCParserU_000E, RFCParserU_000F, RFCParserU_0010, RFCParserU_0011, RFCParserU_0012, RFCParserU_0013, RFCParserU_0014, RFCParserU_0015, RFCParserU_0016, RFCParserU_0017, RFCParserU_0018, RFCParserU_0019, RFCParserU_001A, RFCParserU_001B, RFCParserU_001C, RFCParserU_001D, RFCParserU_001E, RFCParserU_001F, RFCParserU_007F, RFCParserU_REST:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(315)
			p.Qtext()
		}

	case RFCParserBACKSLASH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(316)
			p.Quoted_pair()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IQuoted_contentContext is an interface to support dynamic dispatch.
type IQuoted_contentContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuoted_contentContext differentiates from other interfaces.
	IsQuoted_contentContext()
}

type Quoted_contentContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_contentContext() *Quoted_contentContext {
	var p = new(Quoted_contentContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_quoted_content
	return p
}

func (*Quoted_contentContext) IsQuoted_contentContext() {}

func NewQuoted_contentContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_contentContext {
	var p = new(Quoted_contentContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_quoted_content

	return p
}

func (s *Quoted_contentContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_contentContext) AllQcontent() []IQcontentContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IQcontentContext)(nil)).Elem())
	var tst = make([]IQcontentContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IQcontentContext)
		}
	}

	return tst
}

func (s *Quoted_contentContext) Qcontent(i int) IQcontentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQcontentContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IQcontentContext)
}

func (s *Quoted_contentContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *Quoted_contentContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *Quoted_contentContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_contentContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_contentContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterQuoted_content(s)
	}
}

func (s *Quoted_contentContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitQuoted_content(s)
	}
}

func (p *RFCParser) Quoted_content() (localctx IQuoted_contentContext) {
	localctx = NewQuoted_contentContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 24, RFCParserRULE_quoted_content)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(325)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(320)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE))) != 0 {
				{
					p.SetState(319)
					p.Fws()
				}

			}
			{
				p.SetState(322)
				p.Qcontent()
			}

		}
		p.SetState(327)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 28, p.GetParserRuleContext())
	}
	p.SetState(329)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE))) != 0 {
		{
			p.SetState(328)
			p.Fws()
		}

	}

	return localctx
}

// IQuoted_stringContext is an interface to support dynamic dispatch.
type IQuoted_stringContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsQuoted_stringContext differentiates from other interfaces.
	IsQuoted_stringContext()
}

type Quoted_stringContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyQuoted_stringContext() *Quoted_stringContext {
	var p = new(Quoted_stringContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_quoted_string
	return p
}

func (*Quoted_stringContext) IsQuoted_stringContext() {}

func NewQuoted_stringContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Quoted_stringContext {
	var p = new(Quoted_stringContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_quoted_string

	return p
}

func (s *Quoted_stringContext) GetParser() antlr.Parser { return s.parser }

func (s *Quoted_stringContext) AllDquote() []IDquoteContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDquoteContext)(nil)).Elem())
	var tst = make([]IDquoteContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDquoteContext)
		}
	}

	return tst
}

func (s *Quoted_stringContext) Dquote(i int) IDquoteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDquoteContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDquoteContext)
}

func (s *Quoted_stringContext) Quoted_content() IQuoted_contentContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_contentContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_contentContext)
}

func (s *Quoted_stringContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Quoted_stringContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Quoted_stringContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Quoted_stringContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Quoted_stringContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterQuoted_string(s)
	}
}

func (s *Quoted_stringContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitQuoted_string(s)
	}
}

func (p *RFCParser) Quoted_string() (localctx IQuoted_stringContext) {
	localctx = NewQuoted_stringContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 26, RFCParserRULE_quoted_string)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(332)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(331)
			p.Cfws()
		}

	}
	{
		p.SetState(334)
		p.Dquote()
	}
	{
		p.SetState(335)
		p.Quoted_content()
	}
	{
		p.SetState(336)
		p.Dquote()
	}
	p.SetState(338)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 31, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(337)
			p.Cfws()
		}

	}

	return localctx
}

// IWordContext is an interface to support dynamic dispatch.
type IWordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWordContext differentiates from other interfaces.
	IsWordContext()
}

type WordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWordContext() *WordContext {
	var p = new(WordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_word
	return p
}

func (*WordContext) IsWordContext() {}

func NewWordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WordContext {
	var p = new(WordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_word

	return p
}

func (s *WordContext) GetParser() antlr.Parser { return s.parser }

func (s *WordContext) Encoded_word() IEncoded_wordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncoded_wordContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncoded_wordContext)
}

func (s *WordContext) Atom() IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *WordContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *WordContext) AT() antlr.TerminalNode {
	return s.GetToken(RFCParserAT, 0)
}

func (s *WordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterWord(s)
	}
}

func (s *WordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitWord(s)
	}
}

func (p *RFCParser) Word() (localctx IWordContext) {
	localctx = NewWordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 28, RFCParserRULE_word)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(344)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 32, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(340)
			p.Encoded_word()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(341)
			p.Atom()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(342)
			p.Quoted_string()
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(343)
			p.Match(RFCParserAT)
		}

	}

	return localctx
}

// IPhraseContext is an interface to support dynamic dispatch.
type IPhraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPhraseContext differentiates from other interfaces.
	IsPhraseContext()
}

type PhraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPhraseContext() *PhraseContext {
	var p = new(PhraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_phrase
	return p
}

func (*PhraseContext) IsPhraseContext() {}

func NewPhraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PhraseContext {
	var p = new(PhraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_phrase

	return p
}

func (s *PhraseContext) GetParser() antlr.Parser { return s.parser }

func (s *PhraseContext) AllWord() []IWordContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWordContext)(nil)).Elem())
	var tst = make([]IWordContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWordContext)
		}
	}

	return tst
}

func (s *PhraseContext) Word(i int) IWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWordContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWordContext)
}

func (s *PhraseContext) Obs_phrase() IObs_phraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_phraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_phraseContext)
}

func (s *PhraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PhraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PhraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterPhrase(s)
	}
}

func (s *PhraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitPhrase(s)
	}
}

func (p *RFCParser) Phrase() (localctx IPhraseContext) {
	localctx = NewPhraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 30, RFCParserRULE_phrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(352)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 34, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(347)
		p.GetErrorHandler().Sync(p)
		_alt = 1
		for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			switch _alt {
			case 1:
				{
					p.SetState(346)
					p.Word()
				}

			default:
				panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
			}

			p.SetState(349)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 33, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(351)
			p.Obs_phrase()
		}

	}

	return localctx
}

// IDate_timeContext is an interface to support dynamic dispatch.
type IDate_timeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDate_timeContext differentiates from other interfaces.
	IsDate_timeContext()
}

type Date_timeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDate_timeContext() *Date_timeContext {
	var p = new(Date_timeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_date_time
	return p
}

func (*Date_timeContext) IsDate_timeContext() {}

func NewDate_timeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Date_timeContext {
	var p = new(Date_timeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_date_time

	return p
}

func (s *Date_timeContext) GetParser() antlr.Parser { return s.parser }

func (s *Date_timeContext) Date() IDateContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDateContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDateContext)
}

func (s *Date_timeContext) Time() ITimeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITimeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITimeContext)
}

func (s *Date_timeContext) Day_of_week() IDay_of_weekContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDay_of_weekContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDay_of_weekContext)
}

func (s *Date_timeContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, 0)
}

func (s *Date_timeContext) Cfws() ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Date_timeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Date_timeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Date_timeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDate_time(s)
	}
}

func (s *Date_timeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDate_time(s)
	}
}

func (p *RFCParser) Date_time() (localctx IDate_timeContext) {
	localctx = NewDate_timeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 32, RFCParserRULE_date_time)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(357)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 35, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(354)
			p.Day_of_week()
		}
		{
			p.SetState(355)
			p.Match(RFCParserCOMMA)
		}

	}
	{
		p.SetState(359)
		p.Date()
	}
	{
		p.SetState(360)
		p.Time()
	}
	p.SetState(362)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(361)
			p.Cfws()
		}

	}

	return localctx
}

// IDay_of_weekContext is an interface to support dynamic dispatch.
type IDay_of_weekContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDay_of_weekContext differentiates from other interfaces.
	IsDay_of_weekContext()
}

type Day_of_weekContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDay_of_weekContext() *Day_of_weekContext {
	var p = new(Day_of_weekContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_day_of_week
	return p
}

func (*Day_of_weekContext) IsDay_of_weekContext() {}

func NewDay_of_weekContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Day_of_weekContext {
	var p = new(Day_of_weekContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_day_of_week

	return p
}

func (s *Day_of_weekContext) GetParser() antlr.Parser { return s.parser }

func (s *Day_of_weekContext) Day_name() IDay_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDay_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDay_nameContext)
}

func (s *Day_of_weekContext) Fws() IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *Day_of_weekContext) Obs_day_of_week() IObs_day_of_weekContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_day_of_weekContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_day_of_weekContext)
}

func (s *Day_of_weekContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Day_of_weekContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Day_of_weekContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDay_of_week(s)
	}
}

func (s *Day_of_weekContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDay_of_week(s)
	}
}

func (p *RFCParser) Day_of_week() (localctx IDay_of_weekContext) {
	localctx = NewDay_of_weekContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 34, RFCParserRULE_day_of_week)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(369)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 38, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(365)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE))) != 0 {
			{
				p.SetState(364)
				p.Fws()
			}

		}
		{
			p.SetState(367)
			p.Day_name()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(368)
			p.Obs_day_of_week()
		}

	}

	return localctx
}

// IDay_nameContext is an interface to support dynamic dispatch.
type IDay_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDay_nameContext differentiates from other interfaces.
	IsDay_nameContext()
}

type Day_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDay_nameContext() *Day_nameContext {
	var p = new(Day_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_day_name
	return p
}

func (*Day_nameContext) IsDay_nameContext() {}

func NewDay_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Day_nameContext {
	var p = new(Day_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_day_name

	return p
}

func (s *Day_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Day_nameContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *Day_nameContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *Day_nameContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *Day_nameContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *Day_nameContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *Day_nameContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *Day_nameContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *Day_nameContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *Day_nameContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *Day_nameContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *Day_nameContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *Day_nameContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *Day_nameContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *Day_nameContext) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *Day_nameContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *Day_nameContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *Day_nameContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *Day_nameContext) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *Day_nameContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *Day_nameContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *Day_nameContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *Day_nameContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *Day_nameContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *Day_nameContext) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *Day_nameContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *Day_nameContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *Day_nameContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *Day_nameContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *Day_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Day_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Day_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDay_name(s)
	}
}

func (s *Day_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDay_name(s)
	}
}

func (p *RFCParser) Day_name() (localctx IDay_nameContext) {
	localctx = NewDay_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 36, RFCParserRULE_day_name)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(392)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 39, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(371)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_M || _la == RFCParserM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(372)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_O || _la == RFCParserO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(373)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_N || _la == RFCParserN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(374)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(375)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_U || _la == RFCParserU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(376)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_E || _la == RFCParserE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(377)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_W || _la == RFCParserW) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(378)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_E || _la == RFCParserE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(379)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_D || _la == RFCParserD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(380)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(381)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_H || _la == RFCParserH) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(382)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_U || _la == RFCParserU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(383)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_F || _la == RFCParserF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(384)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_R || _la == RFCParserR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(385)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_I || _la == RFCParserI) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(386)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_S || _la == RFCParserS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(387)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_A || _la == RFCParserA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(388)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(389)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_S || _la == RFCParserS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(390)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_U || _la == RFCParserU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(391)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_N || _la == RFCParserN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IDateContext is an interface to support dynamic dispatch.
type IDateContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDateContext differentiates from other interfaces.
	IsDateContext()
}

type DateContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDateContext() *DateContext {
	var p = new(DateContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_date
	return p
}

func (*DateContext) IsDateContext() {}

func NewDateContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DateContext {
	var p = new(DateContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_date

	return p
}

func (s *DateContext) GetParser() antlr.Parser { return s.parser }

func (s *DateContext) Day() IDayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDayContext)
}

func (s *DateContext) Month() IMonthContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMonthContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMonthContext)
}

func (s *DateContext) Year() IYearContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IYearContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IYearContext)
}

func (s *DateContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DateContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DateContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDate(s)
	}
}

func (s *DateContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDate(s)
	}
}

func (p *RFCParser) Date() (localctx IDateContext) {
	localctx = NewDateContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 38, RFCParserRULE_date)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(394)
		p.Day()
	}
	{
		p.SetState(395)
		p.Month()
	}
	{
		p.SetState(396)
		p.Year()
	}

	return localctx
}

// IDayContext is an interface to support dynamic dispatch.
type IDayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDayContext differentiates from other interfaces.
	IsDayContext()
}

type DayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDayContext() *DayContext {
	var p = new(DayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_day
	return p
}

func (*DayContext) IsDayContext() {}

func NewDayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DayContext {
	var p = new(DayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_day

	return p
}

func (s *DayContext) GetParser() antlr.Parser { return s.parser }

func (s *DayContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *DayContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *DayContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *DayContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *DayContext) Obs_day() IObs_dayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_dayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_dayContext)
}

func (s *DayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDay(s)
	}
}

func (s *DayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDay(s)
	}
}

func (p *RFCParser) Day() (localctx IDayContext) {
	localctx = NewDayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 40, RFCParserRULE_day)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(408)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 42, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(399)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE))) != 0 {
			{
				p.SetState(398)
				p.Fws()
			}

		}

		{
			p.SetState(401)
			p.Digit()
		}
		p.SetState(403)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0 {
			{
				p.SetState(402)
				p.Digit()
			}

		}

		{
			p.SetState(405)
			p.Fws()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(407)
			p.Obs_day()
		}

	}

	return localctx
}

// IMonthContext is an interface to support dynamic dispatch.
type IMonthContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMonthContext differentiates from other interfaces.
	IsMonthContext()
}

type MonthContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMonthContext() *MonthContext {
	var p = new(MonthContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_month
	return p
}

func (*MonthContext) IsMonthContext() {}

func NewMonthContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MonthContext {
	var p = new(MonthContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_month

	return p
}

func (s *MonthContext) GetParser() antlr.Parser { return s.parser }

func (s *MonthContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_J, 0)
}

func (s *MonthContext) J() antlr.TerminalNode {
	return s.GetToken(RFCParserJ, 0)
}

func (s *MonthContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *MonthContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *MonthContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *MonthContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *MonthContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *MonthContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *MonthContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *MonthContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *MonthContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *MonthContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *MonthContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *MonthContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *MonthContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *MonthContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *MonthContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *MonthContext) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *MonthContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *MonthContext) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *MonthContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *MonthContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *MonthContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *MonthContext) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *MonthContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *MonthContext) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *MonthContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *MonthContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *MonthContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *MonthContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *MonthContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *MonthContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *MonthContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *MonthContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *MonthContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *MonthContext) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *MonthContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *MonthContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *MonthContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MonthContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MonthContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterMonth(s)
	}
}

func (s *MonthContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitMonth(s)
	}
}

func (p *RFCParser) Month() (localctx IMonthContext) {
	localctx = NewMonthContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 42, RFCParserRULE_month)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(446)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 43, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(410)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_J || _la == RFCParserJ) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(411)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_A || _la == RFCParserA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(412)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_N || _la == RFCParserN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		{
			p.SetState(413)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_F || _la == RFCParserF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(414)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_E || _la == RFCParserE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(415)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_B || _la == RFCParserB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		{
			p.SetState(416)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_M || _la == RFCParserM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(417)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_A || _la == RFCParserA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(418)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_R || _la == RFCParserR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		{
			p.SetState(419)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_A || _la == RFCParserA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(420)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_P || _la == RFCParserP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(421)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_R || _la == RFCParserR) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		{
			p.SetState(422)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_M || _la == RFCParserM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(423)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_A || _la == RFCParserA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(424)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_Y || _la == RFCParserY) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		{
			p.SetState(425)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_J || _la == RFCParserJ) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(426)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_U || _la == RFCParserU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(427)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_N || _la == RFCParserN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 7:
		{
			p.SetState(428)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_J || _la == RFCParserJ) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(429)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_U || _la == RFCParserU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(430)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_L || _la == RFCParserL) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		{
			p.SetState(431)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_A || _la == RFCParserA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(432)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_U || _la == RFCParserU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(433)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_G || _la == RFCParserG) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		{
			p.SetState(434)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_S || _la == RFCParserS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(435)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_E || _la == RFCParserE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(436)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_P || _la == RFCParserP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		{
			p.SetState(437)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_O || _la == RFCParserO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(438)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_C || _la == RFCParserC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(439)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		{
			p.SetState(440)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_N || _la == RFCParserN) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(441)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_O || _la == RFCParserO) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(442)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_V || _la == RFCParserV) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 12:
		{
			p.SetState(443)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_D || _la == RFCParserD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(444)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_E || _la == RFCParserE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(445)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_C || _la == RFCParserC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IYearContext is an interface to support dynamic dispatch.
type IYearContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsYearContext differentiates from other interfaces.
	IsYearContext()
}

type YearContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyYearContext() *YearContext {
	var p = new(YearContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_year
	return p
}

func (*YearContext) IsYearContext() {}

func NewYearContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *YearContext {
	var p = new(YearContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_year

	return p
}

func (s *YearContext) GetParser() antlr.Parser { return s.parser }

func (s *YearContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *YearContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *YearContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *YearContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *YearContext) Obs_year() IObs_yearContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_yearContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_yearContext)
}

func (s *YearContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *YearContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *YearContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterYear(s)
	}
}

func (s *YearContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitYear(s)
	}
}

func (p *RFCParser) Year() (localctx IYearContext) {
	localctx = NewYearContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 44, RFCParserRULE_year)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(460)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 45, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(448)
			p.Fws()
		}

		{
			p.SetState(449)
			p.Digit()
		}
		{
			p.SetState(450)
			p.Digit()
		}
		{
			p.SetState(451)
			p.Digit()
		}
		p.SetState(453)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0) {
			{
				p.SetState(452)
				p.Digit()
			}

			p.SetState(455)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

		{
			p.SetState(457)
			p.Fws()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(459)
			p.Obs_year()
		}

	}

	return localctx
}

// ITimeContext is an interface to support dynamic dispatch.
type ITimeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTimeContext differentiates from other interfaces.
	IsTimeContext()
}

type TimeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTimeContext() *TimeContext {
	var p = new(TimeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_time
	return p
}

func (*TimeContext) IsTimeContext() {}

func NewTimeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TimeContext {
	var p = new(TimeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_time

	return p
}

func (s *TimeContext) GetParser() antlr.Parser { return s.parser }

func (s *TimeContext) Time_of_day() ITime_of_dayContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITime_of_dayContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITime_of_dayContext)
}

func (s *TimeContext) Zone() IZoneContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IZoneContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IZoneContext)
}

func (s *TimeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TimeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TimeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterTime(s)
	}
}

func (s *TimeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitTime(s)
	}
}

func (p *RFCParser) Time() (localctx ITimeContext) {
	localctx = NewTimeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 46, RFCParserRULE_time)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(462)
		p.Time_of_day()
	}
	p.SetState(464)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 46, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(463)
			p.Zone()
		}

	}

	return localctx
}

// ITime_of_dayContext is an interface to support dynamic dispatch.
type ITime_of_dayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTime_of_dayContext differentiates from other interfaces.
	IsTime_of_dayContext()
}

type Time_of_dayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTime_of_dayContext() *Time_of_dayContext {
	var p = new(Time_of_dayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_time_of_day
	return p
}

func (*Time_of_dayContext) IsTime_of_dayContext() {}

func NewTime_of_dayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Time_of_dayContext {
	var p = new(Time_of_dayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_time_of_day

	return p
}

func (s *Time_of_dayContext) GetParser() antlr.Parser { return s.parser }

func (s *Time_of_dayContext) Hour() IHourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHourContext)
}

func (s *Time_of_dayContext) AllCOLON() []antlr.TerminalNode {
	return s.GetTokens(RFCParserCOLON)
}

func (s *Time_of_dayContext) COLON(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, i)
}

func (s *Time_of_dayContext) Minute() IMinuteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMinuteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMinuteContext)
}

func (s *Time_of_dayContext) Second() ISecondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISecondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISecondContext)
}

func (s *Time_of_dayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Time_of_dayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Time_of_dayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterTime_of_day(s)
	}
}

func (s *Time_of_dayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitTime_of_day(s)
	}
}

func (p *RFCParser) Time_of_day() (localctx ITime_of_dayContext) {
	localctx = NewTime_of_dayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 48, RFCParserRULE_time_of_day)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(466)
		p.Hour()
	}
	{
		p.SetState(467)
		p.Match(RFCParserCOLON)
	}
	{
		p.SetState(468)
		p.Minute()
	}
	p.SetState(471)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFCParserCOLON {
		{
			p.SetState(469)
			p.Match(RFCParserCOLON)
		}
		{
			p.SetState(470)
			p.Second()
		}

	}

	return localctx
}

// IHourContext is an interface to support dynamic dispatch.
type IHourContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHourContext differentiates from other interfaces.
	IsHourContext()
}

type HourContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHourContext() *HourContext {
	var p = new(HourContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_hour
	return p
}

func (*HourContext) IsHourContext() {}

func NewHourContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HourContext {
	var p = new(HourContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_hour

	return p
}

func (s *HourContext) GetParser() antlr.Parser { return s.parser }

func (s *HourContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *HourContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *HourContext) Obs_hour() IObs_hourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_hourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_hourContext)
}

func (s *HourContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HourContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HourContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterHour(s)
	}
}

func (s *HourContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitHour(s)
	}
}

func (p *RFCParser) Hour() (localctx IHourContext) {
	localctx = NewHourContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 50, RFCParserRULE_hour)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(478)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 49, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(473)
			p.Digit()
		}
		p.SetState(475)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0 {
			{
				p.SetState(474)
				p.Digit()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(477)
			p.Obs_hour()
		}

	}

	return localctx
}

// IMinuteContext is an interface to support dynamic dispatch.
type IMinuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMinuteContext differentiates from other interfaces.
	IsMinuteContext()
}

type MinuteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMinuteContext() *MinuteContext {
	var p = new(MinuteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_minute
	return p
}

func (*MinuteContext) IsMinuteContext() {}

func NewMinuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MinuteContext {
	var p = new(MinuteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_minute

	return p
}

func (s *MinuteContext) GetParser() antlr.Parser { return s.parser }

func (s *MinuteContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *MinuteContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *MinuteContext) Obs_minute() IObs_minuteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_minuteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_minuteContext)
}

func (s *MinuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MinuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MinuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterMinute(s)
	}
}

func (s *MinuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitMinute(s)
	}
}

func (p *RFCParser) Minute() (localctx IMinuteContext) {
	localctx = NewMinuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 52, RFCParserRULE_minute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(485)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 51, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(480)
			p.Digit()
		}
		p.SetState(482)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0 {
			{
				p.SetState(481)
				p.Digit()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(484)
			p.Obs_minute()
		}

	}

	return localctx
}

// ISecondContext is an interface to support dynamic dispatch.
type ISecondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSecondContext differentiates from other interfaces.
	IsSecondContext()
}

type SecondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySecondContext() *SecondContext {
	var p = new(SecondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_second
	return p
}

func (*SecondContext) IsSecondContext() {}

func NewSecondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SecondContext {
	var p = new(SecondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_second

	return p
}

func (s *SecondContext) GetParser() antlr.Parser { return s.parser }

func (s *SecondContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *SecondContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *SecondContext) Obs_second() IObs_secondContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_secondContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_secondContext)
}

func (s *SecondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SecondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SecondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterSecond(s)
	}
}

func (s *SecondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitSecond(s)
	}
}

func (p *RFCParser) Second() (localctx ISecondContext) {
	localctx = NewSecondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 54, RFCParserRULE_second)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(492)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 53, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(487)
			p.Digit()
		}
		p.SetState(489)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0 {
			{
				p.SetState(488)
				p.Digit()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(491)
			p.Obs_second()
		}

	}

	return localctx
}

// IZone_hourContext is an interface to support dynamic dispatch.
type IZone_hourContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsZone_hourContext differentiates from other interfaces.
	IsZone_hourContext()
}

type Zone_hourContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyZone_hourContext() *Zone_hourContext {
	var p = new(Zone_hourContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_zone_hour
	return p
}

func (*Zone_hourContext) IsZone_hourContext() {}

func NewZone_hourContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Zone_hourContext {
	var p = new(Zone_hourContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_zone_hour

	return p
}

func (s *Zone_hourContext) GetParser() antlr.Parser { return s.parser }

func (s *Zone_hourContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *Zone_hourContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Zone_hourContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Zone_hourContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Zone_hourContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterZone_hour(s)
	}
}

func (s *Zone_hourContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitZone_hour(s)
	}
}

func (p *RFCParser) Zone_hour() (localctx IZone_hourContext) {
	localctx = NewZone_hourContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 56, RFCParserRULE_zone_hour)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(494)
		p.Digit()
	}
	{
		p.SetState(495)
		p.Digit()
	}

	return localctx
}

// IZone_minuteContext is an interface to support dynamic dispatch.
type IZone_minuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsZone_minuteContext differentiates from other interfaces.
	IsZone_minuteContext()
}

type Zone_minuteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyZone_minuteContext() *Zone_minuteContext {
	var p = new(Zone_minuteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_zone_minute
	return p
}

func (*Zone_minuteContext) IsZone_minuteContext() {}

func NewZone_minuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Zone_minuteContext {
	var p = new(Zone_minuteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_zone_minute

	return p
}

func (s *Zone_minuteContext) GetParser() antlr.Parser { return s.parser }

func (s *Zone_minuteContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *Zone_minuteContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Zone_minuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Zone_minuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Zone_minuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterZone_minute(s)
	}
}

func (s *Zone_minuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitZone_minute(s)
	}
}

func (p *RFCParser) Zone_minute() (localctx IZone_minuteContext) {
	localctx = NewZone_minuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 58, RFCParserRULE_zone_minute)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(497)
		p.Digit()
	}
	{
		p.SetState(498)
		p.Digit()
	}

	return localctx
}

// IZoneContext is an interface to support dynamic dispatch.
type IZoneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// GetSign returns the sign token.
	GetSign() antlr.Token

	// SetSign sets the sign token.
	SetSign(antlr.Token)

	// IsZoneContext differentiates from other interfaces.
	IsZoneContext()
}

type ZoneContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
	sign   antlr.Token
}

func NewEmptyZoneContext() *ZoneContext {
	var p = new(ZoneContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_zone
	return p
}

func (*ZoneContext) IsZoneContext() {}

func NewZoneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *ZoneContext {
	var p = new(ZoneContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_zone

	return p
}

func (s *ZoneContext) GetParser() antlr.Parser { return s.parser }

func (s *ZoneContext) GetSign() antlr.Token { return s.sign }

func (s *ZoneContext) SetSign(v antlr.Token) { s.sign = v }

func (s *ZoneContext) Fws() IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *ZoneContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RFCParserPLUS, 0)
}

func (s *ZoneContext) DASH() antlr.TerminalNode {
	return s.GetToken(RFCParserDASH, 0)
}

func (s *ZoneContext) Zone_hour() IZone_hourContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IZone_hourContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IZone_hourContext)
}

func (s *ZoneContext) Zone_minute() IZone_minuteContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IZone_minuteContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IZone_minuteContext)
}

func (s *ZoneContext) Obs_zone() IObs_zoneContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_zoneContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_zoneContext)
}

func (s *ZoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *ZoneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *ZoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterZone(s)
	}
}

func (s *ZoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitZone(s)
	}
}

func (p *RFCParser) Zone() (localctx IZoneContext) {
	localctx = NewZoneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 60, RFCParserRULE_zone)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(506)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserTAB, RFCParserCR, RFCParserSPACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(500)
			p.Fws()
		}
		{
			p.SetState(501)

			var _lt = p.GetTokenStream().LT(1)

			localctx.(*ZoneContext).sign = _lt

			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserPLUS || _la == RFCParserDASH) {
				var _ri = p.GetErrorHandler().RecoverInline(p)

				localctx.(*ZoneContext).sign = _ri
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

		{
			p.SetState(502)
			p.Zone_hour()
		}
		{
			p.SetState(503)
			p.Zone_minute()
		}

	case RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(505)
			p.Obs_zone()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAddressContext is an interface to support dynamic dispatch.
type IAddressContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddressContext differentiates from other interfaces.
	IsAddressContext()
}

type AddressContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddressContext() *AddressContext {
	var p = new(AddressContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_address
	return p
}

func (*AddressContext) IsAddressContext() {}

func NewAddressContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AddressContext {
	var p = new(AddressContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_address

	return p
}

func (s *AddressContext) GetParser() antlr.Parser { return s.parser }

func (s *AddressContext) Mailbox() IMailboxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMailboxContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMailboxContext)
}

func (s *AddressContext) Group() IGroupContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroupContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroupContext)
}

func (s *AddressContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AddressContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AddressContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterAddress(s)
	}
}

func (s *AddressContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitAddress(s)
	}
}

func (p *RFCParser) Address() (localctx IAddressContext) {
	localctx = NewAddressContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 62, RFCParserRULE_address)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(510)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 55, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(508)
			p.Mailbox()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(509)
			p.Group()
		}

	}

	return localctx
}

// IMailboxContext is an interface to support dynamic dispatch.
type IMailboxContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMailboxContext differentiates from other interfaces.
	IsMailboxContext()
}

type MailboxContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMailboxContext() *MailboxContext {
	var p = new(MailboxContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_mailbox
	return p
}

func (*MailboxContext) IsMailboxContext() {}

func NewMailboxContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *MailboxContext {
	var p = new(MailboxContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_mailbox

	return p
}

func (s *MailboxContext) GetParser() antlr.Parser { return s.parser }

func (s *MailboxContext) Addr_spec() IAddr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddr_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddr_specContext)
}

func (s *MailboxContext) Name_addr() IName_addrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IName_addrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IName_addrContext)
}

func (s *MailboxContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *MailboxContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *MailboxContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterMailbox(s)
	}
}

func (s *MailboxContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitMailbox(s)
	}
}

func (p *RFCParser) Mailbox() (localctx IMailboxContext) {
	localctx = NewMailboxContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 64, RFCParserRULE_mailbox)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(514)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 56, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(512)
			p.Addr_spec()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(513)
			p.Name_addr()
		}

	}

	return localctx
}

// IName_addrContext is an interface to support dynamic dispatch.
type IName_addrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsName_addrContext differentiates from other interfaces.
	IsName_addrContext()
}

type Name_addrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyName_addrContext() *Name_addrContext {
	var p = new(Name_addrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_name_addr
	return p
}

func (*Name_addrContext) IsName_addrContext() {}

func NewName_addrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Name_addrContext {
	var p = new(Name_addrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_name_addr

	return p
}

func (s *Name_addrContext) GetParser() antlr.Parser { return s.parser }

func (s *Name_addrContext) Angle_addr() IAngle_addrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAngle_addrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAngle_addrContext)
}

func (s *Name_addrContext) Cfws() ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Name_addrContext) Addr_spec() IAddr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddr_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddr_specContext)
}

func (s *Name_addrContext) Display_name() IDisplay_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplay_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplay_nameContext)
}

func (s *Name_addrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Name_addrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Name_addrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterName_addr(s)
	}
}

func (s *Name_addrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitName_addr(s)
	}
}

func (p *RFCParser) Name_addr() (localctx IName_addrContext) {
	localctx = NewName_addrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 66, RFCParserRULE_name_addr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(517)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 57, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(516)
			p.Display_name()
		}

	}
	p.SetState(523)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 58, p.GetParserRuleContext()) {
	case 1:
		{
			p.SetState(519)
			p.Angle_addr()
		}

	case 2:
		{
			p.SetState(520)
			p.Cfws()
		}
		{
			p.SetState(521)
			p.Addr_spec()
		}

	}

	return localctx
}

// IAngle_addrContext is an interface to support dynamic dispatch.
type IAngle_addrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAngle_addrContext differentiates from other interfaces.
	IsAngle_addrContext()
}

type Angle_addrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAngle_addrContext() *Angle_addrContext {
	var p = new(Angle_addrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_angle_addr
	return p
}

func (*Angle_addrContext) IsAngle_addrContext() {}

func NewAngle_addrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Angle_addrContext {
	var p = new(Angle_addrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_angle_addr

	return p
}

func (s *Angle_addrContext) GetParser() antlr.Parser { return s.parser }

func (s *Angle_addrContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserLESS_THAN, 0)
}

func (s *Angle_addrContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserGREATER_THAN, 0)
}

func (s *Angle_addrContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Angle_addrContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Angle_addrContext) Addr_spec() IAddr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddr_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddr_specContext)
}

func (s *Angle_addrContext) Obs_angle_addr() IObs_angle_addrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_angle_addrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_angle_addrContext)
}

func (s *Angle_addrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Angle_addrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Angle_addrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterAngle_addr(s)
	}
}

func (s *Angle_addrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitAngle_addr(s)
	}
}

func (p *RFCParser) Angle_addr() (localctx IAngle_addrContext) {
	localctx = NewAngle_addrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 68, RFCParserRULE_angle_addr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(537)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 62, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		p.SetState(526)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
			{
				p.SetState(525)
				p.Cfws()
			}

		}
		{
			p.SetState(528)
			p.Match(RFCParserLESS_THAN)
		}
		p.SetState(530)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserEXCLAMATION)|(1<<RFCParserQUOTE)|(1<<RFCParserHASH)|(1<<RFCParserDOLLAR)|(1<<RFCParserPERCENT)|(1<<RFCParserAMPERSAND)|(1<<RFCParserAPOSTROPHE)|(1<<RFCParserLEFT_PAREN)|(1<<RFCParserASTERISK)|(1<<RFCParserPLUS)|(1<<RFCParserDASH)|(1<<RFCParserSLASH)|(1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(RFCParserEQUALS-33))|(1<<(RFCParserQUESTION-33))|(1<<(RFCParserAT-33))|(1<<(RFCParserCAP_A-33))|(1<<(RFCParserCAP_B-33))|(1<<(RFCParserCAP_C-33))|(1<<(RFCParserCAP_D-33))|(1<<(RFCParserCAP_E-33))|(1<<(RFCParserCAP_F-33))|(1<<(RFCParserCAP_G-33))|(1<<(RFCParserCAP_H-33))|(1<<(RFCParserCAP_I-33))|(1<<(RFCParserCAP_J-33))|(1<<(RFCParserCAP_K-33))|(1<<(RFCParserCAP_L-33))|(1<<(RFCParserCAP_M-33))|(1<<(RFCParserCAP_N-33))|(1<<(RFCParserCAP_O-33))|(1<<(RFCParserCAP_P-33))|(1<<(RFCParserCAP_Q-33))|(1<<(RFCParserCAP_R-33))|(1<<(RFCParserCAP_S-33))|(1<<(RFCParserCAP_T-33))|(1<<(RFCParserCAP_U-33))|(1<<(RFCParserCAP_V-33))|(1<<(RFCParserCAP_W-33))|(1<<(RFCParserCAP_X-33))|(1<<(RFCParserCAP_Y-33))|(1<<(RFCParserCAP_Z-33)))) != 0) || (((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(RFCParserCARAT-66))|(1<<(RFCParserUNDERSCORE-66))|(1<<(RFCParserACCENT-66))|(1<<(RFCParserA-66))|(1<<(RFCParserB-66))|(1<<(RFCParserC-66))|(1<<(RFCParserD-66))|(1<<(RFCParserE-66))|(1<<(RFCParserF-66))|(1<<(RFCParserG-66))|(1<<(RFCParserH-66))|(1<<(RFCParserI-66))|(1<<(RFCParserJ-66))|(1<<(RFCParserK-66))|(1<<(RFCParserL-66))|(1<<(RFCParserM-66))|(1<<(RFCParserN-66))|(1<<(RFCParserO-66))|(1<<(RFCParserP-66))|(1<<(RFCParserQ-66))|(1<<(RFCParserR-66))|(1<<(RFCParserS-66))|(1<<(RFCParserT-66))|(1<<(RFCParserU-66))|(1<<(RFCParserV-66))|(1<<(RFCParserW-66))|(1<<(RFCParserX-66))|(1<<(RFCParserY-66))|(1<<(RFCParserZ-66))|(1<<(RFCParserLEFT_CURLY_BRACE-66))|(1<<(RFCParserPIPE-66))|(1<<(RFCParserRIGHT_CURLY_BRACE-66)))) != 0) || _la == RFCParserTILDE || _la == RFCParserU_REST {
			{
				p.SetState(529)
				p.Addr_spec()
			}

		}
		{
			p.SetState(532)
			p.Match(RFCParserGREATER_THAN)
		}
		p.SetState(534)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 61, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(533)
				p.Cfws()
			}

		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(536)
			p.Obs_angle_addr()
		}

	}

	return localctx
}

// IGroupContext is an interface to support dynamic dispatch.
type IGroupContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroupContext differentiates from other interfaces.
	IsGroupContext()
}

type GroupContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroupContext() *GroupContext {
	var p = new(GroupContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_group
	return p
}

func (*GroupContext) IsGroupContext() {}

func NewGroupContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *GroupContext {
	var p = new(GroupContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_group

	return p
}

func (s *GroupContext) GetParser() antlr.Parser { return s.parser }

func (s *GroupContext) Display_name() IDisplay_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDisplay_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDisplay_nameContext)
}

func (s *GroupContext) COLON() antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, 0)
}

func (s *GroupContext) Group_list() IGroup_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IGroup_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IGroup_listContext)
}

func (s *GroupContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(RFCParserSEMICOLON, 0)
}

func (s *GroupContext) Cfws() ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *GroupContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *GroupContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *GroupContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterGroup(s)
	}
}

func (s *GroupContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitGroup(s)
	}
}

func (p *RFCParser) Group() (localctx IGroupContext) {
	localctx = NewGroupContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 70, RFCParserRULE_group)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(539)
		p.Display_name()
	}
	{
		p.SetState(540)
		p.Match(RFCParserCOLON)
	}
	p.SetState(542)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 63, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(541)
			p.Group_list()
		}

	}
	p.SetState(545)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFCParserSEMICOLON {
		{
			p.SetState(544)
			p.Match(RFCParserSEMICOLON)
		}

	}
	p.SetState(548)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(547)
			p.Cfws()
		}

	}

	return localctx
}

// IDisplay_nameContext is an interface to support dynamic dispatch.
type IDisplay_nameContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDisplay_nameContext differentiates from other interfaces.
	IsDisplay_nameContext()
}

type Display_nameContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDisplay_nameContext() *Display_nameContext {
	var p = new(Display_nameContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_display_name
	return p
}

func (*Display_nameContext) IsDisplay_nameContext() {}

func NewDisplay_nameContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Display_nameContext {
	var p = new(Display_nameContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_display_name

	return p
}

func (s *Display_nameContext) GetParser() antlr.Parser { return s.parser }

func (s *Display_nameContext) Phrase() IPhraseContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPhraseContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPhraseContext)
}

func (s *Display_nameContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Display_nameContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Display_nameContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDisplay_name(s)
	}
}

func (s *Display_nameContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDisplay_name(s)
	}
}

func (p *RFCParser) Display_name() (localctx IDisplay_nameContext) {
	localctx = NewDisplay_nameContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 72, RFCParserRULE_display_name)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(550)
		p.Phrase()
	}

	return localctx
}

// IMailbox_listContext is an interface to support dynamic dispatch.
type IMailbox_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsMailbox_listContext differentiates from other interfaces.
	IsMailbox_listContext()
}

type Mailbox_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyMailbox_listContext() *Mailbox_listContext {
	var p = new(Mailbox_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_mailbox_list
	return p
}

func (*Mailbox_listContext) IsMailbox_listContext() {}

func NewMailbox_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Mailbox_listContext {
	var p = new(Mailbox_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_mailbox_list

	return p
}

func (s *Mailbox_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Mailbox_listContext) AllMailbox() []IMailboxContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMailboxContext)(nil)).Elem())
	var tst = make([]IMailboxContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMailboxContext)
		}
	}

	return tst
}

func (s *Mailbox_listContext) Mailbox(i int) IMailboxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMailboxContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMailboxContext)
}

func (s *Mailbox_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(RFCParserCOMMA)
}

func (s *Mailbox_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, i)
}

func (s *Mailbox_listContext) Obs_mbox_list() IObs_mbox_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_mbox_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_mbox_listContext)
}

func (s *Mailbox_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Mailbox_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Mailbox_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterMailbox_list(s)
	}
}

func (s *Mailbox_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitMailbox_list(s)
	}
}

func (p *RFCParser) Mailbox_list() (localctx IMailbox_listContext) {
	localctx = NewMailbox_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 74, RFCParserRULE_mailbox_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.SetState(561)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 67, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(552)
			p.Mailbox()
		}
		p.SetState(557)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())

		for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
			if _alt == 1 {
				{
					p.SetState(553)
					p.Match(RFCParserCOMMA)
				}
				{
					p.SetState(554)
					p.Mailbox()
				}

			}
			p.SetState(559)
			p.GetErrorHandler().Sync(p)
			_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 66, p.GetParserRuleContext())
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(560)
			p.Obs_mbox_list()
		}

	}

	return localctx
}

// IAddress_listContext is an interface to support dynamic dispatch.
type IAddress_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddress_listContext differentiates from other interfaces.
	IsAddress_listContext()
}

type Address_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddress_listContext() *Address_listContext {
	var p = new(Address_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_address_list
	return p
}

func (*Address_listContext) IsAddress_listContext() {}

func NewAddress_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Address_listContext {
	var p = new(Address_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_address_list

	return p
}

func (s *Address_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Address_listContext) AllAddress() []IAddressContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddressContext)(nil)).Elem())
	var tst = make([]IAddressContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddressContext)
		}
	}

	return tst
}

func (s *Address_listContext) Address(i int) IAddressContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddressContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddressContext)
}

func (s *Address_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(RFCParserCOMMA)
}

func (s *Address_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, i)
}

func (s *Address_listContext) Obs_addr_list() IObs_addr_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_addr_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_addr_listContext)
}

func (s *Address_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Address_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Address_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterAddress_list(s)
	}
}

func (s *Address_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitAddress_list(s)
	}
}

func (p *RFCParser) Address_list() (localctx IAddress_listContext) {
	localctx = NewAddress_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 76, RFCParserRULE_address_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(572)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 69, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(563)
			p.Address()
		}
		p.SetState(568)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		for _la == RFCParserCOMMA {
			{
				p.SetState(564)
				p.Match(RFCParserCOMMA)
			}
			{
				p.SetState(565)
				p.Address()
			}

			p.SetState(570)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(571)
			p.Obs_addr_list()
		}

	}

	return localctx
}

// IGroup_listContext is an interface to support dynamic dispatch.
type IGroup_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsGroup_listContext differentiates from other interfaces.
	IsGroup_listContext()
}

type Group_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyGroup_listContext() *Group_listContext {
	var p = new(Group_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_group_list
	return p
}

func (*Group_listContext) IsGroup_listContext() {}

func NewGroup_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Group_listContext {
	var p = new(Group_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_group_list

	return p
}

func (s *Group_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Group_listContext) Mailbox_list() IMailbox_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMailbox_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IMailbox_listContext)
}

func (s *Group_listContext) Cfws() ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Group_listContext) Obs_group_list() IObs_group_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_group_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_group_listContext)
}

func (s *Group_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Group_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Group_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterGroup_list(s)
	}
}

func (s *Group_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitGroup_list(s)
	}
}

func (p *RFCParser) Group_list() (localctx IGroup_listContext) {
	localctx = NewGroup_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 78, RFCParserRULE_group_list)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(577)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 70, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(574)
			p.Mailbox_list()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(575)
			p.Cfws()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(576)
			p.Obs_group_list()
		}

	}

	return localctx
}

// IAddr_specContext is an interface to support dynamic dispatch.
type IAddr_specContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAddr_specContext differentiates from other interfaces.
	IsAddr_specContext()
}

type Addr_specContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAddr_specContext() *Addr_specContext {
	var p = new(Addr_specContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_addr_spec
	return p
}

func (*Addr_specContext) IsAddr_specContext() {}

func NewAddr_specContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Addr_specContext {
	var p = new(Addr_specContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_addr_spec

	return p
}

func (s *Addr_specContext) GetParser() antlr.Parser { return s.parser }

func (s *Addr_specContext) Local_part() ILocal_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILocal_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILocal_partContext)
}

func (s *Addr_specContext) AT() antlr.TerminalNode {
	return s.GetToken(RFCParserAT, 0)
}

func (s *Addr_specContext) Domain() IDomainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDomainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDomainContext)
}

func (s *Addr_specContext) COLON() antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, 0)
}

func (s *Addr_specContext) Port() IPortContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IPortContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IPortContext)
}

func (s *Addr_specContext) Cfws() ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Addr_specContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Addr_specContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Addr_specContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterAddr_spec(s)
	}
}

func (s *Addr_specContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitAddr_spec(s)
	}
}

func (p *RFCParser) Addr_spec() (localctx IAddr_specContext) {
	localctx = NewAddr_specContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 80, RFCParserRULE_addr_spec)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(579)
		p.Local_part()
	}
	p.SetState(582)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFCParserAT {
		{
			p.SetState(580)
			p.Match(RFCParserAT)
		}
		{
			p.SetState(581)
			p.Domain()
		}

	}
	p.SetState(589)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if _la == RFCParserCOLON {
		{
			p.SetState(584)
			p.Match(RFCParserCOLON)
		}
		{
			p.SetState(585)
			p.Port()
		}
		p.SetState(587)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 72, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(586)
				p.Cfws()
			}

		}

	}

	return localctx
}

// IPortContext is an interface to support dynamic dispatch.
type IPortContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsPortContext differentiates from other interfaces.
	IsPortContext()
}

type PortContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyPortContext() *PortContext {
	var p = new(PortContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_port
	return p
}

func (*PortContext) IsPortContext() {}

func NewPortContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *PortContext {
	var p = new(PortContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_port

	return p
}

func (s *PortContext) GetParser() antlr.Parser { return s.parser }

func (s *PortContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *PortContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *PortContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *PortContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *PortContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterPort(s)
	}
}

func (s *PortContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitPort(s)
	}
}

func (p *RFCParser) Port() (localctx IPortContext) {
	localctx = NewPortContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 82, RFCParserRULE_port)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(592)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0) {
		{
			p.SetState(591)
			p.Digit()
		}

		p.SetState(594)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ILocal_partContext is an interface to support dynamic dispatch.
type ILocal_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLocal_partContext differentiates from other interfaces.
	IsLocal_partContext()
}

type Local_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLocal_partContext() *Local_partContext {
	var p = new(Local_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_local_part
	return p
}

func (*Local_partContext) IsLocal_partContext() {}

func NewLocal_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Local_partContext {
	var p = new(Local_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_local_part

	return p
}

func (s *Local_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Local_partContext) Dot_atom() IDot_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDot_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDot_atomContext)
}

func (s *Local_partContext) Quoted_string() IQuoted_stringContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_stringContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_stringContext)
}

func (s *Local_partContext) Obs_local_part() IObs_local_partContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_local_partContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_local_partContext)
}

func (s *Local_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Local_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Local_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterLocal_part(s)
	}
}

func (s *Local_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitLocal_part(s)
	}
}

func (p *RFCParser) Local_part() (localctx ILocal_partContext) {
	localctx = NewLocal_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 84, RFCParserRULE_local_part)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(599)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 75, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(596)
			p.Dot_atom()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(597)
			p.Quoted_string()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(598)
			p.Obs_local_part()
		}

	}

	return localctx
}

// IDomainContext is an interface to support dynamic dispatch.
type IDomainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDomainContext differentiates from other interfaces.
	IsDomainContext()
}

type DomainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDomainContext() *DomainContext {
	var p = new(DomainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_domain
	return p
}

func (*DomainContext) IsDomainContext() {}

func NewDomainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DomainContext {
	var p = new(DomainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_domain

	return p
}

func (s *DomainContext) GetParser() antlr.Parser { return s.parser }

func (s *DomainContext) Dot_atom() IDot_atomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDot_atomContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDot_atomContext)
}

func (s *DomainContext) Domain_literal() IDomain_literalContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDomain_literalContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDomain_literalContext)
}

func (s *DomainContext) Obs_domain() IObs_domainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_domainContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_domainContext)
}

func (s *DomainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DomainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DomainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDomain(s)
	}
}

func (s *DomainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDomain(s)
	}
}

func (p *RFCParser) Domain() (localctx IDomainContext) {
	localctx = NewDomainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 86, RFCParserRULE_domain)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(604)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 76, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(601)
			p.Dot_atom()
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(602)
			p.Domain_literal()
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(603)
			p.Obs_domain()
		}

	}

	return localctx
}

// IDomain_literalContext is an interface to support dynamic dispatch.
type IDomain_literalContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDomain_literalContext differentiates from other interfaces.
	IsDomain_literalContext()
}

type Domain_literalContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDomain_literalContext() *Domain_literalContext {
	var p = new(Domain_literalContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_domain_literal
	return p
}

func (*Domain_literalContext) IsDomain_literalContext() {}

func NewDomain_literalContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Domain_literalContext {
	var p = new(Domain_literalContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_domain_literal

	return p
}

func (s *Domain_literalContext) GetParser() antlr.Parser { return s.parser }

func (s *Domain_literalContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_BRACE, 0)
}

func (s *Domain_literalContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_BRACE, 0)
}

func (s *Domain_literalContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Domain_literalContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Domain_literalContext) AllDtext() []IDtextContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDtextContext)(nil)).Elem())
	var tst = make([]IDtextContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDtextContext)
		}
	}

	return tst
}

func (s *Domain_literalContext) Dtext(i int) IDtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDtextContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDtextContext)
}

func (s *Domain_literalContext) AllFws() []IFwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IFwsContext)(nil)).Elem())
	var tst = make([]IFwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IFwsContext)
		}
	}

	return tst
}

func (s *Domain_literalContext) Fws(i int) IFwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IFwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IFwsContext)
}

func (s *Domain_literalContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Domain_literalContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Domain_literalContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDomain_literal(s)
	}
}

func (s *Domain_literalContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDomain_literal(s)
	}
}

func (p *RFCParser) Domain_literal() (localctx IDomain_literalContext) {
	localctx = NewDomain_literalContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 88, RFCParserRULE_domain_literal)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(607)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(606)
			p.Cfws()
		}

	}
	{
		p.SetState(609)
		p.Match(RFCParserLEFT_BRACE)
	}
	p.SetState(616)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(611)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE))) != 0 {
				{
					p.SetState(610)
					p.Fws()
				}

			}
			{
				p.SetState(613)
				p.Dtext()
			}

		}
		p.SetState(618)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 79, p.GetParserRuleContext())
	}
	p.SetState(620)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE))) != 0 {
		{
			p.SetState(619)
			p.Fws()
		}

	}
	{
		p.SetState(622)
		p.Match(RFCParserRIGHT_BRACE)
	}
	p.SetState(624)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 81, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(623)
			p.Cfws()
		}

	}

	return localctx
}

// IDtextContext is an interface to support dynamic dispatch.
type IDtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDtextContext differentiates from other interfaces.
	IsDtextContext()
}

type DtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDtextContext() *DtextContext {
	var p = new(DtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_dtext
	return p
}

func (*DtextContext) IsDtextContext() {}

func NewDtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DtextContext {
	var p = new(DtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_dtext

	return p
}

func (s *DtextContext) GetParser() antlr.Parser { return s.parser }

func (s *DtextContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(RFCParserEXCLAMATION, 0)
}

func (s *DtextContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(RFCParserQUOTE, 0)
}

func (s *DtextContext) HASH() antlr.TerminalNode {
	return s.GetToken(RFCParserHASH, 0)
}

func (s *DtextContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(RFCParserDOLLAR, 0)
}

func (s *DtextContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserPERCENT, 0)
}

func (s *DtextContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(RFCParserAMPERSAND, 0)
}

func (s *DtextContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(RFCParserAPOSTROPHE, 0)
}

func (s *DtextContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_PAREN, 0)
}

func (s *DtextContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_PAREN, 0)
}

func (s *DtextContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(RFCParserASTERISK, 0)
}

func (s *DtextContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RFCParserPLUS, 0)
}

func (s *DtextContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, 0)
}

func (s *DtextContext) DASH() antlr.TerminalNode {
	return s.GetToken(RFCParserDASH, 0)
}

func (s *DtextContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, 0)
}

func (s *DtextContext) SLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserSLASH, 0)
}

func (s *DtextContext) ZERO() antlr.TerminalNode {
	return s.GetToken(RFCParserZERO, 0)
}

func (s *DtextContext) ONE() antlr.TerminalNode {
	return s.GetToken(RFCParserONE, 0)
}

func (s *DtextContext) TWO() antlr.TerminalNode {
	return s.GetToken(RFCParserTWO, 0)
}

func (s *DtextContext) THREE() antlr.TerminalNode {
	return s.GetToken(RFCParserTHREE, 0)
}

func (s *DtextContext) FOUR() antlr.TerminalNode {
	return s.GetToken(RFCParserFOUR, 0)
}

func (s *DtextContext) FIVE() antlr.TerminalNode {
	return s.GetToken(RFCParserFIVE, 0)
}

func (s *DtextContext) SIX() antlr.TerminalNode {
	return s.GetToken(RFCParserSIX, 0)
}

func (s *DtextContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(RFCParserSEVEN, 0)
}

func (s *DtextContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(RFCParserEIGHT, 0)
}

func (s *DtextContext) NINE() antlr.TerminalNode {
	return s.GetToken(RFCParserNINE, 0)
}

func (s *DtextContext) COLON() antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, 0)
}

func (s *DtextContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(RFCParserSEMICOLON, 0)
}

func (s *DtextContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserLESS_THAN, 0)
}

func (s *DtextContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(RFCParserEQUALS, 0)
}

func (s *DtextContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserGREATER_THAN, 0)
}

func (s *DtextContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(RFCParserQUESTION, 0)
}

func (s *DtextContext) AT() antlr.TerminalNode {
	return s.GetToken(RFCParserAT, 0)
}

func (s *DtextContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *DtextContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *DtextContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *DtextContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *DtextContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *DtextContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *DtextContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *DtextContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *DtextContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *DtextContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_J, 0)
}

func (s *DtextContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_K, 0)
}

func (s *DtextContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *DtextContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *DtextContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *DtextContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *DtextContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *DtextContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Q, 0)
}

func (s *DtextContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *DtextContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *DtextContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *DtextContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *DtextContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *DtextContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *DtextContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_X, 0)
}

func (s *DtextContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *DtextContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Z, 0)
}

func (s *DtextContext) CARAT() antlr.TerminalNode {
	return s.GetToken(RFCParserCARAT, 0)
}

func (s *DtextContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(RFCParserUNDERSCORE, 0)
}

func (s *DtextContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserACCENT, 0)
}

func (s *DtextContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *DtextContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *DtextContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *DtextContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *DtextContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *DtextContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *DtextContext) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *DtextContext) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *DtextContext) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *DtextContext) J() antlr.TerminalNode {
	return s.GetToken(RFCParserJ, 0)
}

func (s *DtextContext) K() antlr.TerminalNode {
	return s.GetToken(RFCParserK, 0)
}

func (s *DtextContext) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *DtextContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *DtextContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *DtextContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *DtextContext) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *DtextContext) Q() antlr.TerminalNode {
	return s.GetToken(RFCParserQ, 0)
}

func (s *DtextContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *DtextContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *DtextContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *DtextContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *DtextContext) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *DtextContext) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *DtextContext) X() antlr.TerminalNode {
	return s.GetToken(RFCParserX, 0)
}

func (s *DtextContext) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *DtextContext) Z() antlr.TerminalNode {
	return s.GetToken(RFCParserZ, 0)
}

func (s *DtextContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_CURLY_BRACE, 0)
}

func (s *DtextContext) PIPE() antlr.TerminalNode {
	return s.GetToken(RFCParserPIPE, 0)
}

func (s *DtextContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_CURLY_BRACE, 0)
}

func (s *DtextContext) TILDE() antlr.TerminalNode {
	return s.GetToken(RFCParserTILDE, 0)
}

func (s *DtextContext) Obs_dtext() IObs_dtextContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_dtextContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_dtextContext)
}

func (s *DtextContext) U_REST() antlr.TerminalNode {
	return s.GetToken(RFCParserU_REST, 0)
}

func (s *DtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDtext(s)
	}
}

func (s *DtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDtext(s)
	}
}

func (p *RFCParser) Dtext() (localctx IDtextContext) {
	localctx = NewDtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 90, RFCParserRULE_dtext)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(630)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserEXCLAMATION, RFCParserQUOTE, RFCParserHASH, RFCParserDOLLAR, RFCParserPERCENT, RFCParserAMPERSAND, RFCParserAPOSTROPHE, RFCParserLEFT_PAREN, RFCParserRIGHT_PAREN, RFCParserASTERISK, RFCParserPLUS, RFCParserCOMMA, RFCParserDASH, RFCParserPERIOD, RFCParserSLASH, RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE, RFCParserCOLON, RFCParserSEMICOLON, RFCParserLESS_THAN, RFCParserEQUALS, RFCParserGREATER_THAN, RFCParserQUESTION, RFCParserAT, RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(626)
			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserEXCLAMATION)|(1<<RFCParserQUOTE)|(1<<RFCParserHASH)|(1<<RFCParserDOLLAR)|(1<<RFCParserPERCENT)|(1<<RFCParserAMPERSAND)|(1<<RFCParserAPOSTROPHE)|(1<<RFCParserLEFT_PAREN)|(1<<RFCParserRIGHT_PAREN)|(1<<RFCParserASTERISK)|(1<<RFCParserPLUS)|(1<<RFCParserCOMMA)|(1<<RFCParserDASH)|(1<<RFCParserPERIOD)|(1<<RFCParserSLASH)|(1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE)|(1<<RFCParserCOLON)|(1<<RFCParserSEMICOLON))) != 0) || (((_la-32)&-(0x1f+1)) == 0 && ((1<<uint((_la-32)))&((1<<(RFCParserLESS_THAN-32))|(1<<(RFCParserEQUALS-32))|(1<<(RFCParserGREATER_THAN-32))|(1<<(RFCParserQUESTION-32))|(1<<(RFCParserAT-32))|(1<<(RFCParserCAP_A-32))|(1<<(RFCParserCAP_B-32))|(1<<(RFCParserCAP_C-32))|(1<<(RFCParserCAP_D-32))|(1<<(RFCParserCAP_E-32))|(1<<(RFCParserCAP_F-32))|(1<<(RFCParserCAP_G-32))|(1<<(RFCParserCAP_H-32))|(1<<(RFCParserCAP_I-32))|(1<<(RFCParserCAP_J-32))|(1<<(RFCParserCAP_K-32))|(1<<(RFCParserCAP_L-32))|(1<<(RFCParserCAP_M-32))|(1<<(RFCParserCAP_N-32))|(1<<(RFCParserCAP_O-32))|(1<<(RFCParserCAP_P-32))|(1<<(RFCParserCAP_Q-32))|(1<<(RFCParserCAP_R-32))|(1<<(RFCParserCAP_S-32))|(1<<(RFCParserCAP_T-32))|(1<<(RFCParserCAP_U-32))|(1<<(RFCParserCAP_V-32))|(1<<(RFCParserCAP_W-32))|(1<<(RFCParserCAP_X-32))|(1<<(RFCParserCAP_Y-32))|(1<<(RFCParserCAP_Z-32)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserCARAT, RFCParserUNDERSCORE, RFCParserACCENT, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ, RFCParserLEFT_CURLY_BRACE, RFCParserPIPE, RFCParserRIGHT_CURLY_BRACE, RFCParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(627)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(RFCParserCARAT-66))|(1<<(RFCParserUNDERSCORE-66))|(1<<(RFCParserACCENT-66))|(1<<(RFCParserA-66))|(1<<(RFCParserB-66))|(1<<(RFCParserC-66))|(1<<(RFCParserD-66))|(1<<(RFCParserE-66))|(1<<(RFCParserF-66))|(1<<(RFCParserG-66))|(1<<(RFCParserH-66))|(1<<(RFCParserI-66))|(1<<(RFCParserJ-66))|(1<<(RFCParserK-66))|(1<<(RFCParserL-66))|(1<<(RFCParserM-66))|(1<<(RFCParserN-66))|(1<<(RFCParserO-66))|(1<<(RFCParserP-66))|(1<<(RFCParserQ-66))|(1<<(RFCParserR-66))|(1<<(RFCParserS-66))|(1<<(RFCParserT-66))|(1<<(RFCParserU-66))|(1<<(RFCParserV-66))|(1<<(RFCParserW-66))|(1<<(RFCParserX-66))|(1<<(RFCParserY-66))|(1<<(RFCParserZ-66))|(1<<(RFCParserLEFT_CURLY_BRACE-66))|(1<<(RFCParserPIPE-66))|(1<<(RFCParserRIGHT_CURLY_BRACE-66)))) != 0) || _la == RFCParserTILDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserBACKSLASH, RFCParserU_0001, RFCParserU_0002, RFCParserU_0003, RFCParserU_0004, RFCParserU_0005, RFCParserU_0006, RFCParserU_0007, RFCParserU_0008, RFCParserU_000B, RFCParserU_000C, RFCParserU_000E, RFCParserU_000F, RFCParserU_0010, RFCParserU_0011, RFCParserU_0012, RFCParserU_0013, RFCParserU_0014, RFCParserU_0015, RFCParserU_0016, RFCParserU_0017, RFCParserU_0018, RFCParserU_0019, RFCParserU_001A, RFCParserU_001B, RFCParserU_001C, RFCParserU_001D, RFCParserU_001E, RFCParserU_001F, RFCParserU_007F:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(628)
			p.Obs_dtext()
		}

	case RFCParserU_REST:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(629)
			p.Match(RFCParserU_REST)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObs_no_ws_ctlContext is an interface to support dynamic dispatch.
type IObs_no_ws_ctlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_no_ws_ctlContext differentiates from other interfaces.
	IsObs_no_ws_ctlContext()
}

type Obs_no_ws_ctlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_no_ws_ctlContext() *Obs_no_ws_ctlContext {
	var p = new(Obs_no_ws_ctlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_no_ws_ctl
	return p
}

func (*Obs_no_ws_ctlContext) IsObs_no_ws_ctlContext() {}

func NewObs_no_ws_ctlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_no_ws_ctlContext {
	var p = new(Obs_no_ws_ctlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_no_ws_ctl

	return p
}

func (s *Obs_no_ws_ctlContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_no_ws_ctlContext) U_0001() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0001, 0)
}

func (s *Obs_no_ws_ctlContext) U_0002() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0002, 0)
}

func (s *Obs_no_ws_ctlContext) U_0003() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0003, 0)
}

func (s *Obs_no_ws_ctlContext) U_0004() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0004, 0)
}

func (s *Obs_no_ws_ctlContext) U_0005() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0005, 0)
}

func (s *Obs_no_ws_ctlContext) U_0006() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0006, 0)
}

func (s *Obs_no_ws_ctlContext) U_0007() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0007, 0)
}

func (s *Obs_no_ws_ctlContext) U_0008() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0008, 0)
}

func (s *Obs_no_ws_ctlContext) U_000B() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000B, 0)
}

func (s *Obs_no_ws_ctlContext) U_000C() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000C, 0)
}

func (s *Obs_no_ws_ctlContext) U_000E() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000E, 0)
}

func (s *Obs_no_ws_ctlContext) U_000F() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000F, 0)
}

func (s *Obs_no_ws_ctlContext) U_0010() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0010, 0)
}

func (s *Obs_no_ws_ctlContext) U_0011() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0011, 0)
}

func (s *Obs_no_ws_ctlContext) U_0012() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0012, 0)
}

func (s *Obs_no_ws_ctlContext) U_0013() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0013, 0)
}

func (s *Obs_no_ws_ctlContext) U_0014() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0014, 0)
}

func (s *Obs_no_ws_ctlContext) U_0015() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0015, 0)
}

func (s *Obs_no_ws_ctlContext) U_0016() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0016, 0)
}

func (s *Obs_no_ws_ctlContext) U_0017() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0017, 0)
}

func (s *Obs_no_ws_ctlContext) U_0018() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0018, 0)
}

func (s *Obs_no_ws_ctlContext) U_0019() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0019, 0)
}

func (s *Obs_no_ws_ctlContext) U_001A() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001A, 0)
}

func (s *Obs_no_ws_ctlContext) U_001B() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001B, 0)
}

func (s *Obs_no_ws_ctlContext) U_001C() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001C, 0)
}

func (s *Obs_no_ws_ctlContext) U_001D() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001D, 0)
}

func (s *Obs_no_ws_ctlContext) U_001E() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001E, 0)
}

func (s *Obs_no_ws_ctlContext) U_001F() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001F, 0)
}

func (s *Obs_no_ws_ctlContext) U_007F() antlr.TerminalNode {
	return s.GetToken(RFCParserU_007F, 0)
}

func (s *Obs_no_ws_ctlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_no_ws_ctlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_no_ws_ctlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_no_ws_ctl(s)
	}
}

func (s *Obs_no_ws_ctlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_no_ws_ctl(s)
	}
}

func (p *RFCParser) Obs_no_ws_ctl() (localctx IObs_no_ws_ctlContext) {
	localctx = NewObs_no_ws_ctlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 92, RFCParserRULE_obs_no_ws_ctl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(637)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserU_0001, RFCParserU_0002, RFCParserU_0003, RFCParserU_0004, RFCParserU_0005, RFCParserU_0006, RFCParserU_0007, RFCParserU_0008:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(632)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-100)&-(0x1f+1)) == 0 && ((1<<uint((_la-100)))&((1<<(RFCParserU_0001-100))|(1<<(RFCParserU_0002-100))|(1<<(RFCParserU_0003-100))|(1<<(RFCParserU_0004-100))|(1<<(RFCParserU_0005-100))|(1<<(RFCParserU_0006-100))|(1<<(RFCParserU_0007-100))|(1<<(RFCParserU_0008-100)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserU_000B:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(633)
			p.Match(RFCParserU_000B)
		}

	case RFCParserU_000C:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(634)
			p.Match(RFCParserU_000C)
		}

	case RFCParserU_000E, RFCParserU_000F, RFCParserU_0010, RFCParserU_0011, RFCParserU_0012, RFCParserU_0013, RFCParserU_0014, RFCParserU_0015, RFCParserU_0016, RFCParserU_0017, RFCParserU_0018, RFCParserU_0019, RFCParserU_001A, RFCParserU_001B, RFCParserU_001C, RFCParserU_001D, RFCParserU_001E, RFCParserU_001F:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(635)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-110)&-(0x1f+1)) == 0 && ((1<<uint((_la-110)))&((1<<(RFCParserU_000E-110))|(1<<(RFCParserU_000F-110))|(1<<(RFCParserU_0010-110))|(1<<(RFCParserU_0011-110))|(1<<(RFCParserU_0012-110))|(1<<(RFCParserU_0013-110))|(1<<(RFCParserU_0014-110))|(1<<(RFCParserU_0015-110))|(1<<(RFCParserU_0016-110))|(1<<(RFCParserU_0017-110))|(1<<(RFCParserU_0018-110))|(1<<(RFCParserU_0019-110))|(1<<(RFCParserU_001A-110))|(1<<(RFCParserU_001B-110))|(1<<(RFCParserU_001C-110))|(1<<(RFCParserU_001D-110))|(1<<(RFCParserU_001E-110))|(1<<(RFCParserU_001F-110)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserU_007F:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(636)
			p.Match(RFCParserU_007F)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObs_ctextContext is an interface to support dynamic dispatch.
type IObs_ctextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_ctextContext differentiates from other interfaces.
	IsObs_ctextContext()
}

type Obs_ctextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_ctextContext() *Obs_ctextContext {
	var p = new(Obs_ctextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_ctext
	return p
}

func (*Obs_ctextContext) IsObs_ctextContext() {}

func NewObs_ctextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_ctextContext {
	var p = new(Obs_ctextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_ctext

	return p
}

func (s *Obs_ctextContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_ctextContext) Obs_no_ws_ctl() IObs_no_ws_ctlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_no_ws_ctlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_no_ws_ctlContext)
}

func (s *Obs_ctextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_ctextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_ctextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_ctext(s)
	}
}

func (s *Obs_ctextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_ctext(s)
	}
}

func (p *RFCParser) Obs_ctext() (localctx IObs_ctextContext) {
	localctx = NewObs_ctextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 94, RFCParserRULE_obs_ctext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(639)
		p.Obs_no_ws_ctl()
	}

	return localctx
}

// IObs_qtextContext is an interface to support dynamic dispatch.
type IObs_qtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_qtextContext differentiates from other interfaces.
	IsObs_qtextContext()
}

type Obs_qtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_qtextContext() *Obs_qtextContext {
	var p = new(Obs_qtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_qtext
	return p
}

func (*Obs_qtextContext) IsObs_qtextContext() {}

func NewObs_qtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_qtextContext {
	var p = new(Obs_qtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_qtext

	return p
}

func (s *Obs_qtextContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_qtextContext) Obs_no_ws_ctl() IObs_no_ws_ctlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_no_ws_ctlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_no_ws_ctlContext)
}

func (s *Obs_qtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_qtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_qtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_qtext(s)
	}
}

func (s *Obs_qtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_qtext(s)
	}
}

func (p *RFCParser) Obs_qtext() (localctx IObs_qtextContext) {
	localctx = NewObs_qtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 96, RFCParserRULE_obs_qtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(641)
		p.Obs_no_ws_ctl()
	}

	return localctx
}

// IObs_qpContext is an interface to support dynamic dispatch.
type IObs_qpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_qpContext differentiates from other interfaces.
	IsObs_qpContext()
}

type Obs_qpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_qpContext() *Obs_qpContext {
	var p = new(Obs_qpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_qp
	return p
}

func (*Obs_qpContext) IsObs_qpContext() {}

func NewObs_qpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_qpContext {
	var p = new(Obs_qpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_qp

	return p
}

func (s *Obs_qpContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_qpContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserBACKSLASH, 0)
}

func (s *Obs_qpContext) U_0000() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0000, 0)
}

func (s *Obs_qpContext) Obs_no_ws_ctl() IObs_no_ws_ctlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_no_ws_ctlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_no_ws_ctlContext)
}

func (s *Obs_qpContext) Lf() ILfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILfContext)
}

func (s *Obs_qpContext) Cr() ICrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrContext)
}

func (s *Obs_qpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_qpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_qpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_qp(s)
	}
}

func (s *Obs_qpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_qp(s)
	}
}

func (p *RFCParser) Obs_qp() (localctx IObs_qpContext) {
	localctx = NewObs_qpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 98, RFCParserRULE_obs_qp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(643)
		p.Match(RFCParserBACKSLASH)
	}
	p.SetState(648)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserU_0000:
		{
			p.SetState(644)
			p.Match(RFCParserU_0000)
		}

	case RFCParserU_0001, RFCParserU_0002, RFCParserU_0003, RFCParserU_0004, RFCParserU_0005, RFCParserU_0006, RFCParserU_0007, RFCParserU_0008, RFCParserU_000B, RFCParserU_000C, RFCParserU_000E, RFCParserU_000F, RFCParserU_0010, RFCParserU_0011, RFCParserU_0012, RFCParserU_0013, RFCParserU_0014, RFCParserU_0015, RFCParserU_0016, RFCParserU_0017, RFCParserU_0018, RFCParserU_0019, RFCParserU_001A, RFCParserU_001B, RFCParserU_001C, RFCParserU_001D, RFCParserU_001E, RFCParserU_001F, RFCParserU_007F:
		{
			p.SetState(645)
			p.Obs_no_ws_ctl()
		}

	case RFCParserLF:
		{
			p.SetState(646)
			p.Lf()
		}

	case RFCParserCR:
		{
			p.SetState(647)
			p.Cr()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IObs_phraseContext is an interface to support dynamic dispatch.
type IObs_phraseContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_phraseContext differentiates from other interfaces.
	IsObs_phraseContext()
}

type Obs_phraseContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_phraseContext() *Obs_phraseContext {
	var p = new(Obs_phraseContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_phrase
	return p
}

func (*Obs_phraseContext) IsObs_phraseContext() {}

func NewObs_phraseContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_phraseContext {
	var p = new(Obs_phraseContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_phrase

	return p
}

func (s *Obs_phraseContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_phraseContext) AllWord() []IWordContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWordContext)(nil)).Elem())
	var tst = make([]IWordContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWordContext)
		}
	}

	return tst
}

func (s *Obs_phraseContext) Word(i int) IWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWordContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWordContext)
}

func (s *Obs_phraseContext) AllPERIOD() []antlr.TerminalNode {
	return s.GetTokens(RFCParserPERIOD)
}

func (s *Obs_phraseContext) PERIOD(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, i)
}

func (s *Obs_phraseContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_phraseContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_phraseContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_phraseContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_phraseContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_phrase(s)
	}
}

func (s *Obs_phraseContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_phrase(s)
	}
}

func (p *RFCParser) Obs_phrase() (localctx IObs_phraseContext) {
	localctx = NewObs_phraseContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 100, RFCParserRULE_obs_phrase)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(650)
		p.Word()
	}
	p.SetState(656)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(654)
			p.GetErrorHandler().Sync(p)
			switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 85, p.GetParserRuleContext()) {
			case 1:
				{
					p.SetState(651)
					p.Word()
				}

			case 2:
				{
					p.SetState(652)
					p.Match(RFCParserPERIOD)
				}

			case 3:
				{
					p.SetState(653)
					p.Cfws()
				}

			}

		}
		p.SetState(658)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 86, p.GetParserRuleContext())
	}

	return localctx
}

// IObs_fwsContext is an interface to support dynamic dispatch.
type IObs_fwsContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_fwsContext differentiates from other interfaces.
	IsObs_fwsContext()
}

type Obs_fwsContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_fwsContext() *Obs_fwsContext {
	var p = new(Obs_fwsContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_fws
	return p
}

func (*Obs_fwsContext) IsObs_fwsContext() {}

func NewObs_fwsContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_fwsContext {
	var p = new(Obs_fwsContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_fws

	return p
}

func (s *Obs_fwsContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_fwsContext) AllWsp() []IWspContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWspContext)(nil)).Elem())
	var tst = make([]IWspContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWspContext)
		}
	}

	return tst
}

func (s *Obs_fwsContext) Wsp(i int) IWspContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWspContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *Obs_fwsContext) AllCrlf() []ICrlfContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICrlfContext)(nil)).Elem())
	var tst = make([]ICrlfContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICrlfContext)
		}
	}

	return tst
}

func (s *Obs_fwsContext) Crlf(i int) ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *Obs_fwsContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_fwsContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_fwsContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_fws(s)
	}
}

func (s *Obs_fwsContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_fws(s)
	}
}

func (p *RFCParser) Obs_fws() (localctx IObs_fwsContext) {
	localctx = NewObs_fwsContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 102, RFCParserRULE_obs_fws)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(663)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(660)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if _la == RFCParserCR {
				{
					p.SetState(659)
					p.Crlf()
				}

			}
			{
				p.SetState(662)
				p.Wsp()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(665)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 88, p.GetParserRuleContext())
	}

	return localctx
}

// IObs_day_of_weekContext is an interface to support dynamic dispatch.
type IObs_day_of_weekContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_day_of_weekContext differentiates from other interfaces.
	IsObs_day_of_weekContext()
}

type Obs_day_of_weekContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_day_of_weekContext() *Obs_day_of_weekContext {
	var p = new(Obs_day_of_weekContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_day_of_week
	return p
}

func (*Obs_day_of_weekContext) IsObs_day_of_weekContext() {}

func NewObs_day_of_weekContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_day_of_weekContext {
	var p = new(Obs_day_of_weekContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_day_of_week

	return p
}

func (s *Obs_day_of_weekContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_day_of_weekContext) Day_name() IDay_nameContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDay_nameContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDay_nameContext)
}

func (s *Obs_day_of_weekContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_day_of_weekContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_day_of_weekContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_day_of_weekContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_day_of_weekContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_day_of_week(s)
	}
}

func (s *Obs_day_of_weekContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_day_of_week(s)
	}
}

func (p *RFCParser) Obs_day_of_week() (localctx IObs_day_of_weekContext) {
	localctx = NewObs_day_of_weekContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 104, RFCParserRULE_obs_day_of_week)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(668)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(667)
			p.Cfws()
		}

	}
	{
		p.SetState(670)
		p.Day_name()
	}
	p.SetState(672)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(671)
			p.Cfws()
		}

	}

	return localctx
}

// IObs_dayContext is an interface to support dynamic dispatch.
type IObs_dayContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_dayContext differentiates from other interfaces.
	IsObs_dayContext()
}

type Obs_dayContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_dayContext() *Obs_dayContext {
	var p = new(Obs_dayContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_day
	return p
}

func (*Obs_dayContext) IsObs_dayContext() {}

func NewObs_dayContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_dayContext {
	var p = new(Obs_dayContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_day

	return p
}

func (s *Obs_dayContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_dayContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *Obs_dayContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Obs_dayContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_dayContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_dayContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_dayContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_dayContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_day(s)
	}
}

func (s *Obs_dayContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_day(s)
	}
}

func (p *RFCParser) Obs_day() (localctx IObs_dayContext) {
	localctx = NewObs_dayContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 106, RFCParserRULE_obs_day)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(675)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(674)
			p.Cfws()
		}

	}

	{
		p.SetState(677)
		p.Digit()
	}
	p.SetState(679)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0 {
		{
			p.SetState(678)
			p.Digit()
		}

	}

	p.SetState(682)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(681)
			p.Cfws()
		}

	}

	return localctx
}

// IObs_yearContext is an interface to support dynamic dispatch.
type IObs_yearContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_yearContext differentiates from other interfaces.
	IsObs_yearContext()
}

type Obs_yearContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_yearContext() *Obs_yearContext {
	var p = new(Obs_yearContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_year
	return p
}

func (*Obs_yearContext) IsObs_yearContext() {}

func NewObs_yearContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_yearContext {
	var p = new(Obs_yearContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_year

	return p
}

func (s *Obs_yearContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_yearContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *Obs_yearContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Obs_yearContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_yearContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_yearContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_yearContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_yearContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_year(s)
	}
}

func (s *Obs_yearContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_year(s)
	}
}

func (p *RFCParser) Obs_year() (localctx IObs_yearContext) {
	localctx = NewObs_yearContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 108, RFCParserRULE_obs_year)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(685)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(684)
			p.Cfws()
		}

	}

	{
		p.SetState(687)
		p.Digit()
	}
	p.SetState(689)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			{
				p.SetState(688)
				p.Digit()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(691)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 95, p.GetParserRuleContext())
	}

	p.SetState(694)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 96, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(693)
			p.Cfws()
		}

	}

	return localctx
}

// IObs_hourContext is an interface to support dynamic dispatch.
type IObs_hourContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_hourContext differentiates from other interfaces.
	IsObs_hourContext()
}

type Obs_hourContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_hourContext() *Obs_hourContext {
	var p = new(Obs_hourContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_hour
	return p
}

func (*Obs_hourContext) IsObs_hourContext() {}

func NewObs_hourContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_hourContext {
	var p = new(Obs_hourContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_hour

	return p
}

func (s *Obs_hourContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_hourContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *Obs_hourContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Obs_hourContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_hourContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_hourContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_hourContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_hourContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_hour(s)
	}
}

func (s *Obs_hourContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_hour(s)
	}
}

func (p *RFCParser) Obs_hour() (localctx IObs_hourContext) {
	localctx = NewObs_hourContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 110, RFCParserRULE_obs_hour)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(697)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(696)
			p.Cfws()
		}

	}

	{
		p.SetState(699)
		p.Digit()
	}
	p.SetState(701)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0 {
		{
			p.SetState(700)
			p.Digit()
		}

	}

	p.SetState(704)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(703)
			p.Cfws()
		}

	}

	return localctx
}

// IObs_minuteContext is an interface to support dynamic dispatch.
type IObs_minuteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_minuteContext differentiates from other interfaces.
	IsObs_minuteContext()
}

type Obs_minuteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_minuteContext() *Obs_minuteContext {
	var p = new(Obs_minuteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_minute
	return p
}

func (*Obs_minuteContext) IsObs_minuteContext() {}

func NewObs_minuteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_minuteContext {
	var p = new(Obs_minuteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_minute

	return p
}

func (s *Obs_minuteContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_minuteContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *Obs_minuteContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Obs_minuteContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_minuteContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_minuteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_minuteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_minuteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_minute(s)
	}
}

func (s *Obs_minuteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_minute(s)
	}
}

func (p *RFCParser) Obs_minute() (localctx IObs_minuteContext) {
	localctx = NewObs_minuteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 112, RFCParserRULE_obs_minute)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(707)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(706)
			p.Cfws()
		}

	}

	{
		p.SetState(709)
		p.Digit()
	}
	p.SetState(711)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0 {
		{
			p.SetState(710)
			p.Digit()
		}

	}

	p.SetState(714)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 102, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(713)
			p.Cfws()
		}

	}

	return localctx
}

// IObs_secondContext is an interface to support dynamic dispatch.
type IObs_secondContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_secondContext differentiates from other interfaces.
	IsObs_secondContext()
}

type Obs_secondContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_secondContext() *Obs_secondContext {
	var p = new(Obs_secondContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_second
	return p
}

func (*Obs_secondContext) IsObs_secondContext() {}

func NewObs_secondContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_secondContext {
	var p = new(Obs_secondContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_second

	return p
}

func (s *Obs_secondContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_secondContext) AllDigit() []IDigitContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDigitContext)(nil)).Elem())
	var tst = make([]IDigitContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDigitContext)
		}
	}

	return tst
}

func (s *Obs_secondContext) Digit(i int) IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *Obs_secondContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_secondContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_secondContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_secondContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_secondContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_second(s)
	}
}

func (s *Obs_secondContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_second(s)
	}
}

func (p *RFCParser) Obs_second() (localctx IObs_secondContext) {
	localctx = NewObs_secondContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 114, RFCParserRULE_obs_second)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(717)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(716)
			p.Cfws()
		}

	}

	{
		p.SetState(719)
		p.Digit()
	}
	p.SetState(721)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0 {
		{
			p.SetState(720)
			p.Digit()
		}

	}

	p.SetState(724)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 105, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(723)
			p.Cfws()
		}

	}

	return localctx
}

// IObs_zoneContext is an interface to support dynamic dispatch.
type IObs_zoneContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_zoneContext differentiates from other interfaces.
	IsObs_zoneContext()
}

type Obs_zoneContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_zoneContext() *Obs_zoneContext {
	var p = new(Obs_zoneContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_zone
	return p
}

func (*Obs_zoneContext) IsObs_zoneContext() {}

func NewObs_zoneContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_zoneContext {
	var p = new(Obs_zoneContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_zone

	return p
}

func (s *Obs_zoneContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_zoneContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *Obs_zoneContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *Obs_zoneContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *Obs_zoneContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *Obs_zoneContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *Obs_zoneContext) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *Obs_zoneContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *Obs_zoneContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *Obs_zoneContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *Obs_zoneContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *Obs_zoneContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *Obs_zoneContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *Obs_zoneContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *Obs_zoneContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *Obs_zoneContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *Obs_zoneContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *Obs_zoneContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *Obs_zoneContext) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *Obs_zoneContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *Obs_zoneContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *Obs_zoneContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *Obs_zoneContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *Obs_zoneContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *Obs_zoneContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_K, 0)
}

func (s *Obs_zoneContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *Obs_zoneContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *Obs_zoneContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *Obs_zoneContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Q, 0)
}

func (s *Obs_zoneContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *Obs_zoneContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *Obs_zoneContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *Obs_zoneContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_X, 0)
}

func (s *Obs_zoneContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *Obs_zoneContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Z, 0)
}

func (s *Obs_zoneContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *Obs_zoneContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *Obs_zoneContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *Obs_zoneContext) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *Obs_zoneContext) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *Obs_zoneContext) K() antlr.TerminalNode {
	return s.GetToken(RFCParserK, 0)
}

func (s *Obs_zoneContext) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *Obs_zoneContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *Obs_zoneContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *Obs_zoneContext) Q() antlr.TerminalNode {
	return s.GetToken(RFCParserQ, 0)
}

func (s *Obs_zoneContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *Obs_zoneContext) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *Obs_zoneContext) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *Obs_zoneContext) X() antlr.TerminalNode {
	return s.GetToken(RFCParserX, 0)
}

func (s *Obs_zoneContext) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *Obs_zoneContext) Z() antlr.TerminalNode {
	return s.GetToken(RFCParserZ, 0)
}

func (s *Obs_zoneContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_zoneContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_zoneContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_zone(s)
	}
}

func (s *Obs_zoneContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_zone(s)
	}
}

func (p *RFCParser) Obs_zone() (localctx IObs_zoneContext) {
	localctx = NewObs_zoneContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 116, RFCParserRULE_obs_zone)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(759)
	p.GetErrorHandler().Sync(p)
	switch p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 106, p.GetParserRuleContext()) {
	case 1:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(726)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_U || _la == RFCParserU) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(727)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 2:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(728)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_G || _la == RFCParserG) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(729)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_M || _la == RFCParserM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(730)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 3:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(731)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_E || _la == RFCParserE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(732)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_S || _la == RFCParserS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(733)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 4:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(734)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_E || _la == RFCParserE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(735)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_D || _la == RFCParserD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(736)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 5:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(737)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_C || _la == RFCParserC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(738)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_S || _la == RFCParserS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(739)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 6:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(740)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_C || _la == RFCParserC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(741)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_D || _la == RFCParserD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(742)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 7:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(743)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_M || _la == RFCParserM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(744)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_S || _la == RFCParserS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(745)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 8:
		p.EnterOuterAlt(localctx, 8)
		{
			p.SetState(746)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_M || _la == RFCParserM) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(747)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_D || _la == RFCParserD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(748)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 9:
		p.EnterOuterAlt(localctx, 9)
		{
			p.SetState(749)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_P || _la == RFCParserP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(750)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_S || _la == RFCParserS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(751)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 10:
		p.EnterOuterAlt(localctx, 10)
		{
			p.SetState(752)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_P || _la == RFCParserP) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(753)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_D || _la == RFCParserD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}
		{
			p.SetState(754)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_T || _la == RFCParserT) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 11:
		p.EnterOuterAlt(localctx, 11)
		{
			p.SetState(755)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(RFCParserCAP_A-37))|(1<<(RFCParserCAP_B-37))|(1<<(RFCParserCAP_C-37))|(1<<(RFCParserCAP_D-37))|(1<<(RFCParserCAP_E-37))|(1<<(RFCParserCAP_F-37))|(1<<(RFCParserCAP_G-37))|(1<<(RFCParserCAP_H-37))|(1<<(RFCParserCAP_I-37)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 12:
		p.EnterOuterAlt(localctx, 12)
		{
			p.SetState(756)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-47)&-(0x1f+1)) == 0 && ((1<<uint((_la-47)))&((1<<(RFCParserCAP_K-47))|(1<<(RFCParserCAP_L-47))|(1<<(RFCParserCAP_M-47))|(1<<(RFCParserCAP_N-47))|(1<<(RFCParserCAP_O-47))|(1<<(RFCParserCAP_P-47))|(1<<(RFCParserCAP_Q-47))|(1<<(RFCParserCAP_R-47))|(1<<(RFCParserCAP_S-47))|(1<<(RFCParserCAP_T-47))|(1<<(RFCParserCAP_U-47))|(1<<(RFCParserCAP_V-47))|(1<<(RFCParserCAP_W-47))|(1<<(RFCParserCAP_X-47))|(1<<(RFCParserCAP_Y-47))|(1<<(RFCParserCAP_Z-47)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 13:
		p.EnterOuterAlt(localctx, 13)
		{
			p.SetState(757)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(RFCParserA-69))|(1<<(RFCParserB-69))|(1<<(RFCParserC-69))|(1<<(RFCParserD-69))|(1<<(RFCParserE-69))|(1<<(RFCParserF-69))|(1<<(RFCParserG-69))|(1<<(RFCParserH-69))|(1<<(RFCParserI-69)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case 14:
		p.EnterOuterAlt(localctx, 14)
		{
			p.SetState(758)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-79)&-(0x1f+1)) == 0 && ((1<<uint((_la-79)))&((1<<(RFCParserK-79))|(1<<(RFCParserL-79))|(1<<(RFCParserM-79))|(1<<(RFCParserN-79))|(1<<(RFCParserO-79))|(1<<(RFCParserP-79))|(1<<(RFCParserQ-79))|(1<<(RFCParserR-79))|(1<<(RFCParserS-79))|(1<<(RFCParserT-79))|(1<<(RFCParserU-79))|(1<<(RFCParserV-79))|(1<<(RFCParserW-79))|(1<<(RFCParserX-79))|(1<<(RFCParserY-79))|(1<<(RFCParserZ-79)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	}

	return localctx
}

// IObs_angle_addrContext is an interface to support dynamic dispatch.
type IObs_angle_addrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_angle_addrContext differentiates from other interfaces.
	IsObs_angle_addrContext()
}

type Obs_angle_addrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_angle_addrContext() *Obs_angle_addrContext {
	var p = new(Obs_angle_addrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_angle_addr
	return p
}

func (*Obs_angle_addrContext) IsObs_angle_addrContext() {}

func NewObs_angle_addrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_angle_addrContext {
	var p = new(Obs_angle_addrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_angle_addr

	return p
}

func (s *Obs_angle_addrContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_angle_addrContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserLESS_THAN, 0)
}

func (s *Obs_angle_addrContext) Obs_route() IObs_routeContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_routeContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_routeContext)
}

func (s *Obs_angle_addrContext) Addr_spec() IAddr_specContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddr_specContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IAddr_specContext)
}

func (s *Obs_angle_addrContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserGREATER_THAN, 0)
}

func (s *Obs_angle_addrContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_angle_addrContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_angle_addrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_angle_addrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_angle_addrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_angle_addr(s)
	}
}

func (s *Obs_angle_addrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_angle_addr(s)
	}
}

func (p *RFCParser) Obs_angle_addr() (localctx IObs_angle_addrContext) {
	localctx = NewObs_angle_addrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 118, RFCParserRULE_obs_angle_addr)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(762)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(761)
			p.Cfws()
		}

	}
	{
		p.SetState(764)
		p.Match(RFCParserLESS_THAN)
	}
	{
		p.SetState(765)
		p.Obs_route()
	}
	{
		p.SetState(766)
		p.Addr_spec()
	}
	{
		p.SetState(767)
		p.Match(RFCParserGREATER_THAN)
	}
	p.SetState(769)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 108, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(768)
			p.Cfws()
		}

	}

	return localctx
}

// IObs_routeContext is an interface to support dynamic dispatch.
type IObs_routeContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_routeContext differentiates from other interfaces.
	IsObs_routeContext()
}

type Obs_routeContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_routeContext() *Obs_routeContext {
	var p = new(Obs_routeContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_route
	return p
}

func (*Obs_routeContext) IsObs_routeContext() {}

func NewObs_routeContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_routeContext {
	var p = new(Obs_routeContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_route

	return p
}

func (s *Obs_routeContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_routeContext) Obs_domain_list() IObs_domain_listContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_domain_listContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_domain_listContext)
}

func (s *Obs_routeContext) COLON() antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, 0)
}

func (s *Obs_routeContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_routeContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_routeContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_route(s)
	}
}

func (s *Obs_routeContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_route(s)
	}
}

func (p *RFCParser) Obs_route() (localctx IObs_routeContext) {
	localctx = NewObs_routeContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 120, RFCParserRULE_obs_route)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(771)
		p.Obs_domain_list()
	}
	{
		p.SetState(772)
		p.Match(RFCParserCOLON)
	}

	return localctx
}

// IObs_domain_listContext is an interface to support dynamic dispatch.
type IObs_domain_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_domain_listContext differentiates from other interfaces.
	IsObs_domain_listContext()
}

type Obs_domain_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_domain_listContext() *Obs_domain_listContext {
	var p = new(Obs_domain_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_domain_list
	return p
}

func (*Obs_domain_listContext) IsObs_domain_listContext() {}

func NewObs_domain_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_domain_listContext {
	var p = new(Obs_domain_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_domain_list

	return p
}

func (s *Obs_domain_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_domain_listContext) AllAT() []antlr.TerminalNode {
	return s.GetTokens(RFCParserAT)
}

func (s *Obs_domain_listContext) AT(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserAT, i)
}

func (s *Obs_domain_listContext) AllDomain() []IDomainContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IDomainContext)(nil)).Elem())
	var tst = make([]IDomainContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IDomainContext)
		}
	}

	return tst
}

func (s *Obs_domain_listContext) Domain(i int) IDomainContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDomainContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IDomainContext)
}

func (s *Obs_domain_listContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_domain_listContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_domain_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(RFCParserCOMMA)
}

func (s *Obs_domain_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, i)
}

func (s *Obs_domain_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_domain_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_domain_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_domain_list(s)
	}
}

func (s *Obs_domain_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_domain_list(s)
	}
}

func (p *RFCParser) Obs_domain_list() (localctx IObs_domain_listContext) {
	localctx = NewObs_domain_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 122, RFCParserRULE_obs_domain_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(778)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN)|(1<<RFCParserCOMMA))) != 0 {
		p.SetState(776)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case RFCParserTAB, RFCParserCR, RFCParserSPACE, RFCParserLEFT_PAREN:
			{
				p.SetState(774)
				p.Cfws()
			}

		case RFCParserCOMMA:
			{
				p.SetState(775)
				p.Match(RFCParserCOMMA)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(780)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}
	{
		p.SetState(781)
		p.Match(RFCParserAT)
	}
	{
		p.SetState(782)
		p.Domain()
	}
	p.SetState(793)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFCParserCOMMA {
		{
			p.SetState(783)
			p.Match(RFCParserCOMMA)
		}
		p.SetState(785)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
			{
				p.SetState(784)
				p.Cfws()
			}

		}
		p.SetState(789)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)

		if _la == RFCParserAT {
			{
				p.SetState(787)
				p.Match(RFCParserAT)
			}
			{
				p.SetState(788)
				p.Domain()
			}

		}

		p.SetState(795)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObs_mbox_listContext is an interface to support dynamic dispatch.
type IObs_mbox_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_mbox_listContext differentiates from other interfaces.
	IsObs_mbox_listContext()
}

type Obs_mbox_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_mbox_listContext() *Obs_mbox_listContext {
	var p = new(Obs_mbox_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_mbox_list
	return p
}

func (*Obs_mbox_listContext) IsObs_mbox_listContext() {}

func NewObs_mbox_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_mbox_listContext {
	var p = new(Obs_mbox_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_mbox_list

	return p
}

func (s *Obs_mbox_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_mbox_listContext) AllMailbox() []IMailboxContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IMailboxContext)(nil)).Elem())
	var tst = make([]IMailboxContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IMailboxContext)
		}
	}

	return tst
}

func (s *Obs_mbox_listContext) Mailbox(i int) IMailboxContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IMailboxContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IMailboxContext)
}

func (s *Obs_mbox_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(RFCParserCOMMA)
}

func (s *Obs_mbox_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, i)
}

func (s *Obs_mbox_listContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_mbox_listContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_mbox_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_mbox_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_mbox_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_mbox_list(s)
	}
}

func (s *Obs_mbox_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_mbox_list(s)
	}
}

func (p *RFCParser) Obs_mbox_list() (localctx IObs_mbox_listContext) {
	localctx = NewObs_mbox_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 124, RFCParserRULE_obs_mbox_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(802)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(797)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
				{
					p.SetState(796)
					p.Cfws()
				}

			}
			{
				p.SetState(799)
				p.Match(RFCParserCOMMA)
			}

		}
		p.SetState(804)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 115, p.GetParserRuleContext())
	}
	{
		p.SetState(805)
		p.Mailbox()
	}
	p.SetState(813)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			{
				p.SetState(806)
				p.Match(RFCParserCOMMA)
			}
			p.SetState(809)
			p.GetErrorHandler().Sync(p)

			if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 1 {
				{
					p.SetState(807)
					p.Mailbox()
				}

			} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 116, p.GetParserRuleContext()) == 2 {
				{
					p.SetState(808)
					p.Cfws()
				}

			}

		}
		p.SetState(815)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 117, p.GetParserRuleContext())
	}

	return localctx
}

// IObs_addr_listContext is an interface to support dynamic dispatch.
type IObs_addr_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_addr_listContext differentiates from other interfaces.
	IsObs_addr_listContext()
}

type Obs_addr_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_addr_listContext() *Obs_addr_listContext {
	var p = new(Obs_addr_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_addr_list
	return p
}

func (*Obs_addr_listContext) IsObs_addr_listContext() {}

func NewObs_addr_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_addr_listContext {
	var p = new(Obs_addr_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_addr_list

	return p
}

func (s *Obs_addr_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_addr_listContext) AllAddress() []IAddressContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAddressContext)(nil)).Elem())
	var tst = make([]IAddressContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAddressContext)
		}
	}

	return tst
}

func (s *Obs_addr_listContext) Address(i int) IAddressContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAddressContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAddressContext)
}

func (s *Obs_addr_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(RFCParserCOMMA)
}

func (s *Obs_addr_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, i)
}

func (s *Obs_addr_listContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_addr_listContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_addr_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_addr_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_addr_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_addr_list(s)
	}
}

func (s *Obs_addr_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_addr_list(s)
	}
}

func (p *RFCParser) Obs_addr_list() (localctx IObs_addr_listContext) {
	localctx = NewObs_addr_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 126, RFCParserRULE_obs_addr_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(822)
	p.GetErrorHandler().Sync(p)
	_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())

	for _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		if _alt == 1 {
			p.SetState(817)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
				{
					p.SetState(816)
					p.Cfws()
				}

			}
			{
				p.SetState(819)
				p.Match(RFCParserCOMMA)
			}

		}
		p.SetState(824)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 119, p.GetParserRuleContext())
	}
	{
		p.SetState(825)
		p.Address()
	}
	p.SetState(833)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFCParserCOMMA {
		{
			p.SetState(826)
			p.Match(RFCParserCOMMA)
		}
		p.SetState(829)
		p.GetErrorHandler().Sync(p)

		if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 1 {
			{
				p.SetState(827)
				p.Address()
			}

		} else if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 120, p.GetParserRuleContext()) == 2 {
			{
				p.SetState(828)
				p.Cfws()
			}

		}

		p.SetState(835)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObs_group_listContext is an interface to support dynamic dispatch.
type IObs_group_listContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_group_listContext differentiates from other interfaces.
	IsObs_group_listContext()
}

type Obs_group_listContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_group_listContext() *Obs_group_listContext {
	var p = new(Obs_group_listContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_group_list
	return p
}

func (*Obs_group_listContext) IsObs_group_listContext() {}

func NewObs_group_listContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_group_listContext {
	var p = new(Obs_group_listContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_group_list

	return p
}

func (s *Obs_group_listContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_group_listContext) AllCOMMA() []antlr.TerminalNode {
	return s.GetTokens(RFCParserCOMMA)
}

func (s *Obs_group_listContext) COMMA(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, i)
}

func (s *Obs_group_listContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Obs_group_listContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Obs_group_listContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_group_listContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_group_listContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_group_list(s)
	}
}

func (s *Obs_group_listContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_group_list(s)
	}
}

func (p *RFCParser) Obs_group_list() (localctx IObs_group_listContext) {
	localctx = NewObs_group_listContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 128, RFCParserRULE_obs_group_list)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	var _alt int

	p.EnterOuterAlt(localctx, 1)
	p.SetState(840)
	p.GetErrorHandler().Sync(p)
	_alt = 1
	for ok := true; ok; ok = _alt != 2 && _alt != antlr.ATNInvalidAltNumber {
		switch _alt {
		case 1:
			p.SetState(837)
			p.GetErrorHandler().Sync(p)
			_la = p.GetTokenStream().LA(1)

			if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
				{
					p.SetState(836)
					p.Cfws()
				}

			}
			{
				p.SetState(839)
				p.Match(RFCParserCOMMA)
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(842)
		p.GetErrorHandler().Sync(p)
		_alt = p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 123, p.GetParserRuleContext())
	}
	p.SetState(845)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 124, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(844)
			p.Cfws()
		}

	}

	return localctx
}

// IObs_local_partContext is an interface to support dynamic dispatch.
type IObs_local_partContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_local_partContext differentiates from other interfaces.
	IsObs_local_partContext()
}

type Obs_local_partContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_local_partContext() *Obs_local_partContext {
	var p = new(Obs_local_partContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_local_part
	return p
}

func (*Obs_local_partContext) IsObs_local_partContext() {}

func NewObs_local_partContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_local_partContext {
	var p = new(Obs_local_partContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_local_part

	return p
}

func (s *Obs_local_partContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_local_partContext) AllWord() []IWordContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWordContext)(nil)).Elem())
	var tst = make([]IWordContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWordContext)
		}
	}

	return tst
}

func (s *Obs_local_partContext) Word(i int) IWordContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWordContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWordContext)
}

func (s *Obs_local_partContext) AllPERIOD() []antlr.TerminalNode {
	return s.GetTokens(RFCParserPERIOD)
}

func (s *Obs_local_partContext) PERIOD(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, i)
}

func (s *Obs_local_partContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_local_partContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_local_partContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_local_part(s)
	}
}

func (s *Obs_local_partContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_local_part(s)
	}
}

func (p *RFCParser) Obs_local_part() (localctx IObs_local_partContext) {
	localctx = NewObs_local_partContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 130, RFCParserRULE_obs_local_part)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(847)
		p.Word()
	}
	p.SetState(852)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFCParserPERIOD {
		{
			p.SetState(848)
			p.Match(RFCParserPERIOD)
		}
		{
			p.SetState(849)
			p.Word()
		}

		p.SetState(854)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObs_domainContext is an interface to support dynamic dispatch.
type IObs_domainContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_domainContext differentiates from other interfaces.
	IsObs_domainContext()
}

type Obs_domainContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_domainContext() *Obs_domainContext {
	var p = new(Obs_domainContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_domain
	return p
}

func (*Obs_domainContext) IsObs_domainContext() {}

func NewObs_domainContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_domainContext {
	var p = new(Obs_domainContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_domain

	return p
}

func (s *Obs_domainContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_domainContext) AllAtom() []IAtomContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAtomContext)(nil)).Elem())
	var tst = make([]IAtomContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAtomContext)
		}
	}

	return tst
}

func (s *Obs_domainContext) Atom(i int) IAtomContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAtomContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAtomContext)
}

func (s *Obs_domainContext) AllPERIOD() []antlr.TerminalNode {
	return s.GetTokens(RFCParserPERIOD)
}

func (s *Obs_domainContext) PERIOD(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, i)
}

func (s *Obs_domainContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_domainContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_domainContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_domain(s)
	}
}

func (s *Obs_domainContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_domain(s)
	}
}

func (p *RFCParser) Obs_domain() (localctx IObs_domainContext) {
	localctx = NewObs_domainContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 132, RFCParserRULE_obs_domain)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(855)
		p.Atom()
	}
	p.SetState(860)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for _la == RFCParserPERIOD {
		{
			p.SetState(856)
			p.Match(RFCParserPERIOD)
		}
		{
			p.SetState(857)
			p.Atom()
		}

		p.SetState(862)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IObs_dtextContext is an interface to support dynamic dispatch.
type IObs_dtextContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsObs_dtextContext differentiates from other interfaces.
	IsObs_dtextContext()
}

type Obs_dtextContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyObs_dtextContext() *Obs_dtextContext {
	var p = new(Obs_dtextContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_obs_dtext
	return p
}

func (*Obs_dtextContext) IsObs_dtextContext() {}

func NewObs_dtextContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Obs_dtextContext {
	var p = new(Obs_dtextContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_obs_dtext

	return p
}

func (s *Obs_dtextContext) GetParser() antlr.Parser { return s.parser }

func (s *Obs_dtextContext) Obs_no_ws_ctl() IObs_no_ws_ctlContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IObs_no_ws_ctlContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IObs_no_ws_ctlContext)
}

func (s *Obs_dtextContext) Quoted_pair() IQuoted_pairContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IQuoted_pairContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IQuoted_pairContext)
}

func (s *Obs_dtextContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Obs_dtextContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Obs_dtextContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterObs_dtext(s)
	}
}

func (s *Obs_dtextContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitObs_dtext(s)
	}
}

func (p *RFCParser) Obs_dtext() (localctx IObs_dtextContext) {
	localctx = NewObs_dtextContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 134, RFCParserRULE_obs_dtext)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(865)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserU_0001, RFCParserU_0002, RFCParserU_0003, RFCParserU_0004, RFCParserU_0005, RFCParserU_0006, RFCParserU_0007, RFCParserU_0008, RFCParserU_000B, RFCParserU_000C, RFCParserU_000E, RFCParserU_000F, RFCParserU_0010, RFCParserU_0011, RFCParserU_0012, RFCParserU_0013, RFCParserU_0014, RFCParserU_0015, RFCParserU_0016, RFCParserU_0017, RFCParserU_0018, RFCParserU_0019, RFCParserU_001A, RFCParserU_001B, RFCParserU_001C, RFCParserU_001D, RFCParserU_001E, RFCParserU_001F, RFCParserU_007F:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(863)
			p.Obs_no_ws_ctl()
		}

	case RFCParserBACKSLASH:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(864)
			p.Quoted_pair()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAlphaContext is an interface to support dynamic dispatch.
type IAlphaContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAlphaContext differentiates from other interfaces.
	IsAlphaContext()
}

type AlphaContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAlphaContext() *AlphaContext {
	var p = new(AlphaContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_alpha
	return p
}

func (*AlphaContext) IsAlphaContext() {}

func NewAlphaContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *AlphaContext {
	var p = new(AlphaContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_alpha

	return p
}

func (s *AlphaContext) GetParser() antlr.Parser { return s.parser }

func (s *AlphaContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *AlphaContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *AlphaContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *AlphaContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *AlphaContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *AlphaContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *AlphaContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *AlphaContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *AlphaContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *AlphaContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_J, 0)
}

func (s *AlphaContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_K, 0)
}

func (s *AlphaContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *AlphaContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *AlphaContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *AlphaContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *AlphaContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *AlphaContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Q, 0)
}

func (s *AlphaContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *AlphaContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *AlphaContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *AlphaContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *AlphaContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *AlphaContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *AlphaContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_X, 0)
}

func (s *AlphaContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *AlphaContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Z, 0)
}

func (s *AlphaContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *AlphaContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *AlphaContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *AlphaContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *AlphaContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *AlphaContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *AlphaContext) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *AlphaContext) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *AlphaContext) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *AlphaContext) J() antlr.TerminalNode {
	return s.GetToken(RFCParserJ, 0)
}

func (s *AlphaContext) K() antlr.TerminalNode {
	return s.GetToken(RFCParserK, 0)
}

func (s *AlphaContext) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *AlphaContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *AlphaContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *AlphaContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *AlphaContext) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *AlphaContext) Q() antlr.TerminalNode {
	return s.GetToken(RFCParserQ, 0)
}

func (s *AlphaContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *AlphaContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *AlphaContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *AlphaContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *AlphaContext) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *AlphaContext) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *AlphaContext) X() antlr.TerminalNode {
	return s.GetToken(RFCParserX, 0)
}

func (s *AlphaContext) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *AlphaContext) Z() antlr.TerminalNode {
	return s.GetToken(RFCParserZ, 0)
}

func (s *AlphaContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *AlphaContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *AlphaContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterAlpha(s)
	}
}

func (s *AlphaContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitAlpha(s)
	}
}

func (p *RFCParser) Alpha() (localctx IAlphaContext) {
	localctx = NewAlphaContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 136, RFCParserRULE_alpha)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(869)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(867)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(RFCParserCAP_A-37))|(1<<(RFCParserCAP_B-37))|(1<<(RFCParserCAP_C-37))|(1<<(RFCParserCAP_D-37))|(1<<(RFCParserCAP_E-37))|(1<<(RFCParserCAP_F-37))|(1<<(RFCParserCAP_G-37))|(1<<(RFCParserCAP_H-37))|(1<<(RFCParserCAP_I-37))|(1<<(RFCParserCAP_J-37))|(1<<(RFCParserCAP_K-37))|(1<<(RFCParserCAP_L-37))|(1<<(RFCParserCAP_M-37))|(1<<(RFCParserCAP_N-37))|(1<<(RFCParserCAP_O-37))|(1<<(RFCParserCAP_P-37))|(1<<(RFCParserCAP_Q-37))|(1<<(RFCParserCAP_R-37))|(1<<(RFCParserCAP_S-37))|(1<<(RFCParserCAP_T-37))|(1<<(RFCParserCAP_U-37))|(1<<(RFCParserCAP_V-37))|(1<<(RFCParserCAP_W-37))|(1<<(RFCParserCAP_X-37))|(1<<(RFCParserCAP_Y-37))|(1<<(RFCParserCAP_Z-37)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(868)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(RFCParserA-69))|(1<<(RFCParserB-69))|(1<<(RFCParserC-69))|(1<<(RFCParserD-69))|(1<<(RFCParserE-69))|(1<<(RFCParserF-69))|(1<<(RFCParserG-69))|(1<<(RFCParserH-69))|(1<<(RFCParserI-69))|(1<<(RFCParserJ-69))|(1<<(RFCParserK-69))|(1<<(RFCParserL-69))|(1<<(RFCParserM-69))|(1<<(RFCParserN-69))|(1<<(RFCParserO-69))|(1<<(RFCParserP-69))|(1<<(RFCParserQ-69))|(1<<(RFCParserR-69))|(1<<(RFCParserS-69))|(1<<(RFCParserT-69))|(1<<(RFCParserU-69))|(1<<(RFCParserV-69))|(1<<(RFCParserW-69))|(1<<(RFCParserX-69))|(1<<(RFCParserY-69))|(1<<(RFCParserZ-69)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IBitContext is an interface to support dynamic dispatch.
type IBitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsBitContext differentiates from other interfaces.
	IsBitContext()
}

type BitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyBitContext() *BitContext {
	var p = new(BitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_bit
	return p
}

func (*BitContext) IsBitContext() {}

func NewBitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *BitContext {
	var p = new(BitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_bit

	return p
}

func (s *BitContext) GetParser() antlr.Parser { return s.parser }

func (s *BitContext) ZERO() antlr.TerminalNode {
	return s.GetToken(RFCParserZERO, 0)
}

func (s *BitContext) ONE() antlr.TerminalNode {
	return s.GetToken(RFCParserONE, 0)
}

func (s *BitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *BitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *BitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterBit(s)
	}
}

func (s *BitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitBit(s)
	}
}

func (p *RFCParser) Bit() (localctx IBitContext) {
	localctx = NewBitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 138, RFCParserRULE_bit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(871)
		_la = p.GetTokenStream().LA(1)

		if !(_la == RFCParserZERO || _la == RFCParserONE) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IChar_1Context is an interface to support dynamic dispatch.
type IChar_1Context interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsChar_1Context differentiates from other interfaces.
	IsChar_1Context()
}

type Char_1Context struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyChar_1Context() *Char_1Context {
	var p = new(Char_1Context)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_char_1
	return p
}

func (*Char_1Context) IsChar_1Context() {}

func NewChar_1Context(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Char_1Context {
	var p = new(Char_1Context)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_char_1

	return p
}

func (s *Char_1Context) GetParser() antlr.Parser { return s.parser }

func (s *Char_1Context) U_0001() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0001, 0)
}

func (s *Char_1Context) U_0002() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0002, 0)
}

func (s *Char_1Context) U_0003() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0003, 0)
}

func (s *Char_1Context) U_0004() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0004, 0)
}

func (s *Char_1Context) U_0005() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0005, 0)
}

func (s *Char_1Context) U_0006() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0006, 0)
}

func (s *Char_1Context) U_0007() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0007, 0)
}

func (s *Char_1Context) U_0008() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0008, 0)
}

func (s *Char_1Context) TAB() antlr.TerminalNode {
	return s.GetToken(RFCParserTAB, 0)
}

func (s *Char_1Context) LF() antlr.TerminalNode {
	return s.GetToken(RFCParserLF, 0)
}

func (s *Char_1Context) U_000B() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000B, 0)
}

func (s *Char_1Context) U_000C() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000C, 0)
}

func (s *Char_1Context) CR() antlr.TerminalNode {
	return s.GetToken(RFCParserCR, 0)
}

func (s *Char_1Context) U_000E() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000E, 0)
}

func (s *Char_1Context) U_000F() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000F, 0)
}

func (s *Char_1Context) U_0010() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0010, 0)
}

func (s *Char_1Context) U_0011() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0011, 0)
}

func (s *Char_1Context) U_0012() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0012, 0)
}

func (s *Char_1Context) U_0013() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0013, 0)
}

func (s *Char_1Context) U_0014() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0014, 0)
}

func (s *Char_1Context) U_0015() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0015, 0)
}

func (s *Char_1Context) U_0016() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0016, 0)
}

func (s *Char_1Context) U_0017() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0017, 0)
}

func (s *Char_1Context) U_0018() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0018, 0)
}

func (s *Char_1Context) U_0019() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0019, 0)
}

func (s *Char_1Context) U_001A() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001A, 0)
}

func (s *Char_1Context) U_001B() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001B, 0)
}

func (s *Char_1Context) U_001C() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001C, 0)
}

func (s *Char_1Context) U_001D() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001D, 0)
}

func (s *Char_1Context) U_001E() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001E, 0)
}

func (s *Char_1Context) U_001F() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001F, 0)
}

func (s *Char_1Context) SPACE() antlr.TerminalNode {
	return s.GetToken(RFCParserSPACE, 0)
}

func (s *Char_1Context) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(RFCParserEXCLAMATION, 0)
}

func (s *Char_1Context) QUOTE() antlr.TerminalNode {
	return s.GetToken(RFCParserQUOTE, 0)
}

func (s *Char_1Context) HASH() antlr.TerminalNode {
	return s.GetToken(RFCParserHASH, 0)
}

func (s *Char_1Context) DOLLAR() antlr.TerminalNode {
	return s.GetToken(RFCParserDOLLAR, 0)
}

func (s *Char_1Context) PERCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserPERCENT, 0)
}

func (s *Char_1Context) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(RFCParserAMPERSAND, 0)
}

func (s *Char_1Context) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(RFCParserAPOSTROPHE, 0)
}

func (s *Char_1Context) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_PAREN, 0)
}

func (s *Char_1Context) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_PAREN, 0)
}

func (s *Char_1Context) ASTERISK() antlr.TerminalNode {
	return s.GetToken(RFCParserASTERISK, 0)
}

func (s *Char_1Context) PLUS() antlr.TerminalNode {
	return s.GetToken(RFCParserPLUS, 0)
}

func (s *Char_1Context) COMMA() antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, 0)
}

func (s *Char_1Context) DASH() antlr.TerminalNode {
	return s.GetToken(RFCParserDASH, 0)
}

func (s *Char_1Context) PERIOD() antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, 0)
}

func (s *Char_1Context) SLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserSLASH, 0)
}

func (s *Char_1Context) ZERO() antlr.TerminalNode {
	return s.GetToken(RFCParserZERO, 0)
}

func (s *Char_1Context) ONE() antlr.TerminalNode {
	return s.GetToken(RFCParserONE, 0)
}

func (s *Char_1Context) TWO() antlr.TerminalNode {
	return s.GetToken(RFCParserTWO, 0)
}

func (s *Char_1Context) THREE() antlr.TerminalNode {
	return s.GetToken(RFCParserTHREE, 0)
}

func (s *Char_1Context) FOUR() antlr.TerminalNode {
	return s.GetToken(RFCParserFOUR, 0)
}

func (s *Char_1Context) FIVE() antlr.TerminalNode {
	return s.GetToken(RFCParserFIVE, 0)
}

func (s *Char_1Context) SIX() antlr.TerminalNode {
	return s.GetToken(RFCParserSIX, 0)
}

func (s *Char_1Context) SEVEN() antlr.TerminalNode {
	return s.GetToken(RFCParserSEVEN, 0)
}

func (s *Char_1Context) EIGHT() antlr.TerminalNode {
	return s.GetToken(RFCParserEIGHT, 0)
}

func (s *Char_1Context) NINE() antlr.TerminalNode {
	return s.GetToken(RFCParserNINE, 0)
}

func (s *Char_1Context) COLON() antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, 0)
}

func (s *Char_1Context) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(RFCParserSEMICOLON, 0)
}

func (s *Char_1Context) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserLESS_THAN, 0)
}

func (s *Char_1Context) EQUALS() antlr.TerminalNode {
	return s.GetToken(RFCParserEQUALS, 0)
}

func (s *Char_1Context) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserGREATER_THAN, 0)
}

func (s *Char_1Context) QUESTION() antlr.TerminalNode {
	return s.GetToken(RFCParserQUESTION, 0)
}

func (s *Char_1Context) AT() antlr.TerminalNode {
	return s.GetToken(RFCParserAT, 0)
}

func (s *Char_1Context) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *Char_1Context) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *Char_1Context) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *Char_1Context) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *Char_1Context) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *Char_1Context) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *Char_1Context) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *Char_1Context) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *Char_1Context) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *Char_1Context) CAP_J() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_J, 0)
}

func (s *Char_1Context) CAP_K() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_K, 0)
}

func (s *Char_1Context) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *Char_1Context) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *Char_1Context) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *Char_1Context) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *Char_1Context) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *Char_1Context) CAP_Q() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Q, 0)
}

func (s *Char_1Context) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *Char_1Context) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *Char_1Context) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *Char_1Context) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *Char_1Context) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *Char_1Context) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *Char_1Context) CAP_X() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_X, 0)
}

func (s *Char_1Context) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *Char_1Context) CAP_Z() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Z, 0)
}

func (s *Char_1Context) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_BRACE, 0)
}

func (s *Char_1Context) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserBACKSLASH, 0)
}

func (s *Char_1Context) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_BRACE, 0)
}

func (s *Char_1Context) CARAT() antlr.TerminalNode {
	return s.GetToken(RFCParserCARAT, 0)
}

func (s *Char_1Context) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(RFCParserUNDERSCORE, 0)
}

func (s *Char_1Context) ACCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserACCENT, 0)
}

func (s *Char_1Context) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *Char_1Context) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *Char_1Context) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *Char_1Context) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *Char_1Context) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *Char_1Context) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *Char_1Context) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *Char_1Context) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *Char_1Context) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *Char_1Context) J() antlr.TerminalNode {
	return s.GetToken(RFCParserJ, 0)
}

func (s *Char_1Context) K() antlr.TerminalNode {
	return s.GetToken(RFCParserK, 0)
}

func (s *Char_1Context) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *Char_1Context) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *Char_1Context) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *Char_1Context) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *Char_1Context) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *Char_1Context) Q() antlr.TerminalNode {
	return s.GetToken(RFCParserQ, 0)
}

func (s *Char_1Context) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *Char_1Context) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *Char_1Context) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *Char_1Context) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *Char_1Context) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *Char_1Context) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *Char_1Context) X() antlr.TerminalNode {
	return s.GetToken(RFCParserX, 0)
}

func (s *Char_1Context) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *Char_1Context) Z() antlr.TerminalNode {
	return s.GetToken(RFCParserZ, 0)
}

func (s *Char_1Context) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_CURLY_BRACE, 0)
}

func (s *Char_1Context) PIPE() antlr.TerminalNode {
	return s.GetToken(RFCParserPIPE, 0)
}

func (s *Char_1Context) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_CURLY_BRACE, 0)
}

func (s *Char_1Context) TILDE() antlr.TerminalNode {
	return s.GetToken(RFCParserTILDE, 0)
}

func (s *Char_1Context) U_007F() antlr.TerminalNode {
	return s.GetToken(RFCParserU_007F, 0)
}

func (s *Char_1Context) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Char_1Context) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Char_1Context) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterChar_1(s)
	}
}

func (s *Char_1Context) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitChar_1(s)
	}
}

func (p *RFCParser) Char_1() (localctx IChar_1Context) {
	localctx = NewChar_1Context(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 140, RFCParserRULE_char_1)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(873)
		_la = p.GetTokenStream().LA(1)

		if !((((_la-1)&-(0x1f+1)) == 0 && ((1<<uint((_la-1)))&((1<<(RFCParserTAB-1))|(1<<(RFCParserLF-1))|(1<<(RFCParserCR-1))|(1<<(RFCParserSPACE-1))|(1<<(RFCParserEXCLAMATION-1))|(1<<(RFCParserQUOTE-1))|(1<<(RFCParserHASH-1))|(1<<(RFCParserDOLLAR-1))|(1<<(RFCParserPERCENT-1))|(1<<(RFCParserAMPERSAND-1))|(1<<(RFCParserAPOSTROPHE-1))|(1<<(RFCParserLEFT_PAREN-1))|(1<<(RFCParserRIGHT_PAREN-1))|(1<<(RFCParserASTERISK-1))|(1<<(RFCParserPLUS-1))|(1<<(RFCParserCOMMA-1))|(1<<(RFCParserDASH-1))|(1<<(RFCParserPERIOD-1))|(1<<(RFCParserSLASH-1))|(1<<(RFCParserZERO-1))|(1<<(RFCParserONE-1))|(1<<(RFCParserTWO-1))|(1<<(RFCParserTHREE-1))|(1<<(RFCParserFOUR-1))|(1<<(RFCParserFIVE-1))|(1<<(RFCParserSIX-1))|(1<<(RFCParserSEVEN-1))|(1<<(RFCParserEIGHT-1))|(1<<(RFCParserNINE-1))|(1<<(RFCParserCOLON-1))|(1<<(RFCParserSEMICOLON-1))|(1<<(RFCParserLESS_THAN-1)))) != 0) || (((_la-33)&-(0x1f+1)) == 0 && ((1<<uint((_la-33)))&((1<<(RFCParserEQUALS-33))|(1<<(RFCParserGREATER_THAN-33))|(1<<(RFCParserQUESTION-33))|(1<<(RFCParserAT-33))|(1<<(RFCParserCAP_A-33))|(1<<(RFCParserCAP_B-33))|(1<<(RFCParserCAP_C-33))|(1<<(RFCParserCAP_D-33))|(1<<(RFCParserCAP_E-33))|(1<<(RFCParserCAP_F-33))|(1<<(RFCParserCAP_G-33))|(1<<(RFCParserCAP_H-33))|(1<<(RFCParserCAP_I-33))|(1<<(RFCParserCAP_J-33))|(1<<(RFCParserCAP_K-33))|(1<<(RFCParserCAP_L-33))|(1<<(RFCParserCAP_M-33))|(1<<(RFCParserCAP_N-33))|(1<<(RFCParserCAP_O-33))|(1<<(RFCParserCAP_P-33))|(1<<(RFCParserCAP_Q-33))|(1<<(RFCParserCAP_R-33))|(1<<(RFCParserCAP_S-33))|(1<<(RFCParserCAP_T-33))|(1<<(RFCParserCAP_U-33))|(1<<(RFCParserCAP_V-33))|(1<<(RFCParserCAP_W-33))|(1<<(RFCParserCAP_X-33))|(1<<(RFCParserCAP_Y-33))|(1<<(RFCParserCAP_Z-33))|(1<<(RFCParserLEFT_BRACE-33))|(1<<(RFCParserBACKSLASH-33)))) != 0) || (((_la-65)&-(0x1f+1)) == 0 && ((1<<uint((_la-65)))&((1<<(RFCParserRIGHT_BRACE-65))|(1<<(RFCParserCARAT-65))|(1<<(RFCParserUNDERSCORE-65))|(1<<(RFCParserACCENT-65))|(1<<(RFCParserA-65))|(1<<(RFCParserB-65))|(1<<(RFCParserC-65))|(1<<(RFCParserD-65))|(1<<(RFCParserE-65))|(1<<(RFCParserF-65))|(1<<(RFCParserG-65))|(1<<(RFCParserH-65))|(1<<(RFCParserI-65))|(1<<(RFCParserJ-65))|(1<<(RFCParserK-65))|(1<<(RFCParserL-65))|(1<<(RFCParserM-65))|(1<<(RFCParserN-65))|(1<<(RFCParserO-65))|(1<<(RFCParserP-65))|(1<<(RFCParserQ-65))|(1<<(RFCParserR-65))|(1<<(RFCParserS-65))|(1<<(RFCParserT-65))|(1<<(RFCParserU-65))|(1<<(RFCParserV-65))|(1<<(RFCParserW-65))|(1<<(RFCParserX-65))|(1<<(RFCParserY-65))|(1<<(RFCParserZ-65))|(1<<(RFCParserLEFT_CURLY_BRACE-65))|(1<<(RFCParserPIPE-65)))) != 0) || (((_la-97)&-(0x1f+1)) == 0 && ((1<<uint((_la-97)))&((1<<(RFCParserRIGHT_CURLY_BRACE-97))|(1<<(RFCParserTILDE-97))|(1<<(RFCParserU_0001-97))|(1<<(RFCParserU_0002-97))|(1<<(RFCParserU_0003-97))|(1<<(RFCParserU_0004-97))|(1<<(RFCParserU_0005-97))|(1<<(RFCParserU_0006-97))|(1<<(RFCParserU_0007-97))|(1<<(RFCParserU_0008-97))|(1<<(RFCParserU_000B-97))|(1<<(RFCParserU_000C-97))|(1<<(RFCParserU_000E-97))|(1<<(RFCParserU_000F-97))|(1<<(RFCParserU_0010-97))|(1<<(RFCParserU_0011-97))|(1<<(RFCParserU_0012-97))|(1<<(RFCParserU_0013-97))|(1<<(RFCParserU_0014-97))|(1<<(RFCParserU_0015-97))|(1<<(RFCParserU_0016-97))|(1<<(RFCParserU_0017-97))|(1<<(RFCParserU_0018-97))|(1<<(RFCParserU_0019-97))|(1<<(RFCParserU_001A-97))|(1<<(RFCParserU_001B-97))|(1<<(RFCParserU_001C-97))|(1<<(RFCParserU_001D-97))|(1<<(RFCParserU_001E-97))|(1<<(RFCParserU_001F-97))|(1<<(RFCParserU_007F-97)))) != 0)) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// ICrContext is an interface to support dynamic dispatch.
type ICrContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCrContext differentiates from other interfaces.
	IsCrContext()
}

type CrContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrContext() *CrContext {
	var p = new(CrContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_cr
	return p
}

func (*CrContext) IsCrContext() {}

func NewCrContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrContext {
	var p = new(CrContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_cr

	return p
}

func (s *CrContext) GetParser() antlr.Parser { return s.parser }

func (s *CrContext) CR() antlr.TerminalNode {
	return s.GetToken(RFCParserCR, 0)
}

func (s *CrContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterCr(s)
	}
}

func (s *CrContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitCr(s)
	}
}

func (p *RFCParser) Cr() (localctx ICrContext) {
	localctx = NewCrContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 142, RFCParserRULE_cr)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(875)
		p.Match(RFCParserCR)
	}

	return localctx
}

// ICrlfContext is an interface to support dynamic dispatch.
type ICrlfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCrlfContext differentiates from other interfaces.
	IsCrlfContext()
}

type CrlfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCrlfContext() *CrlfContext {
	var p = new(CrlfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_crlf
	return p
}

func (*CrlfContext) IsCrlfContext() {}

func NewCrlfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CrlfContext {
	var p = new(CrlfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_crlf

	return p
}

func (s *CrlfContext) GetParser() antlr.Parser { return s.parser }

func (s *CrlfContext) Cr() ICrContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICrContext)
}

func (s *CrlfContext) Lf() ILfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ILfContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ILfContext)
}

func (s *CrlfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CrlfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CrlfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterCrlf(s)
	}
}

func (s *CrlfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitCrlf(s)
	}
}

func (p *RFCParser) Crlf() (localctx ICrlfContext) {
	localctx = NewCrlfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 144, RFCParserRULE_crlf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(877)
		p.Cr()
	}
	{
		p.SetState(878)
		p.Lf()
	}

	return localctx
}

// ICtlContext is an interface to support dynamic dispatch.
type ICtlContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCtlContext differentiates from other interfaces.
	IsCtlContext()
}

type CtlContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCtlContext() *CtlContext {
	var p = new(CtlContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_ctl
	return p
}

func (*CtlContext) IsCtlContext() {}

func NewCtlContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CtlContext {
	var p = new(CtlContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_ctl

	return p
}

func (s *CtlContext) GetParser() antlr.Parser { return s.parser }

func (s *CtlContext) U_0000() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0000, 0)
}

func (s *CtlContext) U_0001() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0001, 0)
}

func (s *CtlContext) U_0002() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0002, 0)
}

func (s *CtlContext) U_0003() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0003, 0)
}

func (s *CtlContext) U_0004() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0004, 0)
}

func (s *CtlContext) U_0005() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0005, 0)
}

func (s *CtlContext) U_0006() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0006, 0)
}

func (s *CtlContext) U_0007() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0007, 0)
}

func (s *CtlContext) U_0008() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0008, 0)
}

func (s *CtlContext) TAB() antlr.TerminalNode {
	return s.GetToken(RFCParserTAB, 0)
}

func (s *CtlContext) LF() antlr.TerminalNode {
	return s.GetToken(RFCParserLF, 0)
}

func (s *CtlContext) U_000B() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000B, 0)
}

func (s *CtlContext) U_000C() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000C, 0)
}

func (s *CtlContext) CR() antlr.TerminalNode {
	return s.GetToken(RFCParserCR, 0)
}

func (s *CtlContext) U_000E() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000E, 0)
}

func (s *CtlContext) U_000F() antlr.TerminalNode {
	return s.GetToken(RFCParserU_000F, 0)
}

func (s *CtlContext) U_0010() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0010, 0)
}

func (s *CtlContext) U_0011() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0011, 0)
}

func (s *CtlContext) U_0012() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0012, 0)
}

func (s *CtlContext) U_0013() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0013, 0)
}

func (s *CtlContext) U_0014() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0014, 0)
}

func (s *CtlContext) U_0015() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0015, 0)
}

func (s *CtlContext) U_0016() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0016, 0)
}

func (s *CtlContext) U_0017() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0017, 0)
}

func (s *CtlContext) U_0018() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0018, 0)
}

func (s *CtlContext) U_0019() antlr.TerminalNode {
	return s.GetToken(RFCParserU_0019, 0)
}

func (s *CtlContext) U_001A() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001A, 0)
}

func (s *CtlContext) U_001B() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001B, 0)
}

func (s *CtlContext) U_001C() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001C, 0)
}

func (s *CtlContext) U_001D() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001D, 0)
}

func (s *CtlContext) U_001E() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001E, 0)
}

func (s *CtlContext) U_001F() antlr.TerminalNode {
	return s.GetToken(RFCParserU_001F, 0)
}

func (s *CtlContext) U_007F() antlr.TerminalNode {
	return s.GetToken(RFCParserU_007F, 0)
}

func (s *CtlContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CtlContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CtlContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterCtl(s)
	}
}

func (s *CtlContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitCtl(s)
	}
}

func (p *RFCParser) Ctl() (localctx ICtlContext) {
	localctx = NewCtlContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 146, RFCParserRULE_ctl)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(882)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserTAB, RFCParserLF, RFCParserCR, RFCParserU_0000, RFCParserU_0001, RFCParserU_0002, RFCParserU_0003, RFCParserU_0004, RFCParserU_0005, RFCParserU_0006, RFCParserU_0007, RFCParserU_0008, RFCParserU_000B, RFCParserU_000C, RFCParserU_000E, RFCParserU_000F, RFCParserU_0010, RFCParserU_0011, RFCParserU_0012, RFCParserU_0013, RFCParserU_0014, RFCParserU_0015, RFCParserU_0016, RFCParserU_0017, RFCParserU_0018, RFCParserU_0019, RFCParserU_001A, RFCParserU_001B, RFCParserU_001C, RFCParserU_001D, RFCParserU_001E, RFCParserU_001F:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(880)
			_la = p.GetTokenStream().LA(1)

			if !((((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserLF)|(1<<RFCParserCR))) != 0) || (((_la-99)&-(0x1f+1)) == 0 && ((1<<uint((_la-99)))&((1<<(RFCParserU_0000-99))|(1<<(RFCParserU_0001-99))|(1<<(RFCParserU_0002-99))|(1<<(RFCParserU_0003-99))|(1<<(RFCParserU_0004-99))|(1<<(RFCParserU_0005-99))|(1<<(RFCParserU_0006-99))|(1<<(RFCParserU_0007-99))|(1<<(RFCParserU_0008-99))|(1<<(RFCParserU_000B-99))|(1<<(RFCParserU_000C-99))|(1<<(RFCParserU_000E-99))|(1<<(RFCParserU_000F-99))|(1<<(RFCParserU_0010-99))|(1<<(RFCParserU_0011-99))|(1<<(RFCParserU_0012-99))|(1<<(RFCParserU_0013-99))|(1<<(RFCParserU_0014-99))|(1<<(RFCParserU_0015-99))|(1<<(RFCParserU_0016-99))|(1<<(RFCParserU_0017-99))|(1<<(RFCParserU_0018-99))|(1<<(RFCParserU_0019-99))|(1<<(RFCParserU_001A-99))|(1<<(RFCParserU_001B-99))|(1<<(RFCParserU_001C-99))|(1<<(RFCParserU_001D-99))|(1<<(RFCParserU_001E-99))|(1<<(RFCParserU_001F-99)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserU_007F:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(881)
			p.Match(RFCParserU_007F)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IDigitContext is an interface to support dynamic dispatch.
type IDigitContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDigitContext differentiates from other interfaces.
	IsDigitContext()
}

type DigitContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDigitContext() *DigitContext {
	var p = new(DigitContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_digit
	return p
}

func (*DigitContext) IsDigitContext() {}

func NewDigitContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DigitContext {
	var p = new(DigitContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_digit

	return p
}

func (s *DigitContext) GetParser() antlr.Parser { return s.parser }

func (s *DigitContext) ZERO() antlr.TerminalNode {
	return s.GetToken(RFCParserZERO, 0)
}

func (s *DigitContext) ONE() antlr.TerminalNode {
	return s.GetToken(RFCParserONE, 0)
}

func (s *DigitContext) TWO() antlr.TerminalNode {
	return s.GetToken(RFCParserTWO, 0)
}

func (s *DigitContext) THREE() antlr.TerminalNode {
	return s.GetToken(RFCParserTHREE, 0)
}

func (s *DigitContext) FOUR() antlr.TerminalNode {
	return s.GetToken(RFCParserFOUR, 0)
}

func (s *DigitContext) FIVE() antlr.TerminalNode {
	return s.GetToken(RFCParserFIVE, 0)
}

func (s *DigitContext) SIX() antlr.TerminalNode {
	return s.GetToken(RFCParserSIX, 0)
}

func (s *DigitContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(RFCParserSEVEN, 0)
}

func (s *DigitContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(RFCParserEIGHT, 0)
}

func (s *DigitContext) NINE() antlr.TerminalNode {
	return s.GetToken(RFCParserNINE, 0)
}

func (s *DigitContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DigitContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DigitContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDigit(s)
	}
}

func (s *DigitContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDigit(s)
	}
}

func (p *RFCParser) Digit() (localctx IDigitContext) {
	localctx = NewDigitContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 148, RFCParserRULE_digit)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(884)
		_la = p.GetTokenStream().LA(1)

		if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0) {
			p.GetErrorHandler().RecoverInline(p)
		} else {
			p.GetErrorHandler().ReportMatch(p)
			p.Consume()
		}
	}

	return localctx
}

// IDquoteContext is an interface to support dynamic dispatch.
type IDquoteContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsDquoteContext differentiates from other interfaces.
	IsDquoteContext()
}

type DquoteContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyDquoteContext() *DquoteContext {
	var p = new(DquoteContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_dquote
	return p
}

func (*DquoteContext) IsDquoteContext() {}

func NewDquoteContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *DquoteContext {
	var p = new(DquoteContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_dquote

	return p
}

func (s *DquoteContext) GetParser() antlr.Parser { return s.parser }

func (s *DquoteContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(RFCParserQUOTE, 0)
}

func (s *DquoteContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *DquoteContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *DquoteContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterDquote(s)
	}
}

func (s *DquoteContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitDquote(s)
	}
}

func (p *RFCParser) Dquote() (localctx IDquoteContext) {
	localctx = NewDquoteContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 150, RFCParserRULE_dquote)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(886)
		p.Match(RFCParserQUOTE)
	}

	return localctx
}

// IHexdigContext is an interface to support dynamic dispatch.
type IHexdigContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHexdigContext differentiates from other interfaces.
	IsHexdigContext()
}

type HexdigContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHexdigContext() *HexdigContext {
	var p = new(HexdigContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_hexdig
	return p
}

func (*HexdigContext) IsHexdigContext() {}

func NewHexdigContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HexdigContext {
	var p = new(HexdigContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_hexdig

	return p
}

func (s *HexdigContext) GetParser() antlr.Parser { return s.parser }

func (s *HexdigContext) Digit() IDigitContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IDigitContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IDigitContext)
}

func (s *HexdigContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *HexdigContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *HexdigContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *HexdigContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *HexdigContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *HexdigContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *HexdigContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *HexdigContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *HexdigContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *HexdigContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *HexdigContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *HexdigContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *HexdigContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HexdigContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HexdigContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterHexdig(s)
	}
}

func (s *HexdigContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitHexdig(s)
	}
}

func (p *RFCParser) Hexdig() (localctx IHexdigContext) {
	localctx = NewHexdigContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 152, RFCParserRULE_hexdig)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(895)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(888)
			p.Digit()
		}

	case RFCParserCAP_A, RFCParserA:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(889)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_A || _la == RFCParserA) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserCAP_B, RFCParserB:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(890)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_B || _la == RFCParserB) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserCAP_C, RFCParserC:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(891)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_C || _la == RFCParserC) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserCAP_D, RFCParserD:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(892)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_D || _la == RFCParserD) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserCAP_E, RFCParserE:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(893)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_E || _la == RFCParserE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserCAP_F, RFCParserF:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(894)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserCAP_F || _la == RFCParserF) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IHtabContext is an interface to support dynamic dispatch.
type IHtabContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsHtabContext differentiates from other interfaces.
	IsHtabContext()
}

type HtabContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyHtabContext() *HtabContext {
	var p = new(HtabContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_htab
	return p
}

func (*HtabContext) IsHtabContext() {}

func NewHtabContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *HtabContext {
	var p = new(HtabContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_htab

	return p
}

func (s *HtabContext) GetParser() antlr.Parser { return s.parser }

func (s *HtabContext) TAB() antlr.TerminalNode {
	return s.GetToken(RFCParserTAB, 0)
}

func (s *HtabContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *HtabContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *HtabContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterHtab(s)
	}
}

func (s *HtabContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitHtab(s)
	}
}

func (p *RFCParser) Htab() (localctx IHtabContext) {
	localctx = NewHtabContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 154, RFCParserRULE_htab)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(897)
		p.Match(RFCParserTAB)
	}

	return localctx
}

// ILfContext is an interface to support dynamic dispatch.
type ILfContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLfContext differentiates from other interfaces.
	IsLfContext()
}

type LfContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLfContext() *LfContext {
	var p = new(LfContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_lf
	return p
}

func (*LfContext) IsLfContext() {}

func NewLfContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LfContext {
	var p = new(LfContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_lf

	return p
}

func (s *LfContext) GetParser() antlr.Parser { return s.parser }

func (s *LfContext) LF() antlr.TerminalNode {
	return s.GetToken(RFCParserLF, 0)
}

func (s *LfContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LfContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LfContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterLf(s)
	}
}

func (s *LfContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitLf(s)
	}
}

func (p *RFCParser) Lf() (localctx ILfContext) {
	localctx = NewLfContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 156, RFCParserRULE_lf)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(899)
		p.Match(RFCParserLF)
	}

	return localctx
}

// ILwspContext is an interface to support dynamic dispatch.
type ILwspContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsLwspContext differentiates from other interfaces.
	IsLwspContext()
}

type LwspContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyLwspContext() *LwspContext {
	var p = new(LwspContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_lwsp
	return p
}

func (*LwspContext) IsLwspContext() {}

func NewLwspContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *LwspContext {
	var p = new(LwspContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_lwsp

	return p
}

func (s *LwspContext) GetParser() antlr.Parser { return s.parser }

func (s *LwspContext) AllWsp() []IWspContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IWspContext)(nil)).Elem())
	var tst = make([]IWspContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IWspContext)
		}
	}

	return tst
}

func (s *LwspContext) Wsp(i int) IWspContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IWspContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IWspContext)
}

func (s *LwspContext) AllCrlf() []ICrlfContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICrlfContext)(nil)).Elem())
	var tst = make([]ICrlfContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICrlfContext)
		}
	}

	return tst
}

func (s *LwspContext) Crlf(i int) ICrlfContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICrlfContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICrlfContext)
}

func (s *LwspContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *LwspContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *LwspContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterLwsp(s)
	}
}

func (s *LwspContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitLwsp(s)
	}
}

func (p *RFCParser) Lwsp() (localctx ILwspContext) {
	localctx = NewLwspContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 158, RFCParserRULE_lwsp)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(907)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE))) != 0 {
		p.SetState(905)
		p.GetErrorHandler().Sync(p)

		switch p.GetTokenStream().LA(1) {
		case RFCParserTAB, RFCParserSPACE:
			{
				p.SetState(901)
				p.Wsp()
			}

		case RFCParserCR:
			{
				p.SetState(902)
				p.Crlf()
			}
			{
				p.SetState(903)
				p.Wsp()
			}

		default:
			panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
		}

		p.SetState(909)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// ISpContext is an interface to support dynamic dispatch.
type ISpContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsSpContext differentiates from other interfaces.
	IsSpContext()
}

type SpContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptySpContext() *SpContext {
	var p = new(SpContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_sp
	return p
}

func (*SpContext) IsSpContext() {}

func NewSpContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *SpContext {
	var p = new(SpContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_sp

	return p
}

func (s *SpContext) GetParser() antlr.Parser { return s.parser }

func (s *SpContext) SPACE() antlr.TerminalNode {
	return s.GetToken(RFCParserSPACE, 0)
}

func (s *SpContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *SpContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *SpContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterSp(s)
	}
}

func (s *SpContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitSp(s)
	}
}

func (p *RFCParser) Sp() (localctx ISpContext) {
	localctx = NewSpContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 160, RFCParserRULE_sp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(910)
		p.Match(RFCParserSPACE)
	}

	return localctx
}

// IVcharContext is an interface to support dynamic dispatch.
type IVcharContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsVcharContext differentiates from other interfaces.
	IsVcharContext()
}

type VcharContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyVcharContext() *VcharContext {
	var p = new(VcharContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_vchar
	return p
}

func (*VcharContext) IsVcharContext() {}

func NewVcharContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *VcharContext {
	var p = new(VcharContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_vchar

	return p
}

func (s *VcharContext) GetParser() antlr.Parser { return s.parser }

func (s *VcharContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(RFCParserEXCLAMATION, 0)
}

func (s *VcharContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(RFCParserQUOTE, 0)
}

func (s *VcharContext) HASH() antlr.TerminalNode {
	return s.GetToken(RFCParserHASH, 0)
}

func (s *VcharContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(RFCParserDOLLAR, 0)
}

func (s *VcharContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserPERCENT, 0)
}

func (s *VcharContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(RFCParserAMPERSAND, 0)
}

func (s *VcharContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(RFCParserAPOSTROPHE, 0)
}

func (s *VcharContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_PAREN, 0)
}

func (s *VcharContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_PAREN, 0)
}

func (s *VcharContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(RFCParserASTERISK, 0)
}

func (s *VcharContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RFCParserPLUS, 0)
}

func (s *VcharContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, 0)
}

func (s *VcharContext) DASH() antlr.TerminalNode {
	return s.GetToken(RFCParserDASH, 0)
}

func (s *VcharContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, 0)
}

func (s *VcharContext) SLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserSLASH, 0)
}

func (s *VcharContext) ZERO() antlr.TerminalNode {
	return s.GetToken(RFCParserZERO, 0)
}

func (s *VcharContext) ONE() antlr.TerminalNode {
	return s.GetToken(RFCParserONE, 0)
}

func (s *VcharContext) TWO() antlr.TerminalNode {
	return s.GetToken(RFCParserTWO, 0)
}

func (s *VcharContext) THREE() antlr.TerminalNode {
	return s.GetToken(RFCParserTHREE, 0)
}

func (s *VcharContext) FOUR() antlr.TerminalNode {
	return s.GetToken(RFCParserFOUR, 0)
}

func (s *VcharContext) FIVE() antlr.TerminalNode {
	return s.GetToken(RFCParserFIVE, 0)
}

func (s *VcharContext) SIX() antlr.TerminalNode {
	return s.GetToken(RFCParserSIX, 0)
}

func (s *VcharContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(RFCParserSEVEN, 0)
}

func (s *VcharContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(RFCParserEIGHT, 0)
}

func (s *VcharContext) NINE() antlr.TerminalNode {
	return s.GetToken(RFCParserNINE, 0)
}

func (s *VcharContext) COLON() antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, 0)
}

func (s *VcharContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(RFCParserSEMICOLON, 0)
}

func (s *VcharContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserLESS_THAN, 0)
}

func (s *VcharContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(RFCParserEQUALS, 0)
}

func (s *VcharContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserGREATER_THAN, 0)
}

func (s *VcharContext) QUESTION() antlr.TerminalNode {
	return s.GetToken(RFCParserQUESTION, 0)
}

func (s *VcharContext) AT() antlr.TerminalNode {
	return s.GetToken(RFCParserAT, 0)
}

func (s *VcharContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *VcharContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *VcharContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *VcharContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *VcharContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *VcharContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *VcharContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *VcharContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *VcharContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *VcharContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_J, 0)
}

func (s *VcharContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_K, 0)
}

func (s *VcharContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *VcharContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *VcharContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *VcharContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *VcharContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *VcharContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Q, 0)
}

func (s *VcharContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *VcharContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *VcharContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *VcharContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *VcharContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *VcharContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *VcharContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_X, 0)
}

func (s *VcharContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *VcharContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Z, 0)
}

func (s *VcharContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_BRACE, 0)
}

func (s *VcharContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserBACKSLASH, 0)
}

func (s *VcharContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_BRACE, 0)
}

func (s *VcharContext) CARAT() antlr.TerminalNode {
	return s.GetToken(RFCParserCARAT, 0)
}

func (s *VcharContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(RFCParserUNDERSCORE, 0)
}

func (s *VcharContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserACCENT, 0)
}

func (s *VcharContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *VcharContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *VcharContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *VcharContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *VcharContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *VcharContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *VcharContext) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *VcharContext) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *VcharContext) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *VcharContext) J() antlr.TerminalNode {
	return s.GetToken(RFCParserJ, 0)
}

func (s *VcharContext) K() antlr.TerminalNode {
	return s.GetToken(RFCParserK, 0)
}

func (s *VcharContext) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *VcharContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *VcharContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *VcharContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *VcharContext) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *VcharContext) Q() antlr.TerminalNode {
	return s.GetToken(RFCParserQ, 0)
}

func (s *VcharContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *VcharContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *VcharContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *VcharContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *VcharContext) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *VcharContext) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *VcharContext) X() antlr.TerminalNode {
	return s.GetToken(RFCParserX, 0)
}

func (s *VcharContext) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *VcharContext) Z() antlr.TerminalNode {
	return s.GetToken(RFCParserZ, 0)
}

func (s *VcharContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_CURLY_BRACE, 0)
}

func (s *VcharContext) PIPE() antlr.TerminalNode {
	return s.GetToken(RFCParserPIPE, 0)
}

func (s *VcharContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_CURLY_BRACE, 0)
}

func (s *VcharContext) TILDE() antlr.TerminalNode {
	return s.GetToken(RFCParserTILDE, 0)
}

func (s *VcharContext) U_REST() antlr.TerminalNode {
	return s.GetToken(RFCParserU_REST, 0)
}

func (s *VcharContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *VcharContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *VcharContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterVchar(s)
	}
}

func (s *VcharContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitVchar(s)
	}
}

func (p *RFCParser) Vchar() (localctx IVcharContext) {
	localctx = NewVcharContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 162, RFCParserRULE_vchar)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(914)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserEXCLAMATION, RFCParserQUOTE, RFCParserHASH, RFCParserDOLLAR, RFCParserPERCENT, RFCParserAMPERSAND, RFCParserAPOSTROPHE, RFCParserLEFT_PAREN, RFCParserRIGHT_PAREN, RFCParserASTERISK, RFCParserPLUS, RFCParserCOMMA, RFCParserDASH, RFCParserPERIOD, RFCParserSLASH, RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE, RFCParserCOLON, RFCParserSEMICOLON, RFCParserLESS_THAN, RFCParserEQUALS, RFCParserGREATER_THAN, RFCParserQUESTION, RFCParserAT, RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z, RFCParserLEFT_BRACE, RFCParserBACKSLASH, RFCParserRIGHT_BRACE, RFCParserCARAT, RFCParserUNDERSCORE, RFCParserACCENT, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ, RFCParserLEFT_CURLY_BRACE, RFCParserPIPE, RFCParserRIGHT_CURLY_BRACE, RFCParserTILDE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(912)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-5)&-(0x1f+1)) == 0 && ((1<<uint((_la-5)))&((1<<(RFCParserEXCLAMATION-5))|(1<<(RFCParserQUOTE-5))|(1<<(RFCParserHASH-5))|(1<<(RFCParserDOLLAR-5))|(1<<(RFCParserPERCENT-5))|(1<<(RFCParserAMPERSAND-5))|(1<<(RFCParserAPOSTROPHE-5))|(1<<(RFCParserLEFT_PAREN-5))|(1<<(RFCParserRIGHT_PAREN-5))|(1<<(RFCParserASTERISK-5))|(1<<(RFCParserPLUS-5))|(1<<(RFCParserCOMMA-5))|(1<<(RFCParserDASH-5))|(1<<(RFCParserPERIOD-5))|(1<<(RFCParserSLASH-5))|(1<<(RFCParserZERO-5))|(1<<(RFCParserONE-5))|(1<<(RFCParserTWO-5))|(1<<(RFCParserTHREE-5))|(1<<(RFCParserFOUR-5))|(1<<(RFCParserFIVE-5))|(1<<(RFCParserSIX-5))|(1<<(RFCParserSEVEN-5))|(1<<(RFCParserEIGHT-5))|(1<<(RFCParserNINE-5))|(1<<(RFCParserCOLON-5))|(1<<(RFCParserSEMICOLON-5))|(1<<(RFCParserLESS_THAN-5))|(1<<(RFCParserEQUALS-5))|(1<<(RFCParserGREATER_THAN-5))|(1<<(RFCParserQUESTION-5))|(1<<(RFCParserAT-5)))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(RFCParserCAP_A-37))|(1<<(RFCParserCAP_B-37))|(1<<(RFCParserCAP_C-37))|(1<<(RFCParserCAP_D-37))|(1<<(RFCParserCAP_E-37))|(1<<(RFCParserCAP_F-37))|(1<<(RFCParserCAP_G-37))|(1<<(RFCParserCAP_H-37))|(1<<(RFCParserCAP_I-37))|(1<<(RFCParserCAP_J-37))|(1<<(RFCParserCAP_K-37))|(1<<(RFCParserCAP_L-37))|(1<<(RFCParserCAP_M-37))|(1<<(RFCParserCAP_N-37))|(1<<(RFCParserCAP_O-37))|(1<<(RFCParserCAP_P-37))|(1<<(RFCParserCAP_Q-37))|(1<<(RFCParserCAP_R-37))|(1<<(RFCParserCAP_S-37))|(1<<(RFCParserCAP_T-37))|(1<<(RFCParserCAP_U-37))|(1<<(RFCParserCAP_V-37))|(1<<(RFCParserCAP_W-37))|(1<<(RFCParserCAP_X-37))|(1<<(RFCParserCAP_Y-37))|(1<<(RFCParserCAP_Z-37))|(1<<(RFCParserLEFT_BRACE-37))|(1<<(RFCParserBACKSLASH-37))|(1<<(RFCParserRIGHT_BRACE-37))|(1<<(RFCParserCARAT-37))|(1<<(RFCParserUNDERSCORE-37))|(1<<(RFCParserACCENT-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(RFCParserA-69))|(1<<(RFCParserB-69))|(1<<(RFCParserC-69))|(1<<(RFCParserD-69))|(1<<(RFCParserE-69))|(1<<(RFCParserF-69))|(1<<(RFCParserG-69))|(1<<(RFCParserH-69))|(1<<(RFCParserI-69))|(1<<(RFCParserJ-69))|(1<<(RFCParserK-69))|(1<<(RFCParserL-69))|(1<<(RFCParserM-69))|(1<<(RFCParserN-69))|(1<<(RFCParserO-69))|(1<<(RFCParserP-69))|(1<<(RFCParserQ-69))|(1<<(RFCParserR-69))|(1<<(RFCParserS-69))|(1<<(RFCParserT-69))|(1<<(RFCParserU-69))|(1<<(RFCParserV-69))|(1<<(RFCParserW-69))|(1<<(RFCParserX-69))|(1<<(RFCParserY-69))|(1<<(RFCParserZ-69))|(1<<(RFCParserLEFT_CURLY_BRACE-69))|(1<<(RFCParserPIPE-69))|(1<<(RFCParserRIGHT_CURLY_BRACE-69))|(1<<(RFCParserTILDE-69)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserU_REST:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(913)
			p.Match(RFCParserU_REST)
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IWspContext is an interface to support dynamic dispatch.
type IWspContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsWspContext differentiates from other interfaces.
	IsWspContext()
}

type WspContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyWspContext() *WspContext {
	var p = new(WspContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_wsp
	return p
}

func (*WspContext) IsWspContext() {}

func NewWspContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *WspContext {
	var p = new(WspContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_wsp

	return p
}

func (s *WspContext) GetParser() antlr.Parser { return s.parser }

func (s *WspContext) Sp() ISpContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ISpContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ISpContext)
}

func (s *WspContext) Htab() IHtabContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IHtabContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IHtabContext)
}

func (s *WspContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *WspContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *WspContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterWsp(s)
	}
}

func (s *WspContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitWsp(s)
	}
}

func (p *RFCParser) Wsp() (localctx IWspContext) {
	localctx = NewWspContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 164, RFCParserRULE_wsp)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(918)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserSPACE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(916)
			p.Sp()
		}

	case RFCParserTAB:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(917)
			p.Htab()
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IEncoded_wordContext is an interface to support dynamic dispatch.
type IEncoded_wordContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncoded_wordContext differentiates from other interfaces.
	IsEncoded_wordContext()
}

type Encoded_wordContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncoded_wordContext() *Encoded_wordContext {
	var p = new(Encoded_wordContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_encoded_word
	return p
}

func (*Encoded_wordContext) IsEncoded_wordContext() {}

func NewEncoded_wordContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Encoded_wordContext {
	var p = new(Encoded_wordContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_encoded_word

	return p
}

func (s *Encoded_wordContext) GetParser() antlr.Parser { return s.parser }

func (s *Encoded_wordContext) Charset() ICharsetContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICharsetContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ICharsetContext)
}

func (s *Encoded_wordContext) AllQUESTION() []antlr.TerminalNode {
	return s.GetTokens(RFCParserQUESTION)
}

func (s *Encoded_wordContext) QUESTION(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserQUESTION, i)
}

func (s *Encoded_wordContext) Encoding() IEncodingContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncodingContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncodingContext)
}

func (s *Encoded_wordContext) Encoded_text() IEncoded_textContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IEncoded_textContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(IEncoded_textContext)
}

func (s *Encoded_wordContext) AllEQUALS() []antlr.TerminalNode {
	return s.GetTokens(RFCParserEQUALS)
}

func (s *Encoded_wordContext) EQUALS(i int) antlr.TerminalNode {
	return s.GetToken(RFCParserEQUALS, i)
}

func (s *Encoded_wordContext) AllCfws() []ICfwsContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*ICfwsContext)(nil)).Elem())
	var tst = make([]ICfwsContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(ICfwsContext)
		}
	}

	return tst
}

func (s *Encoded_wordContext) Cfws(i int) ICfwsContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ICfwsContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(ICfwsContext)
}

func (s *Encoded_wordContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Encoded_wordContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Encoded_wordContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterEncoded_word(s)
	}
}

func (s *Encoded_wordContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitEncoded_word(s)
	}
}

func (p *RFCParser) Encoded_word() (localctx IEncoded_wordContext) {
	localctx = NewEncoded_wordContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 166, RFCParserRULE_encoded_word)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(921)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	if ((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserTAB)|(1<<RFCParserCR)|(1<<RFCParserSPACE)|(1<<RFCParserLEFT_PAREN))) != 0 {
		{
			p.SetState(920)
			p.Cfws()
		}

	}

	{
		p.SetState(923)
		p.Match(RFCParserEQUALS)
	}
	{
		p.SetState(924)
		p.Match(RFCParserQUESTION)
	}

	{
		p.SetState(926)
		p.Charset()
	}
	{
		p.SetState(927)
		p.Match(RFCParserQUESTION)
	}
	{
		p.SetState(928)
		p.Encoding()
	}
	{
		p.SetState(929)
		p.Match(RFCParserQUESTION)
	}
	{
		p.SetState(930)
		p.Encoded_text()
	}

	{
		p.SetState(931)
		p.Match(RFCParserQUESTION)
	}
	{
		p.SetState(932)
		p.Match(RFCParserEQUALS)
	}

	p.SetState(935)
	p.GetErrorHandler().Sync(p)

	if p.GetInterpreter().AdaptivePredict(p.GetTokenStream(), 136, p.GetParserRuleContext()) == 1 {
		{
			p.SetState(934)
			p.Cfws()
		}

	}

	return localctx
}

// IAnytext_tokenContext is an interface to support dynamic dispatch.
type IAnytext_tokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnytext_tokenContext differentiates from other interfaces.
	IsAnytext_tokenContext()
}

type Anytext_tokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnytext_tokenContext() *Anytext_tokenContext {
	var p = new(Anytext_tokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_anytext_token
	return p
}

func (*Anytext_tokenContext) IsAnytext_tokenContext() {}

func NewAnytext_tokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Anytext_tokenContext {
	var p = new(Anytext_tokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_anytext_token

	return p
}

func (s *Anytext_tokenContext) GetParser() antlr.Parser { return s.parser }

func (s *Anytext_tokenContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(RFCParserEXCLAMATION, 0)
}

func (s *Anytext_tokenContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(RFCParserQUOTE, 0)
}

func (s *Anytext_tokenContext) HASH() antlr.TerminalNode {
	return s.GetToken(RFCParserHASH, 0)
}

func (s *Anytext_tokenContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(RFCParserDOLLAR, 0)
}

func (s *Anytext_tokenContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserPERCENT, 0)
}

func (s *Anytext_tokenContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(RFCParserAMPERSAND, 0)
}

func (s *Anytext_tokenContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(RFCParserAPOSTROPHE, 0)
}

func (s *Anytext_tokenContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(RFCParserASTERISK, 0)
}

func (s *Anytext_tokenContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RFCParserPLUS, 0)
}

func (s *Anytext_tokenContext) DASH() antlr.TerminalNode {
	return s.GetToken(RFCParserDASH, 0)
}

func (s *Anytext_tokenContext) ZERO() antlr.TerminalNode {
	return s.GetToken(RFCParserZERO, 0)
}

func (s *Anytext_tokenContext) ONE() antlr.TerminalNode {
	return s.GetToken(RFCParserONE, 0)
}

func (s *Anytext_tokenContext) TWO() antlr.TerminalNode {
	return s.GetToken(RFCParserTWO, 0)
}

func (s *Anytext_tokenContext) THREE() antlr.TerminalNode {
	return s.GetToken(RFCParserTHREE, 0)
}

func (s *Anytext_tokenContext) FOUR() antlr.TerminalNode {
	return s.GetToken(RFCParserFOUR, 0)
}

func (s *Anytext_tokenContext) FIVE() antlr.TerminalNode {
	return s.GetToken(RFCParserFIVE, 0)
}

func (s *Anytext_tokenContext) SIX() antlr.TerminalNode {
	return s.GetToken(RFCParserSIX, 0)
}

func (s *Anytext_tokenContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(RFCParserSEVEN, 0)
}

func (s *Anytext_tokenContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(RFCParserEIGHT, 0)
}

func (s *Anytext_tokenContext) NINE() antlr.TerminalNode {
	return s.GetToken(RFCParserNINE, 0)
}

func (s *Anytext_tokenContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *Anytext_tokenContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *Anytext_tokenContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *Anytext_tokenContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *Anytext_tokenContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *Anytext_tokenContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *Anytext_tokenContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *Anytext_tokenContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *Anytext_tokenContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *Anytext_tokenContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_J, 0)
}

func (s *Anytext_tokenContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_K, 0)
}

func (s *Anytext_tokenContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *Anytext_tokenContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *Anytext_tokenContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *Anytext_tokenContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *Anytext_tokenContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *Anytext_tokenContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Q, 0)
}

func (s *Anytext_tokenContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *Anytext_tokenContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *Anytext_tokenContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *Anytext_tokenContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *Anytext_tokenContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *Anytext_tokenContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *Anytext_tokenContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_X, 0)
}

func (s *Anytext_tokenContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *Anytext_tokenContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Z, 0)
}

func (s *Anytext_tokenContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserBACKSLASH, 0)
}

func (s *Anytext_tokenContext) CARAT() antlr.TerminalNode {
	return s.GetToken(RFCParserCARAT, 0)
}

func (s *Anytext_tokenContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(RFCParserUNDERSCORE, 0)
}

func (s *Anytext_tokenContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserACCENT, 0)
}

func (s *Anytext_tokenContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *Anytext_tokenContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *Anytext_tokenContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *Anytext_tokenContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *Anytext_tokenContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *Anytext_tokenContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *Anytext_tokenContext) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *Anytext_tokenContext) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *Anytext_tokenContext) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *Anytext_tokenContext) J() antlr.TerminalNode {
	return s.GetToken(RFCParserJ, 0)
}

func (s *Anytext_tokenContext) K() antlr.TerminalNode {
	return s.GetToken(RFCParserK, 0)
}

func (s *Anytext_tokenContext) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *Anytext_tokenContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *Anytext_tokenContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *Anytext_tokenContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *Anytext_tokenContext) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *Anytext_tokenContext) Q() antlr.TerminalNode {
	return s.GetToken(RFCParserQ, 0)
}

func (s *Anytext_tokenContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *Anytext_tokenContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *Anytext_tokenContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *Anytext_tokenContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *Anytext_tokenContext) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *Anytext_tokenContext) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *Anytext_tokenContext) X() antlr.TerminalNode {
	return s.GetToken(RFCParserX, 0)
}

func (s *Anytext_tokenContext) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *Anytext_tokenContext) Z() antlr.TerminalNode {
	return s.GetToken(RFCParserZ, 0)
}

func (s *Anytext_tokenContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_CURLY_BRACE, 0)
}

func (s *Anytext_tokenContext) PIPE() antlr.TerminalNode {
	return s.GetToken(RFCParserPIPE, 0)
}

func (s *Anytext_tokenContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_CURLY_BRACE, 0)
}

func (s *Anytext_tokenContext) TILDE() antlr.TerminalNode {
	return s.GetToken(RFCParserTILDE, 0)
}

func (s *Anytext_tokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Anytext_tokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Anytext_tokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterAnytext_token(s)
	}
}

func (s *Anytext_tokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitAnytext_token(s)
	}
}

func (p *RFCParser) Anytext_token() (localctx IAnytext_tokenContext) {
	localctx = NewAnytext_tokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 168, RFCParserRULE_anytext_token)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(944)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserEXCLAMATION, RFCParserQUOTE, RFCParserHASH, RFCParserDOLLAR, RFCParserPERCENT, RFCParserAMPERSAND, RFCParserAPOSTROPHE:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(937)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserEXCLAMATION)|(1<<RFCParserQUOTE)|(1<<RFCParserHASH)|(1<<RFCParserDOLLAR)|(1<<RFCParserPERCENT)|(1<<RFCParserAMPERSAND)|(1<<RFCParserAPOSTROPHE))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserASTERISK, RFCParserPLUS:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(938)
			_la = p.GetTokenStream().LA(1)

			if !(_la == RFCParserASTERISK || _la == RFCParserPLUS) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserDASH:
		p.EnterOuterAlt(localctx, 3)
		{
			p.SetState(939)
			p.Match(RFCParserDASH)
		}

	case RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE:
		p.EnterOuterAlt(localctx, 4)
		{
			p.SetState(940)
			_la = p.GetTokenStream().LA(1)

			if !(((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z:
		p.EnterOuterAlt(localctx, 5)
		{
			p.SetState(941)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(RFCParserCAP_A-37))|(1<<(RFCParserCAP_B-37))|(1<<(RFCParserCAP_C-37))|(1<<(RFCParserCAP_D-37))|(1<<(RFCParserCAP_E-37))|(1<<(RFCParserCAP_F-37))|(1<<(RFCParserCAP_G-37))|(1<<(RFCParserCAP_H-37))|(1<<(RFCParserCAP_I-37))|(1<<(RFCParserCAP_J-37))|(1<<(RFCParserCAP_K-37))|(1<<(RFCParserCAP_L-37))|(1<<(RFCParserCAP_M-37))|(1<<(RFCParserCAP_N-37))|(1<<(RFCParserCAP_O-37))|(1<<(RFCParserCAP_P-37))|(1<<(RFCParserCAP_Q-37))|(1<<(RFCParserCAP_R-37))|(1<<(RFCParserCAP_S-37))|(1<<(RFCParserCAP_T-37))|(1<<(RFCParserCAP_U-37))|(1<<(RFCParserCAP_V-37))|(1<<(RFCParserCAP_W-37))|(1<<(RFCParserCAP_X-37))|(1<<(RFCParserCAP_Y-37))|(1<<(RFCParserCAP_Z-37)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserBACKSLASH:
		p.EnterOuterAlt(localctx, 6)
		{
			p.SetState(942)
			p.Match(RFCParserBACKSLASH)
		}

	case RFCParserCARAT, RFCParserUNDERSCORE, RFCParserACCENT, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ, RFCParserLEFT_CURLY_BRACE, RFCParserPIPE, RFCParserRIGHT_CURLY_BRACE, RFCParserTILDE:
		p.EnterOuterAlt(localctx, 7)
		{
			p.SetState(943)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-66)&-(0x1f+1)) == 0 && ((1<<uint((_la-66)))&((1<<(RFCParserCARAT-66))|(1<<(RFCParserUNDERSCORE-66))|(1<<(RFCParserACCENT-66))|(1<<(RFCParserA-66))|(1<<(RFCParserB-66))|(1<<(RFCParserC-66))|(1<<(RFCParserD-66))|(1<<(RFCParserE-66))|(1<<(RFCParserF-66))|(1<<(RFCParserG-66))|(1<<(RFCParserH-66))|(1<<(RFCParserI-66))|(1<<(RFCParserJ-66))|(1<<(RFCParserK-66))|(1<<(RFCParserL-66))|(1<<(RFCParserM-66))|(1<<(RFCParserN-66))|(1<<(RFCParserO-66))|(1<<(RFCParserP-66))|(1<<(RFCParserQ-66))|(1<<(RFCParserR-66))|(1<<(RFCParserS-66))|(1<<(RFCParserT-66))|(1<<(RFCParserU-66))|(1<<(RFCParserV-66))|(1<<(RFCParserW-66))|(1<<(RFCParserX-66))|(1<<(RFCParserY-66))|(1<<(RFCParserZ-66))|(1<<(RFCParserLEFT_CURLY_BRACE-66))|(1<<(RFCParserPIPE-66))|(1<<(RFCParserRIGHT_CURLY_BRACE-66)))) != 0) || _la == RFCParserTILDE) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// IAnytext_etContext is an interface to support dynamic dispatch.
type IAnytext_etContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsAnytext_etContext differentiates from other interfaces.
	IsAnytext_etContext()
}

type Anytext_etContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyAnytext_etContext() *Anytext_etContext {
	var p = new(Anytext_etContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_anytext_et
	return p
}

func (*Anytext_etContext) IsAnytext_etContext() {}

func NewAnytext_etContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Anytext_etContext {
	var p = new(Anytext_etContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_anytext_et

	return p
}

func (s *Anytext_etContext) GetParser() antlr.Parser { return s.parser }

func (s *Anytext_etContext) EXCLAMATION() antlr.TerminalNode {
	return s.GetToken(RFCParserEXCLAMATION, 0)
}

func (s *Anytext_etContext) QUOTE() antlr.TerminalNode {
	return s.GetToken(RFCParserQUOTE, 0)
}

func (s *Anytext_etContext) HASH() antlr.TerminalNode {
	return s.GetToken(RFCParserHASH, 0)
}

func (s *Anytext_etContext) DOLLAR() antlr.TerminalNode {
	return s.GetToken(RFCParserDOLLAR, 0)
}

func (s *Anytext_etContext) PERCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserPERCENT, 0)
}

func (s *Anytext_etContext) AMPERSAND() antlr.TerminalNode {
	return s.GetToken(RFCParserAMPERSAND, 0)
}

func (s *Anytext_etContext) APOSTROPHE() antlr.TerminalNode {
	return s.GetToken(RFCParserAPOSTROPHE, 0)
}

func (s *Anytext_etContext) LEFT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_PAREN, 0)
}

func (s *Anytext_etContext) RIGHT_PAREN() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_PAREN, 0)
}

func (s *Anytext_etContext) ASTERISK() antlr.TerminalNode {
	return s.GetToken(RFCParserASTERISK, 0)
}

func (s *Anytext_etContext) PLUS() antlr.TerminalNode {
	return s.GetToken(RFCParserPLUS, 0)
}

func (s *Anytext_etContext) COMMA() antlr.TerminalNode {
	return s.GetToken(RFCParserCOMMA, 0)
}

func (s *Anytext_etContext) DASH() antlr.TerminalNode {
	return s.GetToken(RFCParserDASH, 0)
}

func (s *Anytext_etContext) PERIOD() antlr.TerminalNode {
	return s.GetToken(RFCParserPERIOD, 0)
}

func (s *Anytext_etContext) SLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserSLASH, 0)
}

func (s *Anytext_etContext) ZERO() antlr.TerminalNode {
	return s.GetToken(RFCParserZERO, 0)
}

func (s *Anytext_etContext) ONE() antlr.TerminalNode {
	return s.GetToken(RFCParserONE, 0)
}

func (s *Anytext_etContext) TWO() antlr.TerminalNode {
	return s.GetToken(RFCParserTWO, 0)
}

func (s *Anytext_etContext) THREE() antlr.TerminalNode {
	return s.GetToken(RFCParserTHREE, 0)
}

func (s *Anytext_etContext) FOUR() antlr.TerminalNode {
	return s.GetToken(RFCParserFOUR, 0)
}

func (s *Anytext_etContext) FIVE() antlr.TerminalNode {
	return s.GetToken(RFCParserFIVE, 0)
}

func (s *Anytext_etContext) SIX() antlr.TerminalNode {
	return s.GetToken(RFCParserSIX, 0)
}

func (s *Anytext_etContext) SEVEN() antlr.TerminalNode {
	return s.GetToken(RFCParserSEVEN, 0)
}

func (s *Anytext_etContext) EIGHT() antlr.TerminalNode {
	return s.GetToken(RFCParserEIGHT, 0)
}

func (s *Anytext_etContext) NINE() antlr.TerminalNode {
	return s.GetToken(RFCParserNINE, 0)
}

func (s *Anytext_etContext) COLON() antlr.TerminalNode {
	return s.GetToken(RFCParserCOLON, 0)
}

func (s *Anytext_etContext) SEMICOLON() antlr.TerminalNode {
	return s.GetToken(RFCParserSEMICOLON, 0)
}

func (s *Anytext_etContext) LESS_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserLESS_THAN, 0)
}

func (s *Anytext_etContext) EQUALS() antlr.TerminalNode {
	return s.GetToken(RFCParserEQUALS, 0)
}

func (s *Anytext_etContext) GREATER_THAN() antlr.TerminalNode {
	return s.GetToken(RFCParserGREATER_THAN, 0)
}

func (s *Anytext_etContext) AT() antlr.TerminalNode {
	return s.GetToken(RFCParserAT, 0)
}

func (s *Anytext_etContext) CAP_A() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_A, 0)
}

func (s *Anytext_etContext) CAP_B() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_B, 0)
}

func (s *Anytext_etContext) CAP_C() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_C, 0)
}

func (s *Anytext_etContext) CAP_D() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_D, 0)
}

func (s *Anytext_etContext) CAP_E() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_E, 0)
}

func (s *Anytext_etContext) CAP_F() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_F, 0)
}

func (s *Anytext_etContext) CAP_G() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_G, 0)
}

func (s *Anytext_etContext) CAP_H() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_H, 0)
}

func (s *Anytext_etContext) CAP_I() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_I, 0)
}

func (s *Anytext_etContext) CAP_J() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_J, 0)
}

func (s *Anytext_etContext) CAP_K() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_K, 0)
}

func (s *Anytext_etContext) CAP_L() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_L, 0)
}

func (s *Anytext_etContext) CAP_M() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_M, 0)
}

func (s *Anytext_etContext) CAP_N() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_N, 0)
}

func (s *Anytext_etContext) CAP_O() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_O, 0)
}

func (s *Anytext_etContext) CAP_P() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_P, 0)
}

func (s *Anytext_etContext) CAP_Q() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Q, 0)
}

func (s *Anytext_etContext) CAP_R() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_R, 0)
}

func (s *Anytext_etContext) CAP_S() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_S, 0)
}

func (s *Anytext_etContext) CAP_T() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_T, 0)
}

func (s *Anytext_etContext) CAP_U() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_U, 0)
}

func (s *Anytext_etContext) CAP_V() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_V, 0)
}

func (s *Anytext_etContext) CAP_W() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_W, 0)
}

func (s *Anytext_etContext) CAP_X() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_X, 0)
}

func (s *Anytext_etContext) CAP_Y() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Y, 0)
}

func (s *Anytext_etContext) CAP_Z() antlr.TerminalNode {
	return s.GetToken(RFCParserCAP_Z, 0)
}

func (s *Anytext_etContext) LEFT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_BRACE, 0)
}

func (s *Anytext_etContext) BACKSLASH() antlr.TerminalNode {
	return s.GetToken(RFCParserBACKSLASH, 0)
}

func (s *Anytext_etContext) RIGHT_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_BRACE, 0)
}

func (s *Anytext_etContext) CARAT() antlr.TerminalNode {
	return s.GetToken(RFCParserCARAT, 0)
}

func (s *Anytext_etContext) UNDERSCORE() antlr.TerminalNode {
	return s.GetToken(RFCParserUNDERSCORE, 0)
}

func (s *Anytext_etContext) ACCENT() antlr.TerminalNode {
	return s.GetToken(RFCParserACCENT, 0)
}

func (s *Anytext_etContext) A() antlr.TerminalNode {
	return s.GetToken(RFCParserA, 0)
}

func (s *Anytext_etContext) B() antlr.TerminalNode {
	return s.GetToken(RFCParserB, 0)
}

func (s *Anytext_etContext) C() antlr.TerminalNode {
	return s.GetToken(RFCParserC, 0)
}

func (s *Anytext_etContext) D() antlr.TerminalNode {
	return s.GetToken(RFCParserD, 0)
}

func (s *Anytext_etContext) E() antlr.TerminalNode {
	return s.GetToken(RFCParserE, 0)
}

func (s *Anytext_etContext) F() antlr.TerminalNode {
	return s.GetToken(RFCParserF, 0)
}

func (s *Anytext_etContext) G() antlr.TerminalNode {
	return s.GetToken(RFCParserG, 0)
}

func (s *Anytext_etContext) H() antlr.TerminalNode {
	return s.GetToken(RFCParserH, 0)
}

func (s *Anytext_etContext) I() antlr.TerminalNode {
	return s.GetToken(RFCParserI, 0)
}

func (s *Anytext_etContext) J() antlr.TerminalNode {
	return s.GetToken(RFCParserJ, 0)
}

func (s *Anytext_etContext) K() antlr.TerminalNode {
	return s.GetToken(RFCParserK, 0)
}

func (s *Anytext_etContext) L() antlr.TerminalNode {
	return s.GetToken(RFCParserL, 0)
}

func (s *Anytext_etContext) M() antlr.TerminalNode {
	return s.GetToken(RFCParserM, 0)
}

func (s *Anytext_etContext) N() antlr.TerminalNode {
	return s.GetToken(RFCParserN, 0)
}

func (s *Anytext_etContext) O() antlr.TerminalNode {
	return s.GetToken(RFCParserO, 0)
}

func (s *Anytext_etContext) P() antlr.TerminalNode {
	return s.GetToken(RFCParserP, 0)
}

func (s *Anytext_etContext) Q() antlr.TerminalNode {
	return s.GetToken(RFCParserQ, 0)
}

func (s *Anytext_etContext) R() antlr.TerminalNode {
	return s.GetToken(RFCParserR, 0)
}

func (s *Anytext_etContext) S() antlr.TerminalNode {
	return s.GetToken(RFCParserS, 0)
}

func (s *Anytext_etContext) T() antlr.TerminalNode {
	return s.GetToken(RFCParserT, 0)
}

func (s *Anytext_etContext) U() antlr.TerminalNode {
	return s.GetToken(RFCParserU, 0)
}

func (s *Anytext_etContext) V() antlr.TerminalNode {
	return s.GetToken(RFCParserV, 0)
}

func (s *Anytext_etContext) W() antlr.TerminalNode {
	return s.GetToken(RFCParserW, 0)
}

func (s *Anytext_etContext) X() antlr.TerminalNode {
	return s.GetToken(RFCParserX, 0)
}

func (s *Anytext_etContext) Y() antlr.TerminalNode {
	return s.GetToken(RFCParserY, 0)
}

func (s *Anytext_etContext) Z() antlr.TerminalNode {
	return s.GetToken(RFCParserZ, 0)
}

func (s *Anytext_etContext) LEFT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserLEFT_CURLY_BRACE, 0)
}

func (s *Anytext_etContext) PIPE() antlr.TerminalNode {
	return s.GetToken(RFCParserPIPE, 0)
}

func (s *Anytext_etContext) RIGHT_CURLY_BRACE() antlr.TerminalNode {
	return s.GetToken(RFCParserRIGHT_CURLY_BRACE, 0)
}

func (s *Anytext_etContext) TILDE() antlr.TerminalNode {
	return s.GetToken(RFCParserTILDE, 0)
}

func (s *Anytext_etContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Anytext_etContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Anytext_etContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterAnytext_et(s)
	}
}

func (s *Anytext_etContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitAnytext_et(s)
	}
}

func (p *RFCParser) Anytext_et() (localctx IAnytext_etContext) {
	localctx = NewAnytext_etContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 170, RFCParserRULE_anytext_et)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.SetState(948)
	p.GetErrorHandler().Sync(p)

	switch p.GetTokenStream().LA(1) {
	case RFCParserEXCLAMATION, RFCParserQUOTE, RFCParserHASH, RFCParserDOLLAR, RFCParserPERCENT, RFCParserAMPERSAND, RFCParserAPOSTROPHE, RFCParserLEFT_PAREN, RFCParserRIGHT_PAREN, RFCParserASTERISK, RFCParserPLUS, RFCParserCOMMA, RFCParserDASH, RFCParserPERIOD, RFCParserSLASH, RFCParserZERO, RFCParserONE, RFCParserTWO, RFCParserTHREE, RFCParserFOUR, RFCParserFIVE, RFCParserSIX, RFCParserSEVEN, RFCParserEIGHT, RFCParserNINE, RFCParserCOLON, RFCParserSEMICOLON, RFCParserLESS_THAN, RFCParserEQUALS, RFCParserGREATER_THAN:
		p.EnterOuterAlt(localctx, 1)
		{
			p.SetState(946)
			_la = p.GetTokenStream().LA(1)

			if !(((_la-5)&-(0x1f+1)) == 0 && ((1<<uint((_la-5)))&((1<<(RFCParserEXCLAMATION-5))|(1<<(RFCParserQUOTE-5))|(1<<(RFCParserHASH-5))|(1<<(RFCParserDOLLAR-5))|(1<<(RFCParserPERCENT-5))|(1<<(RFCParserAMPERSAND-5))|(1<<(RFCParserAPOSTROPHE-5))|(1<<(RFCParserLEFT_PAREN-5))|(1<<(RFCParserRIGHT_PAREN-5))|(1<<(RFCParserASTERISK-5))|(1<<(RFCParserPLUS-5))|(1<<(RFCParserCOMMA-5))|(1<<(RFCParserDASH-5))|(1<<(RFCParserPERIOD-5))|(1<<(RFCParserSLASH-5))|(1<<(RFCParserZERO-5))|(1<<(RFCParserONE-5))|(1<<(RFCParserTWO-5))|(1<<(RFCParserTHREE-5))|(1<<(RFCParserFOUR-5))|(1<<(RFCParserFIVE-5))|(1<<(RFCParserSIX-5))|(1<<(RFCParserSEVEN-5))|(1<<(RFCParserEIGHT-5))|(1<<(RFCParserNINE-5))|(1<<(RFCParserCOLON-5))|(1<<(RFCParserSEMICOLON-5))|(1<<(RFCParserLESS_THAN-5))|(1<<(RFCParserEQUALS-5))|(1<<(RFCParserGREATER_THAN-5)))) != 0) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	case RFCParserAT, RFCParserCAP_A, RFCParserCAP_B, RFCParserCAP_C, RFCParserCAP_D, RFCParserCAP_E, RFCParserCAP_F, RFCParserCAP_G, RFCParserCAP_H, RFCParserCAP_I, RFCParserCAP_J, RFCParserCAP_K, RFCParserCAP_L, RFCParserCAP_M, RFCParserCAP_N, RFCParserCAP_O, RFCParserCAP_P, RFCParserCAP_Q, RFCParserCAP_R, RFCParserCAP_S, RFCParserCAP_T, RFCParserCAP_U, RFCParserCAP_V, RFCParserCAP_W, RFCParserCAP_X, RFCParserCAP_Y, RFCParserCAP_Z, RFCParserLEFT_BRACE, RFCParserBACKSLASH, RFCParserRIGHT_BRACE, RFCParserCARAT, RFCParserUNDERSCORE, RFCParserACCENT, RFCParserA, RFCParserB, RFCParserC, RFCParserD, RFCParserE, RFCParserF, RFCParserG, RFCParserH, RFCParserI, RFCParserJ, RFCParserK, RFCParserL, RFCParserM, RFCParserN, RFCParserO, RFCParserP, RFCParserQ, RFCParserR, RFCParserS, RFCParserT, RFCParserU, RFCParserV, RFCParserW, RFCParserX, RFCParserY, RFCParserZ, RFCParserLEFT_CURLY_BRACE, RFCParserPIPE, RFCParserRIGHT_CURLY_BRACE, RFCParserTILDE:
		p.EnterOuterAlt(localctx, 2)
		{
			p.SetState(947)
			_la = p.GetTokenStream().LA(1)

			if !((((_la-36)&-(0x1f+1)) == 0 && ((1<<uint((_la-36)))&((1<<(RFCParserAT-36))|(1<<(RFCParserCAP_A-36))|(1<<(RFCParserCAP_B-36))|(1<<(RFCParserCAP_C-36))|(1<<(RFCParserCAP_D-36))|(1<<(RFCParserCAP_E-36))|(1<<(RFCParserCAP_F-36))|(1<<(RFCParserCAP_G-36))|(1<<(RFCParserCAP_H-36))|(1<<(RFCParserCAP_I-36))|(1<<(RFCParserCAP_J-36))|(1<<(RFCParserCAP_K-36))|(1<<(RFCParserCAP_L-36))|(1<<(RFCParserCAP_M-36))|(1<<(RFCParserCAP_N-36))|(1<<(RFCParserCAP_O-36))|(1<<(RFCParserCAP_P-36))|(1<<(RFCParserCAP_Q-36))|(1<<(RFCParserCAP_R-36))|(1<<(RFCParserCAP_S-36))|(1<<(RFCParserCAP_T-36))|(1<<(RFCParserCAP_U-36))|(1<<(RFCParserCAP_V-36))|(1<<(RFCParserCAP_W-36))|(1<<(RFCParserCAP_X-36))|(1<<(RFCParserCAP_Y-36))|(1<<(RFCParserCAP_Z-36))|(1<<(RFCParserLEFT_BRACE-36))|(1<<(RFCParserBACKSLASH-36))|(1<<(RFCParserRIGHT_BRACE-36))|(1<<(RFCParserCARAT-36))|(1<<(RFCParserUNDERSCORE-36)))) != 0) || (((_la-68)&-(0x1f+1)) == 0 && ((1<<uint((_la-68)))&((1<<(RFCParserACCENT-68))|(1<<(RFCParserA-68))|(1<<(RFCParserB-68))|(1<<(RFCParserC-68))|(1<<(RFCParserD-68))|(1<<(RFCParserE-68))|(1<<(RFCParserF-68))|(1<<(RFCParserG-68))|(1<<(RFCParserH-68))|(1<<(RFCParserI-68))|(1<<(RFCParserJ-68))|(1<<(RFCParserK-68))|(1<<(RFCParserL-68))|(1<<(RFCParserM-68))|(1<<(RFCParserN-68))|(1<<(RFCParserO-68))|(1<<(RFCParserP-68))|(1<<(RFCParserQ-68))|(1<<(RFCParserR-68))|(1<<(RFCParserS-68))|(1<<(RFCParserT-68))|(1<<(RFCParserU-68))|(1<<(RFCParserV-68))|(1<<(RFCParserW-68))|(1<<(RFCParserX-68))|(1<<(RFCParserY-68))|(1<<(RFCParserZ-68))|(1<<(RFCParserLEFT_CURLY_BRACE-68))|(1<<(RFCParserPIPE-68))|(1<<(RFCParserRIGHT_CURLY_BRACE-68))|(1<<(RFCParserTILDE-68)))) != 0)) {
				p.GetErrorHandler().RecoverInline(p)
			} else {
				p.GetErrorHandler().ReportMatch(p)
				p.Consume()
			}
		}

	default:
		panic(antlr.NewNoViableAltException(p, nil, nil, nil, nil, nil))
	}

	return localctx
}

// ICharsetContext is an interface to support dynamic dispatch.
type ICharsetContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsCharsetContext differentiates from other interfaces.
	IsCharsetContext()
}

type CharsetContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyCharsetContext() *CharsetContext {
	var p = new(CharsetContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_charset
	return p
}

func (*CharsetContext) IsCharsetContext() {}

func NewCharsetContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *CharsetContext {
	var p = new(CharsetContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_charset

	return p
}

func (s *CharsetContext) GetParser() antlr.Parser { return s.parser }

func (s *CharsetContext) Token() ITokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokenContext)
}

func (s *CharsetContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *CharsetContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *CharsetContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterCharset(s)
	}
}

func (s *CharsetContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitCharset(s)
	}
}

func (p *RFCParser) Charset() (localctx ICharsetContext) {
	localctx = NewCharsetContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 172, RFCParserRULE_charset)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(950)
		p.Token()
	}

	return localctx
}

// IEncodingContext is an interface to support dynamic dispatch.
type IEncodingContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncodingContext differentiates from other interfaces.
	IsEncodingContext()
}

type EncodingContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncodingContext() *EncodingContext {
	var p = new(EncodingContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_encoding
	return p
}

func (*EncodingContext) IsEncodingContext() {}

func NewEncodingContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *EncodingContext {
	var p = new(EncodingContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_encoding

	return p
}

func (s *EncodingContext) GetParser() antlr.Parser { return s.parser }

func (s *EncodingContext) Token() ITokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*ITokenContext)(nil)).Elem(), 0)

	if t == nil {
		return nil
	}

	return t.(ITokenContext)
}

func (s *EncodingContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *EncodingContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *EncodingContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterEncoding(s)
	}
}

func (s *EncodingContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitEncoding(s)
	}
}

func (p *RFCParser) Encoding() (localctx IEncodingContext) {
	localctx = NewEncodingContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 174, RFCParserRULE_encoding)

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	{
		p.SetState(952)
		p.Token()
	}

	return localctx
}

// ITokenContext is an interface to support dynamic dispatch.
type ITokenContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsTokenContext differentiates from other interfaces.
	IsTokenContext()
}

type TokenContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyTokenContext() *TokenContext {
	var p = new(TokenContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_token
	return p
}

func (*TokenContext) IsTokenContext() {}

func NewTokenContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *TokenContext {
	var p = new(TokenContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_token

	return p
}

func (s *TokenContext) GetParser() antlr.Parser { return s.parser }

func (s *TokenContext) AllAnytext_token() []IAnytext_tokenContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnytext_tokenContext)(nil)).Elem())
	var tst = make([]IAnytext_tokenContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnytext_tokenContext)
		}
	}

	return tst
}

func (s *TokenContext) Anytext_token(i int) IAnytext_tokenContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnytext_tokenContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnytext_tokenContext)
}

func (s *TokenContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *TokenContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *TokenContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterToken(s)
	}
}

func (s *TokenContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitToken(s)
	}
}

func (p *RFCParser) Token() (localctx ITokenContext) {
	localctx = NewTokenContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 176, RFCParserRULE_token)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(955)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la)&-(0x1f+1)) == 0 && ((1<<uint(_la))&((1<<RFCParserEXCLAMATION)|(1<<RFCParserQUOTE)|(1<<RFCParserHASH)|(1<<RFCParserDOLLAR)|(1<<RFCParserPERCENT)|(1<<RFCParserAMPERSAND)|(1<<RFCParserAPOSTROPHE)|(1<<RFCParserASTERISK)|(1<<RFCParserPLUS)|(1<<RFCParserDASH)|(1<<RFCParserZERO)|(1<<RFCParserONE)|(1<<RFCParserTWO)|(1<<RFCParserTHREE)|(1<<RFCParserFOUR)|(1<<RFCParserFIVE)|(1<<RFCParserSIX)|(1<<RFCParserSEVEN)|(1<<RFCParserEIGHT)|(1<<RFCParserNINE))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(RFCParserCAP_A-37))|(1<<(RFCParserCAP_B-37))|(1<<(RFCParserCAP_C-37))|(1<<(RFCParserCAP_D-37))|(1<<(RFCParserCAP_E-37))|(1<<(RFCParserCAP_F-37))|(1<<(RFCParserCAP_G-37))|(1<<(RFCParserCAP_H-37))|(1<<(RFCParserCAP_I-37))|(1<<(RFCParserCAP_J-37))|(1<<(RFCParserCAP_K-37))|(1<<(RFCParserCAP_L-37))|(1<<(RFCParserCAP_M-37))|(1<<(RFCParserCAP_N-37))|(1<<(RFCParserCAP_O-37))|(1<<(RFCParserCAP_P-37))|(1<<(RFCParserCAP_Q-37))|(1<<(RFCParserCAP_R-37))|(1<<(RFCParserCAP_S-37))|(1<<(RFCParserCAP_T-37))|(1<<(RFCParserCAP_U-37))|(1<<(RFCParserCAP_V-37))|(1<<(RFCParserCAP_W-37))|(1<<(RFCParserCAP_X-37))|(1<<(RFCParserCAP_Y-37))|(1<<(RFCParserCAP_Z-37))|(1<<(RFCParserBACKSLASH-37))|(1<<(RFCParserCARAT-37))|(1<<(RFCParserUNDERSCORE-37))|(1<<(RFCParserACCENT-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(RFCParserA-69))|(1<<(RFCParserB-69))|(1<<(RFCParserC-69))|(1<<(RFCParserD-69))|(1<<(RFCParserE-69))|(1<<(RFCParserF-69))|(1<<(RFCParserG-69))|(1<<(RFCParserH-69))|(1<<(RFCParserI-69))|(1<<(RFCParserJ-69))|(1<<(RFCParserK-69))|(1<<(RFCParserL-69))|(1<<(RFCParserM-69))|(1<<(RFCParserN-69))|(1<<(RFCParserO-69))|(1<<(RFCParserP-69))|(1<<(RFCParserQ-69))|(1<<(RFCParserR-69))|(1<<(RFCParserS-69))|(1<<(RFCParserT-69))|(1<<(RFCParserU-69))|(1<<(RFCParserV-69))|(1<<(RFCParserW-69))|(1<<(RFCParserX-69))|(1<<(RFCParserY-69))|(1<<(RFCParserZ-69))|(1<<(RFCParserLEFT_CURLY_BRACE-69))|(1<<(RFCParserPIPE-69))|(1<<(RFCParserRIGHT_CURLY_BRACE-69))|(1<<(RFCParserTILDE-69)))) != 0) {
		{
			p.SetState(954)
			p.Anytext_token()
		}

		p.SetState(957)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}

// IEncoded_textContext is an interface to support dynamic dispatch.
type IEncoded_textContext interface {
	antlr.ParserRuleContext

	// GetParser returns the parser.
	GetParser() antlr.Parser

	// IsEncoded_textContext differentiates from other interfaces.
	IsEncoded_textContext()
}

type Encoded_textContext struct {
	*antlr.BaseParserRuleContext
	parser antlr.Parser
}

func NewEmptyEncoded_textContext() *Encoded_textContext {
	var p = new(Encoded_textContext)
	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(nil, -1)
	p.RuleIndex = RFCParserRULE_encoded_text
	return p
}

func (*Encoded_textContext) IsEncoded_textContext() {}

func NewEncoded_textContext(parser antlr.Parser, parent antlr.ParserRuleContext, invokingState int) *Encoded_textContext {
	var p = new(Encoded_textContext)

	p.BaseParserRuleContext = antlr.NewBaseParserRuleContext(parent, invokingState)

	p.parser = parser
	p.RuleIndex = RFCParserRULE_encoded_text

	return p
}

func (s *Encoded_textContext) GetParser() antlr.Parser { return s.parser }

func (s *Encoded_textContext) AllAnytext_et() []IAnytext_etContext {
	var ts = s.GetTypedRuleContexts(reflect.TypeOf((*IAnytext_etContext)(nil)).Elem())
	var tst = make([]IAnytext_etContext, len(ts))

	for i, t := range ts {
		if t != nil {
			tst[i] = t.(IAnytext_etContext)
		}
	}

	return tst
}

func (s *Encoded_textContext) Anytext_et(i int) IAnytext_etContext {
	var t = s.GetTypedRuleContext(reflect.TypeOf((*IAnytext_etContext)(nil)).Elem(), i)

	if t == nil {
		return nil
	}

	return t.(IAnytext_etContext)
}

func (s *Encoded_textContext) GetRuleContext() antlr.RuleContext {
	return s
}

func (s *Encoded_textContext) ToStringTree(ruleNames []string, recog antlr.Recognizer) string {
	return antlr.TreesStringTree(s, ruleNames, recog)
}

func (s *Encoded_textContext) EnterRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.EnterEncoded_text(s)
	}
}

func (s *Encoded_textContext) ExitRule(listener antlr.ParseTreeListener) {
	if listenerT, ok := listener.(RFCListener); ok {
		listenerT.ExitEncoded_text(s)
	}
}

func (p *RFCParser) Encoded_text() (localctx IEncoded_textContext) {
	localctx = NewEncoded_textContext(p, p.GetParserRuleContext(), p.GetState())
	p.EnterRule(localctx, 178, RFCParserRULE_encoded_text)
	var _la int

	defer func() {
		p.ExitRule()
	}()

	defer func() {
		if err := recover(); err != nil {
			if v, ok := err.(antlr.RecognitionException); ok {
				localctx.SetException(v)
				p.GetErrorHandler().ReportError(p, v)
				p.GetErrorHandler().Recover(p, v)
			} else {
				panic(err)
			}
		}
	}()

	p.EnterOuterAlt(localctx, 1)
	p.SetState(960)
	p.GetErrorHandler().Sync(p)
	_la = p.GetTokenStream().LA(1)

	for ok := true; ok; ok = (((_la-5)&-(0x1f+1)) == 0 && ((1<<uint((_la-5)))&((1<<(RFCParserEXCLAMATION-5))|(1<<(RFCParserQUOTE-5))|(1<<(RFCParserHASH-5))|(1<<(RFCParserDOLLAR-5))|(1<<(RFCParserPERCENT-5))|(1<<(RFCParserAMPERSAND-5))|(1<<(RFCParserAPOSTROPHE-5))|(1<<(RFCParserLEFT_PAREN-5))|(1<<(RFCParserRIGHT_PAREN-5))|(1<<(RFCParserASTERISK-5))|(1<<(RFCParserPLUS-5))|(1<<(RFCParserCOMMA-5))|(1<<(RFCParserDASH-5))|(1<<(RFCParserPERIOD-5))|(1<<(RFCParserSLASH-5))|(1<<(RFCParserZERO-5))|(1<<(RFCParserONE-5))|(1<<(RFCParserTWO-5))|(1<<(RFCParserTHREE-5))|(1<<(RFCParserFOUR-5))|(1<<(RFCParserFIVE-5))|(1<<(RFCParserSIX-5))|(1<<(RFCParserSEVEN-5))|(1<<(RFCParserEIGHT-5))|(1<<(RFCParserNINE-5))|(1<<(RFCParserCOLON-5))|(1<<(RFCParserSEMICOLON-5))|(1<<(RFCParserLESS_THAN-5))|(1<<(RFCParserEQUALS-5))|(1<<(RFCParserGREATER_THAN-5))|(1<<(RFCParserAT-5)))) != 0) || (((_la-37)&-(0x1f+1)) == 0 && ((1<<uint((_la-37)))&((1<<(RFCParserCAP_A-37))|(1<<(RFCParserCAP_B-37))|(1<<(RFCParserCAP_C-37))|(1<<(RFCParserCAP_D-37))|(1<<(RFCParserCAP_E-37))|(1<<(RFCParserCAP_F-37))|(1<<(RFCParserCAP_G-37))|(1<<(RFCParserCAP_H-37))|(1<<(RFCParserCAP_I-37))|(1<<(RFCParserCAP_J-37))|(1<<(RFCParserCAP_K-37))|(1<<(RFCParserCAP_L-37))|(1<<(RFCParserCAP_M-37))|(1<<(RFCParserCAP_N-37))|(1<<(RFCParserCAP_O-37))|(1<<(RFCParserCAP_P-37))|(1<<(RFCParserCAP_Q-37))|(1<<(RFCParserCAP_R-37))|(1<<(RFCParserCAP_S-37))|(1<<(RFCParserCAP_T-37))|(1<<(RFCParserCAP_U-37))|(1<<(RFCParserCAP_V-37))|(1<<(RFCParserCAP_W-37))|(1<<(RFCParserCAP_X-37))|(1<<(RFCParserCAP_Y-37))|(1<<(RFCParserCAP_Z-37))|(1<<(RFCParserLEFT_BRACE-37))|(1<<(RFCParserBACKSLASH-37))|(1<<(RFCParserRIGHT_BRACE-37))|(1<<(RFCParserCARAT-37))|(1<<(RFCParserUNDERSCORE-37))|(1<<(RFCParserACCENT-37)))) != 0) || (((_la-69)&-(0x1f+1)) == 0 && ((1<<uint((_la-69)))&((1<<(RFCParserA-69))|(1<<(RFCParserB-69))|(1<<(RFCParserC-69))|(1<<(RFCParserD-69))|(1<<(RFCParserE-69))|(1<<(RFCParserF-69))|(1<<(RFCParserG-69))|(1<<(RFCParserH-69))|(1<<(RFCParserI-69))|(1<<(RFCParserJ-69))|(1<<(RFCParserK-69))|(1<<(RFCParserL-69))|(1<<(RFCParserM-69))|(1<<(RFCParserN-69))|(1<<(RFCParserO-69))|(1<<(RFCParserP-69))|(1<<(RFCParserQ-69))|(1<<(RFCParserR-69))|(1<<(RFCParserS-69))|(1<<(RFCParserT-69))|(1<<(RFCParserU-69))|(1<<(RFCParserV-69))|(1<<(RFCParserW-69))|(1<<(RFCParserX-69))|(1<<(RFCParserY-69))|(1<<(RFCParserZ-69))|(1<<(RFCParserLEFT_CURLY_BRACE-69))|(1<<(RFCParserPIPE-69))|(1<<(RFCParserRIGHT_CURLY_BRACE-69))|(1<<(RFCParserTILDE-69)))) != 0) {
		{
			p.SetState(959)
			p.Anytext_et()
		}

		p.SetState(962)
		p.GetErrorHandler().Sync(p)
		_la = p.GetTokenStream().LA(1)
	}

	return localctx
}
